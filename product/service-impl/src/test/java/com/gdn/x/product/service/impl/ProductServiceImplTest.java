package com.gdn.x.product.service.impl;

import static com.gdn.x.product.domain.event.config.ProductDomainEventName.PRODUCT_PREORDER_STATUS;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.CURRENCY;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.GENERATED_ITEM_NAME;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.ID;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.MASTER_CATALOG;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.MERCHANT_SKU;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.PRODUCT_ITEM_ID;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.PRODUCT_NAME;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.SKU_CODE;
import static com.gdn.x.product.domain.event.enums.ProductFieldNames.URL;
import static com.gdn.x.product.enums.ItemChangeEventType.HALAL_CONFIG_CHANGE;
import static java.util.stream.Collectors.toSet;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.notNullValue;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyMap;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.initMocks;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.gdn.x.product.domain.event.model.CompressedVideoUpdateEventModel;
import com.gdn.x.product.domain.event.model.VideoCompressionEventModel;
import com.gdn.x.product.model.entity.Video;
import com.gdn.x.product.rest.web.model.request.OmniChannelSkuUpdateRequest;
import com.gdn.x.product.rest.web.model.request.ProductBasicMasterFieldsRequest;
import com.gdn.x.product.model.vo.ReelProductListingRequestVo;
import com.gdn.x.product.rest.web.model.request.ProductEditRequest;
import com.gdn.x.product.rest.web.model.request.ReelProductListingRequest;
import com.gdn.x.product.rest.web.model.response.ReelProductDetailResponse;
import com.gdn.x.product.service.properties.KafkaTopicProperties;
import com.gdn.x.productcategorybase.dto.VideoDTO;
import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.log4j.MDC;
import org.dozer.DozerBeanMapper;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.gdn.common.base.mapper.GdnMapper;
import com.gdn.common.base.mapper.impl.DozerMapper;
import com.gdn.common.exception.ApplicationRuntimeException;
import com.gdn.common.web.wrapper.response.GdnRestSingleResponse;
import com.gdn.warehouse.itemmaster.command.model.biilofmaterial.CreateUpdateBillOfMaterialRecipeCommandRequest;
import com.gdn.warehouse.itemmaster.webmodel.response.CreateUpdateBOMRecipeResponse;
import com.gdn.x.businesspartner.dto.CompanyDTO;
import com.gdn.x.businesspartner.dto.ProductCounterResponse;
import com.gdn.x.businesspartner.dto.ProfileResponse;
import com.gdn.x.product.dao.api.ItemRepository;
import com.gdn.x.product.dao.api.ProductRepository;
import com.gdn.x.product.dao.solr.api.ProductAndItemSolrRepository;
import com.gdn.x.product.dao.solr.api.ProductSolrRepository;
import com.gdn.x.product.domain.event.config.ProductDomainEventName;
import com.gdn.x.product.domain.event.enums.ItemPickupPointChangeEventType;
import com.gdn.x.product.domain.event.enums.ProductChangeEventType;
import com.gdn.x.product.domain.event.model.CategoryProductSkuMappingRequest;
import com.gdn.x.product.domain.event.model.ExternalSearchReindexToSolrEventModel;
import com.gdn.x.product.domain.event.model.HalalHistoryUpdateEventModel;
import com.gdn.x.product.domain.event.model.ItemCacheClearModel;
import com.gdn.x.product.domain.event.model.ProductAndItemEventModel;
import com.gdn.x.product.domain.event.model.ProductChange;
import com.gdn.x.product.domain.event.model.ProductPreOrderStatus;
import com.gdn.x.product.domain.event.model.ProductSkuToSalesCatalogMappingRequest;
import com.gdn.x.product.enums.ChannelName;
import com.gdn.x.product.enums.Constants;
import com.gdn.x.product.enums.CurationStatus;
import com.gdn.x.product.enums.DescriptiveAttributeValueType;
import com.gdn.x.product.enums.ItemChangeEventType;
import com.gdn.x.product.enums.MasterDataAttributeType;
import com.gdn.x.product.enums.ProductCenterActivity;
import com.gdn.x.product.enums.ProductFieldNames;
import com.gdn.x.product.enums.ProductType;
import com.gdn.x.product.enums.PromoType;
import com.gdn.x.product.enums.SystemParameterNames;
import com.gdn.x.product.exception.ApiIncorrectInputDataException;
import com.gdn.x.product.model.entity.B2bFields;
import com.gdn.x.product.model.entity.BusinessPartner;
import com.gdn.x.product.model.entity.BusinessPartnerPickupPoint;
import com.gdn.x.product.model.entity.BusinessPartnerPromo;
import com.gdn.x.product.model.entity.Category;
import com.gdn.x.product.model.entity.DiscountPrice;
import com.gdn.x.product.model.entity.Item;
import com.gdn.x.product.model.entity.ItemBuyableSchedule;
import com.gdn.x.product.model.entity.ItemDiscoverableSchedule;
import com.gdn.x.product.model.entity.ItemPickupPoint;
import com.gdn.x.product.model.entity.ItemViewConfig;
import com.gdn.x.product.model.entity.MasterCatalog;
import com.gdn.x.product.model.entity.MasterDataAllowedAttributeValue;
import com.gdn.x.product.model.entity.MasterDataAttribute;
import com.gdn.x.product.model.entity.MasterDataItem;
import com.gdn.x.product.model.entity.MasterDataItemAttributeValue;
import com.gdn.x.product.model.entity.MasterDataItemImage;
import com.gdn.x.product.model.entity.MasterDataProduct;
import com.gdn.x.product.model.entity.MasterDataProductAttribute;
import com.gdn.x.product.model.entity.MasterDataProductAttributeValue;
import com.gdn.x.product.model.entity.MasterDataProductImage;
import com.gdn.x.product.model.entity.OfflineItem;
import com.gdn.x.product.model.entity.PreOrder;
import com.gdn.x.product.model.entity.PredefinedAllowedAttributeValue;
import com.gdn.x.product.model.entity.Price;
import com.gdn.x.product.model.entity.PristineDataItem;
import com.gdn.x.product.model.entity.Product;
import com.gdn.x.product.model.entity.ProductAttribute;
import com.gdn.x.product.model.entity.ProductAttributeDetail;
import com.gdn.x.product.model.entity.ProductRetryEventPublish;
import com.gdn.x.product.model.entity.ProductScore;
import com.gdn.x.product.model.entity.ProductSpecialAttribute;
import com.gdn.x.product.model.entity.SalesCatalog;
import com.gdn.x.product.model.entity.SalesCategorySequence;
import com.gdn.x.product.model.entity.SystemParameter;
import com.gdn.x.product.model.solr.ProductAndItemSolr;
import com.gdn.x.product.model.solr.ProductSolr;
import com.gdn.x.product.model.vo.B2bFieldsVo;
import com.gdn.x.product.model.vo.BulkDownloadProductBasicInfoResponse;
import com.gdn.x.product.model.vo.BundleRecipeVo;
import com.gdn.x.product.model.vo.ItemCatalogVO;
import com.gdn.x.product.model.vo.ItemPickupPointVo;
import com.gdn.x.product.model.vo.ItemVo;
import com.gdn.x.product.model.vo.MasterDataCacheVo;
import com.gdn.x.product.model.vo.MasterDataProductAndItemsVO;
import com.gdn.x.product.model.vo.PreOrderVO;
import com.gdn.x.product.model.vo.ProductAndItemsVO;
import com.gdn.x.product.model.vo.ProductCenterSummaryRequest;
import com.gdn.x.product.model.vo.ProductCenterSummaryResponse;
import com.gdn.x.product.model.vo.ProductItemsVo;
import com.gdn.x.product.model.vo.ProductScoreVo;
import com.gdn.x.product.model.vo.ProductSkuSummaryRequestVo;
import com.gdn.x.product.model.vo.ProductSummaryRequestVo;
import com.gdn.x.product.model.vo.ProductVo;
import com.gdn.x.product.model.vo.UnmappedSkuResponse;
import com.gdn.x.product.outbound.api.ProductCategoryBaseOutbound;
import com.gdn.x.product.outbound.api.WarehouseItemMasterOutbound;
import com.gdn.x.product.outbound.api.XbpOutbound;
import com.gdn.x.product.rest.web.model.EditItemResponse;
import com.gdn.x.product.rest.web.model.dto.AuditTrailDto;
import com.gdn.x.product.rest.web.model.dto.PreOrderDTO;
import com.gdn.x.product.rest.web.model.dto.ProductAndItemsDTO;
import com.gdn.x.product.rest.web.model.enums.ApiErrorCode;
import com.gdn.x.product.rest.web.model.enums.EditChangeType;
import com.gdn.x.product.rest.web.model.request.AddDeleteVariantRetryRequest;
import com.gdn.x.product.rest.web.model.request.CategoryBrandRequest;
import com.gdn.x.product.rest.web.model.request.ItemActivationRequest;
import com.gdn.x.product.rest.web.model.request.NeedCorrectionItemActivationRequest;
import com.gdn.x.product.rest.web.model.request.NeedCorrectionProductActivationRequest;
import com.gdn.x.product.rest.web.model.request.ProductAndL5MigrationRequest;
import com.gdn.x.product.rest.web.model.request.ProductBundleCreationRequest;
import com.gdn.x.product.rest.web.model.request.ProductScoreRequest;
import com.gdn.x.product.rest.web.model.request.ProductSkuSummaryRequest;
import com.gdn.x.product.rest.web.model.request.ProductSummaryRequest;
import com.gdn.x.product.rest.web.model.request.SalesCategoryMappingUpdateRequest;
import com.gdn.x.product.rest.web.model.request.SalesCategoryUpdateRequest;
import com.gdn.x.product.rest.web.model.request.SimpleListStringRequest;
import com.gdn.x.product.rest.web.model.response.AuditTrailListResponse;
import com.gdn.x.product.rest.web.model.response.EditProductDetailDTO;
import com.gdn.x.product.rest.web.model.response.ItemInfoResponse;
import com.gdn.x.product.rest.web.model.response.ItemResponse;
import com.gdn.x.product.rest.web.model.response.ProductAndItemInfoResponse;
import com.gdn.x.product.rest.web.model.response.ProductAndItemsResponse;
import com.gdn.x.product.rest.web.model.response.ProductBasicResponse;
import com.gdn.x.product.rest.web.model.response.ProductCenterDetailResponse;
import com.gdn.x.product.rest.web.model.response.ProductInfoResponse;
import com.gdn.x.product.rest.web.model.response.ProductL3Response;
import com.gdn.x.product.rest.web.model.response.ProductL3SummaryResponse;
import com.gdn.x.product.rest.web.model.request.ProductLevel3SummaryRequest;
import com.gdn.x.product.rest.web.model.response.ProductNameSuggestionResponse;
import com.gdn.x.product.rest.web.model.response.ProductPickupPointListResponse;
import com.gdn.x.product.rest.web.model.response.ProductResponse;
import com.gdn.x.product.rest.web.model.response.ProductSkuSummaryResponse;
import com.gdn.x.product.rest.web.model.response.ProductTypeResponse;
import com.gdn.x.product.rest.web.model.response.PromoEligibilityResponse;
import com.gdn.x.product.rest.web.model.response.SharedProductBundleRecipeResponse;
import com.gdn.x.product.rest.web.model.response.SimpleBooleanResponse;
import com.gdn.x.product.rest.web.model.response.SkuCodeBundleRecipeResponse;
import com.gdn.x.product.rest.web.model.util.GdnMandatoryRequestParameterUtil;
import com.gdn.x.product.rest.web.model.response.ProductSkuResponse;
import com.gdn.x.product.service.api.BusinessPartnerPickupPointService;
import com.gdn.x.product.service.api.BusinessPartnerPromoService;
import com.gdn.x.product.service.api.BusinessPartnerService;
import com.gdn.x.product.service.api.CacheEvictHelperService;
import com.gdn.x.product.service.api.CacheEvictItemService;
import com.gdn.x.product.service.api.CacheItemHelperService;
import com.gdn.x.product.service.api.CachedService;
import com.gdn.x.product.service.api.CatalogService;
import com.gdn.x.product.service.api.ChannelService;
import com.gdn.x.product.service.api.ItemPickupPointService;
import com.gdn.x.product.service.api.ItemPriceService;
import com.gdn.x.product.service.api.ItemService;
import com.gdn.x.product.service.api.MasterDataAttributeService;
import com.gdn.x.product.service.api.MasterDataConstructorService;
import com.gdn.x.product.service.api.MasterDataService;
import com.gdn.x.product.service.api.ObjectConverterService;
import com.gdn.x.product.service.api.OfflineItemService;
import com.gdn.x.product.service.api.PCBMasterDataService;
import com.gdn.x.product.service.api.ProductAndItemSolrConstructorService;
import com.gdn.x.product.service.api.ProductAndItemSolrIndexerService;
import com.gdn.x.product.service.api.ProductCacheableService;
import com.gdn.x.product.service.api.ProductCenterHistoryService;
import com.gdn.x.product.service.api.ProductHelperService;
import com.gdn.x.product.service.api.ProductRetryEventPublishService;
import com.gdn.x.product.service.api.ProductScoreHistoryL3Service;
import com.gdn.x.product.service.api.ProductSearchHelperService;
import com.gdn.x.product.service.api.SaveAndPublishService;
import com.gdn.x.product.service.api.SaveOperationService;
import com.gdn.x.product.service.api.SkuValidator;
import com.gdn.x.product.service.api.SystemParameterService;
import com.gdn.x.product.service.config.KafkaPublisher;
import com.gdn.x.product.service.interceptor.MandatoryParameterHelper;
import com.gdn.x.product.service.util.CommonUtil;
import com.gdn.x.product.service.util.FormulaUtil;
import com.gdn.x.product.service.util.ProductScoreUtil;
import com.gdn.x.productcategorybase.AttributeType;
import com.gdn.x.productcategorybase.CatalogType;
import com.gdn.x.productcategorybase.domain.event.model.AllowedAttributeValueDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.AttributeDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.CatalogDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.CategoryDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.ImageDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.PredefinedAllowedAttributeValueDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.ProductAttributeDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.ProductAttributeValueDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.ProductCategoryDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.ProductDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.ProductItemDomainEventModel;
import com.gdn.x.productcategorybase.domain.event.model.ProductSalesCategoryMapping;
import com.gdn.x.productcategorybase.dto.Image;
import com.gdn.x.productcategorybase.dto.response.AllowedAttributeValueResponse;
import com.gdn.x.productcategorybase.dto.response.AttributeResponse;
import com.gdn.x.productcategorybase.dto.response.BasicInfoProductResponse;
import com.gdn.x.productcategorybase.dto.response.CatalogResponse;
import com.gdn.x.productcategorybase.dto.response.CategoryDetailResponse;
import com.gdn.x.productcategorybase.dto.response.CategoryNamesResponse;
import com.gdn.x.productcategorybase.dto.response.CategoryResponse;
import com.gdn.x.productcategorybase.dto.response.PredefinedAllowedAttributeValueResponse;
import com.gdn.x.productcategorybase.dto.response.ProductAttributeResponse;
import com.gdn.x.productcategorybase.dto.response.ProductAttributeValueResponse;
import com.gdn.x.productcategorybase.dto.response.ProductCategoryResponse;
import com.gdn.x.productcategorybase.dto.response.ProductDetailResponse;
import com.gdn.x.productcategorybase.dto.response.ProductItemAttributeValueResponse;
import com.gdn.x.productcategorybase.dto.response.ProductItemResponse;
import com.gdn.x.productcategorybase.dto.response.ProductSalesCategoryMappingResponse;
import com.google.api.services.youtube.YouTube;
import com.google.api.services.youtube.model.PageInfo;
import com.google.api.services.youtube.model.VideoListResponse;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

public class ProductServiceImplTest {

  private static final String ATTRIBUTE_CODE = "ATTRIBUTE_CODE";

  private static final String ATTRIBUTE_CODE_1 = "ATTRIBUTE_CODE_1";

  private static final String UPC_CODE = "UPC_CODE";

  private static final String ATTRIBUTE_CODE2 = "ATTRIBUTE_CODE2";

  private static final String CATALOG_CODE = "12051";

  private static final String ITEM_SKU = "item-sku";

  private static final String ITEM_SKU_2 = "item-sku2";

  private static final String ITEM_SKU_OFFLINE_ITEM = "item-sku-offline-item";

  private static final boolean NEED_MASTER_DATA_DETAIL = true;

  private static final String PRODUCT_CODE = "product-code";

  private static final String STORE_ID = "10001";

  private static final String SYSTEM = "system";

  private static final String REQUEST_ID = "request-id";

  private static final String PRODUCT_SKU_SYNC = "merchant-code00001";

  private static final String PRODUCT_SKU_WITH_UNSYNC = "product-sku-with-unsync";

  private static final String MASTER_CATALOG_CODE = "master-catalog-code";

  private static final String SALES_CATALOG_CODE = "12051";
  private static final String B2B_SALES_CATALOG_CODE = "12052";

  private static final String CATEGORY_CODE = "category-code";

  private static final String CATEGORY_CODE_UPDATED = "category-code-updated";

  private static final String PRODUCT_SKU_TOBE_UPDATED = "product-sku-tobe-updated";

  private static final String PRODUCT_CODE_TOBE_UPDATED = "product-code-tobe-updated";

  private static final String CATALOG_CODE_NOT_FOUND = "catalog-code-not-found";

  private static final String SETTLEMENT_TYPE_UPDATED = "settlement-type-updated";

  private static final String SETTLEMENT_TYPE = "settlement-type";

  private static final String PRODUCT_SKU_SYNC_TOBE_UPDATED = "product-sku-sync-tobe-updated";
  private static final String OMNI_CHANNEL_SKU = "omniChannelSku";
  private static final String OMNI_CHANNEL_SKU_2 = "omniChannelSku2";
  private static final String SIZE_CHART_CODE = "size-chart-code";
  private static final String SIZE_ATTRIBUTE_CODE = "size-attribute-code";
  private static final String SIZE_CHART_CODE1 = "size-chart-code1";

  private static final boolean IS_SYNCHRONIZED = true;

  private static final String PRODUCT_SKU_UNSYNC_TOBE_UPDATED = "product-sku-unsync-tobe-updated";

  private static final double HEIGHT = 3.0;

  private static final String BRAND = "brand";

  private static final String RANDOM = "random name";

  private static final String NEW_BRAND = "new brand";

  private static final String OLD_BRAND_CODE = "OLD_BRAND_CODE";

  private static final String NEW_BRAND_CODE = "NEW_BRAND_CODE";

  private static final String BRAND_LOGO_URL = "brand-logo-url";

  private static final String STORE_ID_NOT_FOUND = "store-id-not-found";

  private static final String PRODUCT_SKU_NOT_FOUND = "product-sku-not-found";

  private static final String PRODUCT_SKU_WITHOUT_ITEMS = "prod-sku-wo-items";

  private static final String PRODUCT_NOT_FOUND = "Product not found";

  private static final String CHANNEL_WEB = ChannelName.DESKTOP_WEB.toString();

  private static final boolean IS_DISPLAYABLE = true;

  private static final boolean IS_DISCOVERABLE = true;

  private static final String STORE_ID_FOR_PRODUCT_VIEW_CONFIG_ADDED = "store-id-for-product-view-config";

  private static final String STORE_ID_PRODUCT_VIEW_CONFIG_UPDATED = "store-id-for-product-view-config-updated";

  private static final String STORE_ID_WITH_CHANNEL_NOT_FOUND = "store-id-with-channel-not-found";

  private static final String CHANNEL_MOBILE = ChannelName.MOBILE_WEB.toString();

  private static final String USERNAME = "username";

  private static final String RECAT_ID = "recatId";

  private static final String FAILED_STATUS = "FAILED";

  private static final String COMPLETED_STATUS = "COMPLETED";

  private static final boolean IS_NOT_SYNCHRONIZED = false;

  private static final String NEW_PRODUCT_NAME = "new-product-name";

  private static final String OLD_PRODUCT_NAME = "old-product-name";

  private static final String MERCHANT_CODE = "merchant-code";
  private static final String MERCHANT_CODE_1 = "HAS-60061";

  private static final String PRODUCT_SKU_1 = "HAS-60061-00707";
  private static final String PRODUCT_SKU_2 = "COS-28126-40382";
  private static final String SALES_CATEGORY_CODE = "SI-1100000038";
  private static final long PRODUCT_COUNTER = 1;

  private static final MasterDataProduct MASTER_DATA_PRODUCT = new MasterDataProduct();

  private static final double UPDATED_DOUBLE = 2.0;

  private static final String SHIPPING_WEIGHT_FIELD =
      ProductFieldNames.MASTER_DATA_PRODUCT + "." + ProductFieldNames.SHIPPING_WEIGHT;

  private static final String PRODUCT_SKU = "product-sku-with-pattern";

  private static final String ACTIVITY = "activity";

  private static final String CURRENT_VALUE = "current_value";

  private static final String PREVIOUS_VALUE = "previous_value";

  private static final String PRODUCT_SKU4 = "3BS-11204-00329";

  private static final String PRODUCT_SKU2 = "product-sku-with-pattern-2";

  private static final String PRODUCT_SKU3 = "product-sku-with-pattern-3";

  private static final List<String> PRODUCT_SKUS = Arrays.asList(PRODUCT_SKU);

  private static final String PRISTINE_ID = "pristine-id";

  private static final String ETD_NOTE = "ETD_NOTE";

  private static final String BLANK = "";

  private static final Product PRODUCT1 = initializeProduct(PRODUCT_SKU);

  private static final Product PRODUCT2 = initializeProduct(PRODUCT_SKU2);

  private static final Product PRODUCT3 = initializeProduct(PRODUCT_SKU3);

  private static final Stream<Product> PRODUCT_STREAM = Stream.of(PRODUCT1, PRODUCT2, PRODUCT3);
  private static final String ALLOWED_ATTRIBUTE_VALUE_CODE = "allowedAttributeValueCode";
  private static final String ALLOWED_ATTRIBUTE_VALUE_CODE_1 = "allowedAttributeValueCode1";
  private static final String ALLOWED_ATTRIBUTE_VALUE = "allowedAttributeValue";
  private static final String ALLOWED_ATTRIBUTE_VALUE_1 = "allowedAttributeValue1";

  private static final String PREDEFINED_ATTRIBUTE_VALUE = "predefinedAttributeValue";
  private static final String PREDEFINED_ATTRIBUTE_VALUE_2 = "predefinedAttributeValue2";

  private static final String DESCRIPTIVE_ATTRIBUTE_VALUE = "descriptiveValue";
  private static final String DESCRIPTIVE_ATTRIBUTE_VALUE_2 = "descriptiveValue2";


  private static final boolean TRUE = true;

  private static final boolean FALSE = false;
  private static final String OLD_CAT_1 = "old_cat_1";
  private static final String OLD_CAT_2 = "old_cat_2";
  private static final String OLD_CAT_3 = "old_cat_3";
  private static final String NEW_CAT_1 = "new_cat_1";
  private static final String NEW_CAT_2 = "new_cat_2";
  private static final String NEW_UMKM_CAT_1 = "new_umkm_cat_1";
  private static final String NEW_UMKM_CAT_2 = "new_umkm_cat_2";
  private static final String CATEGORY_CODE_FOR_UNSYNC_CHECK = "CAT-01";
  private static final String UPDATED_DESCRIPTION = "updated-description";
  private static final String UPDATED_LONG_DESCRIPTION = "updated-long-description";
  private static final String UPDATED_PRODUCT_STORY = "updated-product-story";
  private static final String UPDATED_USP = "updated-usp";
  private static final String UPDATED_UOM = "updated-uom";
  private static final String UPDATED_URL = "updated-url";
  private static final String LOCATION_PATH = "location_path";
  private static final String NAME = "name";
  private static final String DESCRIPTION = "description";
  private static final boolean IN_ALL_PRODUCTS = false;
  private static final String YOUTUBE_URL = "https://www.youtube.com/watch?v=P1xAhgKTqDA";
  private static final String YOUTUBE_INVALID_URL = "https://www.youtube.com/watch?v";
  private static final String VIDEO_LIST = "snippet,contentDetails,statistics";
  private static final String API_KEY = "apiKey";
  private static final String OLD_CATEGORY = "old-category";
  private static final String NEW_CATEGORY = "new-category";
  private static final String SKU = "sku";
  private static final String SKU_2 = "sku2";
  private static final String SOURCE_ITEM_CODE = "sourceItemCode";
  private static final String ITEM_CODE = "itemCode";
  private static final String PREORDER_TYPE = "preOrderType";
  private static final String PREORDER_WEEK_TYPE = "WEEK";
  private static final Integer PREORDER_VALUE = 10;
  private static final String PICKUP_POINT_CODE = "ppCode";
  private static final String FILE_PATH = "ProductL3";
  private static final String PRODUCT_SOLR_LIST = "ProductSolrList.json";
  private static final String PRODUCT_AND_ITEM_SOLR = "ProductAndItemSolr.json";
  private static final String PRODUCT_SCORE = "ProductScore.json";
  public static final String DEFAULT = "DEFAULT";
  public static final String TOQ_15120_06641_00001 = "TOQ-15120-06641-00001";
  private static final String PRODUCT_SKU_JSON = "TOQ-15120-06641";
  public static final Long PRODUCT_COUNT = 100L;
  public static final String SOLR_CATEGORY_LIST_BATCH_SIZE = "250";
  private static final String TRUE_SYSTEM_PARAMETER = "true";
  private static final Integer L5_COUNT = 10;

  private static final String FALSE_SYSTEM_PARAMETER = "false";

  private static final String SELLER_PROMO_BUNDLINGS_SWITCH = "sellerPromoBundlingsSwitch";

  private static final String ACTIVE_PROMO_BUNDLING_TEST = "ACTIVE_PROMO_BUNDLING_TEST";

  private static final String SKU_CODE_1 = "skuCode1";
  private static final String SKU_CODE_2 = "skuCode2";
  private static final String SKU_CODE_3 = "skuCode3";
  private static final String SKU_CODE_4 = "skuCode4";
  private static final String ITEM_SKU_1 = "itemSku1";
  private static final String ITEM_SKU_3 = "itemSku3";
  private static final String PICKUP_POINT_CODE_1 = "pickupPointCode1";
  private static final Date TEN_DAYS_AGO = new Date(System.currentTimeMillis() - (10 * 24 * 60 * 60 * 1000));
  private static final Date TEN_DAYS_AFTER = new Date(System.currentTimeMillis() + (10 * 24 * 60 * 60 * 1000));
  private static final String VIDEO_URL_CLIENT_ID = "videoUrlClientId";
  private static final String VIDEO_ID_1 = "videoId1";
  private static final String VIDEO_ID_2 = "videoId2";
  private static final String VIDEO_NAME_1 = "videoName1";
  private static final String VIDEO_NAME_2 = "videoName2";

  private String filePath;

  @InjectMocks
  private ProductServiceImpl productServiceImpl;

  @Mock
  private CacheEvictHelperService cacheEvictHelperService;

  @Mock
  private ObjectConverterService objectConverterService;

  @Mock
  private ProductCategoryBaseOutbound productCategoryBaseClient;

  @Mock
  private ProductCacheableService productCacheableService;

  @Mock
  private ProductRepository productRepository;

  @Mock
  private ProductAndItemSolrRepository solrRepository;

  @Mock
  private ProductSolrRepository productSolrRepository;

  @Mock
  private ProductHelperService productHelperService;

  @Mock
  private ItemService itemService;

  @Mock
  private XbpOutbound xbpOutbound;

  @Mock
  private MasterDataAttributeService masterDataAttributeService;

  @Mock
  private SaveOperationService saveOperationService;

  @Mock
  private SaveAndPublishService saveAndPublishService;

  @Mock
  private CatalogService catalogService;

  @Mock
  private SkuValidator skuValidator;

  @Mock
  private FormulaUtil formulaUtil;

  @Mock
  private MasterDataService masterDataService;

  @Mock
  private MasterDataConstructorService masterDataConstructorService;

  @Mock
  private KafkaPublisher kafkaProducer;

  @Mock
  private SystemParameterService systemParameterService;

  @Mock
  private OfflineItemService offlineItemService;

  @Mock
  private ProductSearchHelperService productSearchHelperService;

  @Mock
  private ProductAndItemSolrIndexerService productAndItemSolrIndexerService;

  @Mock
  private CacheItemHelperService cacheItemHelperService;

  @Mock
  private BusinessPartnerService businessPartnerService;

  @Mock
  private ProductScoreUtil productScoreUtil;

  @Mock
  private ProductScoreHistoryL3Service productScoreHistoryL3Service;

  @Mock
  private ItemPickupPointService itemPickupPointService;

  @Mock
  private CachedService cachedService;

  @Captor
  private ArgumentCaptor<Product> productArgumentCaptor;

  @Captor
  private ArgumentCaptor<ProfileResponse> profileResponseArgumentCaptor;

  @Captor
  private ArgumentCaptor<BusinessPartner> businessPartnerArgumentCaptor;

  @Captor
  private ArgumentCaptor<List<Item>> itemListArgumentCaptor;

  @Captor
  private ArgumentCaptor<List<Product>> productListArgumentCaptor;

  @Captor
  private ArgumentCaptor<List<ItemPickupPoint>> itemPickupPointListArgumentCaptor;

  @Captor
  private ArgumentCaptor<Item> itemArgumentCaptor;

  @Captor
  private ArgumentCaptor<ProductAndItemsVO> productAndItemsVOArgumentCaptor;

  @Captor
  private ArgumentCaptor<Map<String, Double>> mapArgumentCaptor;

  @Captor
  private ArgumentCaptor<ProductSummaryRequestVo> productSummaryRequestVoArgumentCaptor;

  @Captor
  private ArgumentCaptor<List<OfflineItem>> offlineItemListArgumentCaptor;

  @Captor
  private ArgumentCaptor<AuditTrailListResponse> auditTrailListResponseArgumentCaptor;

  @Mock
  private YouTube youTube;

  @Mock
  private YouTube.Videos videos;

  @Mock
  private YouTube.Videos.List list;

  @Mock
  private ObjectMapper mapper;

  @Mock
  private ProductRetryEventPublishService productRetryEventPublishService;

  @Mock
  private ProductAndItemSolrConstructorService solrDataConstructor;


  @Mock
  private ProductCenterHistoryService productCenterHistoryService;

  @Mock
  private BusinessPartnerPromoService businessPartnerPromoService;

  @Mock
  private CacheEvictItemService cacheEvictItemService;

  @Mock
  private BusinessPartnerPickupPointService businessPartnerPickupPointService;

  @Mock
  private ItemPriceService itemPriceService;

  @Mock
  private ChannelService channelService;

  @Mock
  private GdnMapper gdnMapperMock;


  @Captor
  private ArgumentCaptor<ProductChange> productChangeArgumentCaptor;

  @Mock
  private ItemRepository itemRepository;

  @Mock
  private WarehouseItemMasterOutbound warehouseItemMasterOutbound;

  @Mock
  private PCBMasterDataService pcbMasterDataService;

  @Mock
  private MandatoryParameterHelper mandatoryParameterHelper;

  @Mock
  private KafkaTopicProperties kafkaTopicProperties;

  private GdnMapper gdnMapper = new DozerMapper(new DozerBeanMapper());

  private VideoListResponse videoListResponse;

  private Product productUnsync;

  private MasterDataProduct masterDataProduct;

  private Product productSync;

  private NeedCorrectionItemActivationRequest itemActivationRequest;

  private List<ProductCategoryResponse> productCategoryResponses;

  private MasterCatalog masterCatalog;

  private List<SalesCatalog> salesCatalogs;

  private List<Item> listOfItems;

  private Product productWithMasterData;

  private Category category;

  private Product productSyncUpdated;

  private MasterCatalog masterCatalogTobeUpdated;

  private Category categoryTobeUpdated;

  private Product productTobeUpdated;

  private SalesCatalog salesCatalog;

  private List<SalesCatalog> ListOfsalesCatalogs;

  private List<SalesCatalog> ListOfSalesCatalogsUpdated;

  private List<Category> listOfCategories;

  private List<String> salesCategoryList = new ArrayList<>();

  private SalesCatalog salesCatalogTobeUpdated;

  private List<Category> listOfCategoriesTobeUpdated;

  private List<SalesCatalog> ListOfsalesCatalogsTobeUpdated;

  private Product productUpdated;

  private Product productSyncTobeUpdated;

  private Product productUnsyncUpdated;

  private Product productUnSyncTobeUpdated;

  private MasterDataProduct masterDataProductUpdated;

  private MasterDataProduct masterDataProductToBeUpdated;

  private Item item;

  private List<Item> emptyList;

  private ItemViewConfig productViewConfigAdded;

  private ItemBuyableSchedule itemBuyableSchedules;

  private ItemDiscoverableSchedule itemDiscoverableSchedules;

  private Product productWithProductViewConfigAdded;

  private HashSet<ItemViewConfig> itemViewConfigs;

  private Product productWithProductViewConfigToBeAdded;

  private Product productWithProductViewConfigToBeAddedWithExistingChannel;

  private Product productWithProductViewConfigUpdated;

  private ItemBuyableSchedule productDisplayableSchedulesUpdated;

  private ItemDiscoverableSchedule productDiscoverableSchedulesUpdated;

  private ItemViewConfig productViewConfigWithChannelNotFound;

  private Product productWithProductViewConfigDeleted;

  private Item itemWithMasterDataItem;

  private MasterDataItem masterDataItem;

  private List<Item> listOfItemWithMasterDataItem;

  private ProductAndItemsVO productAndItemsVO;

  private List<Item> listOfItemRequestVO;

  private Product productRequestVO;

  private GdnRestSingleResponse<ProductDetailResponse> productDetailResponseGdn;

  private ProductDetailResponse productDetailResponse;

  private Product productUnsyncWithoutMasterData;

  private HashSet<Product> setOfProducts;

  private GdnRestSingleResponse<ProductCounterResponse> productCounterResponseGdn;

  private ProductCounterResponse productCounterResponse;

  private HashSet<String> productCodes;

  private MasterDataProductAttribute masterDataProductAttribute;

  private MasterDataProductAttribute masterDataProductAttribute2;

  private MasterDataAttribute masterDataAttribute;

  private MasterDataAttribute masterDataAttribute2;

  private OfflineItem offlineItem;

  private Product product;
  private ProfileResponse profileResponse1;

  private Map<String, Boolean> itemsMap = new HashMap<>();

  private MasterDataAttribute masterDataAttributeUpdated = new MasterDataAttribute();

  private MasterDataProductAttributeValue masterDataProductAttributeValueUpdated = new MasterDataProductAttributeValue();

  private List<MasterDataProductAttributeValue> masterDataProductAttributeValues = new ArrayList<>();

  private MasterDataProductAttribute masterDataProductAttributeUpdated = new MasterDataProductAttribute();

  private MasterDataAttribute masterDataAttributeExisting = new MasterDataAttribute();

  private MasterDataProductAttributeValue masterDataProductAttributeValueExisting =
      new MasterDataProductAttributeValue();

  private List<MasterDataProductAttributeValue> masterDataProductAttributeValuesExisting = new ArrayList<>();

  private MasterDataProductAttribute masterDataProductAttributeExisting = new MasterDataProductAttribute();

  private MasterDataProduct masterDataProductExisting = new MasterDataProduct();
  private List<String> oldSalesCategoryList;
  private List<String> newSalesCategoryList;
  private List<String> newUmkmSalesCategoryList;

  private SystemParameter systemParameter = new SystemParameter();

  private MasterDataAllowedAttributeValue masterDataAllowedAttributeValueUpdated =
      new MasterDataAllowedAttributeValue();

  private PredefinedAllowedAttributeValue masterDataPredefinedAttributeValueExisting =
      new PredefinedAllowedAttributeValue();

  private PredefinedAllowedAttributeValue masterDataPredefinedAttributeValueUpdated =
      new PredefinedAllowedAttributeValue();

  private MasterDataProductImage masterDataProductImage = new MasterDataProductImage();

  private MasterDataItemImage masterDataItemImage = new MasterDataItemImage();

  private ProductSalesCategoryMapping productSalesCategoryMapping;

  private ProductCategoryDomainEventModel productCategoryDomainEventModel;

  private ProductSalesCategoryMappingResponse productSalesCategoryMappingResponse =
      new ProductSalesCategoryMappingResponse();

  private ProductCategoryResponse productCategoryResponse = new ProductCategoryResponse();

  private CategoryResponse categoryResponse = new CategoryResponse();

  private ProductDomainEventModel message;

  private ProductScoreVo productScoreVo = new ProductScoreVo();
  private ProductScore oldProductScore = new ProductScore();
  private ProductSolr productSolr1 = new ProductSolr();

  private ProductSpecialAttribute productSpecialAttribute = new ProductSpecialAttribute();

  private ProductItemResponse productItemResponse = new ProductItemResponse();

  private ProductScoreRequest productScoreRequest = new ProductScoreRequest();

  private Page<ProductSolr> productSolrPage;

  private CategoryNamesResponse categoryNamesResponse;

  private SalesCategoryUpdateRequest salesCategoryUpdateRequest;

  private SalesCategoryUpdateRequest salesCategoryUpdateRequest1;

  private PreOrder preOrder;
  private Video video;
  private PreOrderDTO preOrderDTO;

  private ProductSkuSummaryRequest productSkuSummaryRequest = new ProductSkuSummaryRequest();

  private Map<String, Boolean> stringBooleanMap = new HashMap<>();
  private ProductSummaryRequestVo productSummaryRequestVo = new ProductSummaryRequestVo();
  private ClassLoader classLoader;
  private ObjectMapper objectMapper = new ObjectMapper();
  private ProductAndItemInfoResponse productAndItemInfoResponse;
  private ProductAndItemsResponse productAndItemsResponse;
  private ProductAndItemsDTO productAndItemsDTO;
  private ProductItemsVo productItemsVo;
  private BusinessPartnerPromo businessPartnerPromo = new BusinessPartnerPromo();
  private ItemPickupPoint itemPickupPoint;
  private Set<ItemViewConfig> itemViewConfigList;
  private Set<Price> prices;
  private ProductSolr productSolr2;
  private BusinessPartnerPickupPoint businessPartnerPickupPoint =
      BusinessPartnerPickupPoint.builder().code(PICKUP_POINT_CODE).name(PICKUP_POINT_CODE)
          .build();
  private ProductL3Response productL3Response = new ProductL3Response();
  private ProfileResponse profileResponse = new ProfileResponse();
  private BusinessPartner businessPartner;
  private HalalHistoryUpdateEventModel halalHistoryUpdateEventModel;
  private EditProductDetailDTO editProductDetailDTO;
  private ItemBuyableSchedule itemBuyableSchedule;
  private ItemDiscoverableSchedule itemDiscoverableSchedule;
  private ProductAndL5MigrationRequest productAndL5MigrationRequest;



  @Test
  public void addProductAndItemsTest() throws Exception {
    productAndItemsVO.getProduct().setPreOrder(preOrder);
    productAndItemsVO.getProduct().setVideo(video);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(this.productDetailResponse);
    when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), eq(this.productSync), eq(this.productDetailResponse),
        businessPartnerArgumentCaptor.capture())).thenReturn(new ArrayList<>());
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
        businessPartner);
    when(this.productHelperService.setProductDetail(eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class),
        eq(this.productDetailResponse))).thenReturn(productSync);

    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));

    verify(this.productHelperService)
        .setProductDetail(eq(ProductServiceImplTest.REQUEST_ID), eq(ProductServiceImplTest.USERNAME),
            eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class), eq(this.productDetailResponse));
    verify(this.itemService).addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), productArgumentCaptor.capture(), eq(this.productDetailResponse),
        businessPartnerArgumentCaptor.capture());
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_SYNC);
    verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
    assertTrue(productArgumentCaptor.getValue().getPreOrder().getIsPreOrder());
    assertEquals(PREORDER_TYPE, productArgumentCaptor.getValue().getPreOrder().getPreOrderType());
    assertEquals(PREORDER_VALUE, productArgumentCaptor.getValue().getPreOrder().getPreOrderValue());
    assertEquals("videoId", productArgumentCaptor.getValue().getVideo().getVideoId());
  }

  @Test
  public void addProductAndItemsPreorderTest() throws Exception {
    productAndItemsVO.getProduct().setPreOrder(preOrder);
    productAndItemsVO.getProduct().getPreOrder().setIsPreOrder(false);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(this.productDetailResponse);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
        businessPartner);
    when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), eq(this.productSync), eq(this.productDetailResponse),
        eq(businessPartner))).thenReturn(
        new ArrayList<>());

    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));

    verify(this.productHelperService)
        .setProductDetail(eq(ProductServiceImplTest.REQUEST_ID), eq(ProductServiceImplTest.USERNAME),
            eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class), eq(this.productDetailResponse));
    verify(this.itemService).addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), productArgumentCaptor.capture(), eq(this.productDetailResponse),
        eq(businessPartner));
    verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_SYNC);
    assertEquals(PREORDER_TYPE, productArgumentCaptor.getValue().getPreOrder().getPreOrderType());
    assertEquals(PREORDER_VALUE, productArgumentCaptor.getValue().getPreOrder().getPreOrderValue());
  }

  @Test
  public void addProductAndItemsPreorder3Test() throws Exception {
    productAndItemsVO.getProduct().setPreOrder(null);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(this.productDetailResponse);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
        businessPartner);
    when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), eq(this.productSync), eq(this.productDetailResponse),
        eq(businessPartner))).thenReturn(
        new ArrayList<>());

    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));

    verify(this.productHelperService)
        .setProductDetail(eq(ProductServiceImplTest.REQUEST_ID), eq(ProductServiceImplTest.USERNAME),
            eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class), eq(this.productDetailResponse));
    verify(this.itemService).addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), productArgumentCaptor.capture(), eq(this.productDetailResponse),
        eq(businessPartner));
    verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_SYNC);
  }

  @Test
  public void addProductAndItemsPreorder1Test() throws Exception {
    productAndItemsVO.getProduct().setPreOrder(preOrder);
    productAndItemsVO.getProduct().getPreOrder().setIsPreOrder(null);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(this.productDetailResponse);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
        businessPartner);
    when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), eq(this.productSync), eq(this.productDetailResponse),
        eq(businessPartner))).thenReturn(new ArrayList<>());

    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));

    verify(this.productHelperService)
        .setProductDetail(eq(ProductServiceImplTest.REQUEST_ID), eq(ProductServiceImplTest.USERNAME),
            eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class), eq(this.productDetailResponse));
    verify(this.itemService).addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), productArgumentCaptor.capture(), eq(this.productDetailResponse),
        eq(businessPartner));
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_SYNC);
  }


  @Test
  public void addProductAndItemsWithBlankProductSkuTest() throws Exception {
    this.productAndItemsVO.getProduct().setProductSku(StringUtils.EMPTY);
    when(this.masterDataService
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
    when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), eq(this.productSync), eq(this.productDetailResponse),
        eq(businessPartner))).thenReturn(new ArrayList<>());
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
        businessPartner);
    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));
    verify(this.productHelperService)
        .setProductDetail(eq(ProductServiceImplTest.REQUEST_ID), eq(ProductServiceImplTest.USERNAME),
            eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class), eq(this.productDetailResponse));
    verify(this.itemService).addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(""), anyList(), eq(this.productSync),
        eq(this.productDetailResponse), eq(businessPartner));
    verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
  }

  @Test
  public void addProductAndItemsWithProductSkuTest() throws Exception {
    this.productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    when(this.masterDataService
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
    when(this.itemService
        .addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
            eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU),
            anyList(), eq(this.productSync), eq(this.productDetailResponse), eq(businessPartner)))
        .thenReturn(new ArrayList<>());
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(null);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
        businessPartner);
    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));
    verify(this.productHelperService)
        .setProductDetail(eq(ProductServiceImplTest.REQUEST_ID), eq(ProductServiceImplTest.USERNAME),
            eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class), eq(this.productDetailResponse));
    verify(this.itemService)
        .addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
            eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU),
            anyList(), eq(this.productSync), eq(this.productDetailResponse), eq(businessPartner));
    verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void addProductAndItemsWithProductSku1Test() throws Exception {
    this.productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
    when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), eq(this.productSync), eq(this.productDetailResponse),
        eq(businessPartner))).thenReturn(new ArrayList<>());
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(productSync);
    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync),
        anyList());
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void addProductAndItemsTestWithBlankProductCode() throws Exception {
    this.productRequestVO.setProductCode(null);
    this.productAndItemsVO.setProduct(this.productRequestVO);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint)));
  }

  @Test
  public void addProductAndItemsTestWithBlankRequestId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, "",
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint)));
  }

  @Test
  public void addProductAndItemsTestWithBlankStoreId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProductAndItems("", ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint)));
  }

  @Test
  public void addProductAndItemsTestWithNullProductAndItemsRequestVO() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, null));
  }

  @Test
  public void addProductAndItemsTestWithNullItem() throws Exception {
    this.productAndItemsVO.setProduct(this.productRequestVO);
    this.productAndItemsVO.setItems(null);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), null, itemPickupPoint)));
  }

  @Test
  public void addProductAndItemsTestWithEmptyItem() throws Exception {
    ProductItemsVo productItemsVo = generateProductItemVo(productRequestVO, null, itemPickupPoint);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, productItemsVo));
  }

  @Test
  public void addProductTest() throws Exception {
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(this.productDetailResponse);

    boolean result = this.productServiceImpl.addProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, this.productSync);

    verify(this.productHelperService).setProductDetail(ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.STORE_ID, this.productSync,
        this.productDetailResponse);
    verify(this.saveOperationService).saveProduct(this.productSync);

    assertThat(result, equalTo(true));
  }

  @Test
  public void addProductTest_SpecialAttNull() throws Exception {
    productSync.setProductSpecialAttributes(null);
    productDetailResponse.setProductAttributeResponses(new ArrayList<>());
    when(this.masterDataService
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
    boolean result = this.productServiceImpl
        .addProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            this.productSync);
    verify(this.productHelperService)
        .setProductDetail(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.STORE_ID, this.productSync, this.productDetailResponse);
    verify(this.saveOperationService).saveProduct(this.productSync);
    assertThat(result, equalTo(true));
  }

  @Test
  public void addProductTest_AttNull() throws Exception {
    productDetailResponse.setProductAttributeResponses(null);
    when(this.masterDataService
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
    boolean result = this.productServiceImpl
        .addProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            this.productSync);
    verify(this.productHelperService)
        .setProductDetail(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.STORE_ID, this.productSync, this.productDetailResponse);
    verify(this.saveOperationService).saveProduct(this.productSync);
    assertThat(result, equalTo(true));
  }

  @Test
  public void addProductTest_AttEmpty() throws Exception {
    productSync.setProductSpecialAttributes(Arrays.asList(new ProductSpecialAttribute()));
    productDetailResponse.setProductAttributeResponses(new ArrayList<>());
    when(this.masterDataService
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
    boolean result = this.productServiceImpl
        .addProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            this.productSync);
    verify(this.productHelperService)
        .setProductDetail(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.STORE_ID, this.productSync, this.productDetailResponse);
    verify(this.saveOperationService).saveProduct(this.productSync);
    assertThat(result, equalTo(true));
  }

  @Test
  public void addProductTest_AttEmpty_2() throws Exception {
    productSync.setProductSpecialAttributes(Arrays.asList(new ProductSpecialAttribute("code", "name", "Value")));
    productDetailResponse.setProductAttributeResponses(new ArrayList<>());
    when(this.masterDataService
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
    boolean result = this.productServiceImpl
        .addProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            this.productSync);
    verify(this.productHelperService)
        .setProductDetail(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.STORE_ID, this.productSync, this.productDetailResponse);
    verify(this.saveOperationService).saveProduct(this.productSync);
    assertThat(result, equalTo(true));
  }

  @Test
  public void addProductTestWithBlankProductCode() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, null));
  }

  @Test
  public void addProductTestWithBlankRequestId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProduct(ProductServiceImplTest.STORE_ID, null,
        ProductServiceImplTest.USERNAME, this.productSync));
  }

  @Test
  public void addProductTestWithBlankStoreId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProduct(null, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, this.productSync));
  }

  @Test
  public void addProductTestWithNullProduct() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.addProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, null));
  }

  @Test
  public void aTest() {
    List<Product> product = new ArrayList<>();
    Map<Boolean, List<Product>> collect =
        product.stream().collect(Collectors.groupingBy(e -> e.getProductCode() == null,
            Collectors.mapping(e -> e, Collectors.toList())));
    System.out.println(collect);
  }

  @Test
  public void deleteProductTest() throws Exception {
    boolean result = this.productServiceImpl.deleteProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC, false);
    verify(this.itemService).getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.saveOperationService)
        .saveProductAndItems(new ProductAndItemsVO(this.productSync, this.listOfItems), new ArrayList<>());
    assertTrue(result);
  }

  @Test
  public void deleteProductTestWithEmptyListOfItem() throws Exception {
    boolean result = this.productServiceImpl.deleteProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS, false);
    verify(this.itemService).getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS);

    verify(this.saveOperationService)
        .saveProductAndItems(new ProductAndItemsVO(this.productSyncTobeUpdated, this.emptyList), new ArrayList<>());
    assertTrue(result);
  }

  @Test
  public void deleteProductTestWithProductNotFound() throws Exception {
    try {
      this.productServiceImpl.deleteProduct(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND);
    } catch (Exception e) {
      verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
          ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND, false);
      assertTrue(e instanceof ApplicationRuntimeException);
    }
  }

  @Test
  public void deleteProductTestWithProductSkuBlank() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () ->  this.productServiceImpl.deleteProduct(ProductServiceImplTest.STORE_ID, null));
  }

  @Test
  public void deleteProductTestWithSotreIdBlank() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.deleteProduct(null, ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND));
  }

  @Test
  public void getProductAndItemsAvailabilityTest() throws Exception {
    String[] includedField = {ProductFieldNames.PRODUCT_SKU, ProductFieldNames.PRODUCT_CODE,
        ProductFieldNames.IS_SYNCHRONIZED, ProductFieldNames.MERCHANT_CODE, SHIPPING_WEIGHT_FIELD,
        ProductFieldNames.PRODUCT_TYPE};

    List<String> productSkus = new ArrayList<>();
    productSkus.add(PRODUCT_SKU_SYNC);

    Map<String, List<Item>> itemsMap = new HashMap<>();
    List<Item> items = new ArrayList<>();
    items.add(itemWithMasterDataItem);
    itemsMap.put(PRODUCT_SKU_SYNC, items);

    Map<String, MasterDataProductAndItemsVO> masterData = new HashMap<>();
    masterData.put(PRODUCT_CODE, new MasterDataProductAndItemsVO());

    Map<String, List<ProductAndItemsVO>> result = new HashMap<>();
    result.put(PRODUCT_CODE, new ArrayList<>());


    List<Product> productResponse = new ArrayList<>();
    productResponse.add(productSync);
    when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(STORE_ID, productSkus,
        includedField)).thenReturn(productResponse);
    when(productRepository.findSyncProductByStoreIdAndProductCodesAndMarkForDeleteFalse(STORE_ID,
        productCodes, includedField)).thenReturn(productResponse);
    when(itemService.getItemAvailability(STORE_ID, new HashSet<>(productSkus)))
        .thenReturn(itemsMap);
    when(masterDataService.getMasterDataProductDetailResponse(STORE_ID, USERNAME, REQUEST_ID,
        productCodes, IN_ALL_PRODUCTS)).thenReturn(masterData);
    when(productHelperService.constructProductWithItemAndMasterData(productResponse, itemsMap,
        masterData)).thenReturn(result);

    productServiceImpl.getProductAndItemsAvailability(STORE_ID, REQUEST_ID, USERNAME, productSkus);

    verify(productRepository).findByStoreIdAndProductSkusAndMarkForDeleteFalse(STORE_ID,
        productSkus, includedField);
    verify(productRepository).findSyncProductByStoreIdAndProductCodesAndMarkForDeleteFalse(STORE_ID,
        productCodes, includedField);
    verify(itemService).getItemAvailability(STORE_ID, new HashSet<>(productSkus));
    verify(masterDataService).getMasterDataProductDetailResponse(STORE_ID, USERNAME, REQUEST_ID,
        productCodes, IN_ALL_PRODUCTS);
    verify(productHelperService).constructProductWithItemAndMasterData(productResponse, itemsMap,
        masterData);
    verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.PRODUCT_AVAILIBILITY_REQUEST_LIMIT);
  }

  @Test
  public void getProductAndItemsAvailabilityAsFalseTest() throws Exception {
    String[] includedField = {ProductFieldNames.PRODUCT_SKU, ProductFieldNames.PRODUCT_CODE,
        ProductFieldNames.IS_SYNCHRONIZED, ProductFieldNames.MERCHANT_CODE, SHIPPING_WEIGHT_FIELD,
        ProductFieldNames.PRODUCT_TYPE};

    List<String> productSkus = new ArrayList<>();
    productSkus.add(PRODUCT_SKU_SYNC);

    Map<String, List<Item>> itemsMap = new HashMap<>();
    List<Item> items = new ArrayList<>();
    items.add(itemWithMasterDataItem);
    itemsMap.put(PRODUCT_SKU_SYNC, items);

    Map<String, MasterDataProductAndItemsVO> masterData = new HashMap<>();
    masterData.put(PRODUCT_CODE, new MasterDataProductAndItemsVO());

    Map<String, List<ProductAndItemsVO>> result = new HashMap<>();
    result.put(PRODUCT_CODE, new ArrayList<>());


    List<Product> productResponse = new ArrayList<>();
    productSync.setSynchronized(false);
    productResponse.add(productSync);
    when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(STORE_ID, productSkus,
        includedField)).thenReturn(productResponse);
    when(productRepository.findSyncProductByStoreIdAndProductCodesAndMarkForDeleteFalse(STORE_ID,
        productCodes, includedField)).thenReturn(productResponse);
    when(itemService.getItemAvailability(STORE_ID, new HashSet<>(productSkus)))
        .thenReturn(itemsMap);
    when(masterDataService.getMasterDataProductDetailResponse(STORE_ID, USERNAME, REQUEST_ID,
        productCodes, IN_ALL_PRODUCTS)).thenReturn(masterData);
    when(productHelperService.constructProductWithItemAndMasterData(productResponse, itemsMap,
        masterData)).thenReturn(result);

    productServiceImpl.getProductAndItemsAvailability(STORE_ID, REQUEST_ID, USERNAME, productSkus);

    verify(productRepository).findByStoreIdAndProductSkusAndMarkForDeleteFalse(STORE_ID,
        productSkus, includedField);
    verify(productRepository).findSyncProductByStoreIdAndProductCodesAndMarkForDeleteFalse(STORE_ID,
        Collections.EMPTY_SET, includedField);
    verify(itemService).getItemAvailability(STORE_ID, new HashSet<>(productSkus));
    verify(masterDataService).getMasterDataProductDetailResponse(STORE_ID, USERNAME, REQUEST_ID,
        Collections.EMPTY_SET, IN_ALL_PRODUCTS);
    verify(productHelperService).constructProductWithItemAndMasterData(productResponse, itemsMap,
        new HashMap<>());
    verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.PRODUCT_AVAILIBILITY_REQUEST_LIMIT);
  }


  @Test
  public void getProductAndItemsAvailabilityWithProductSkuNullTest() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getProductAndItemsAvailability(STORE_ID, REQUEST_ID, USERNAME, null));
  }

  @Test
  public void getProductAndItemsAvailabilityWithSizeExceededTest() throws Exception {
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getProductAndItemsAvailability(STORE_ID, REQUEST_ID, USERNAME, Arrays.asList("1", "1", "1")));
    } finally {
      verify(this.systemParameterService)
          .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.PRODUCT_AVAILIBILITY_REQUEST_LIMIT);
    }
  }

  @Test
  @Disabled
  public void getProductAndItemsTest() throws Exception {
    ProductAndItemsVO vo =
        new ProductAndItemsVO(this.productUnsync, this.listOfItemWithMasterDataItem);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync, this.listOfItems)).thenReturn(vo);
    when(this.itemService.getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_SYNC, ProductServiceImplTest.IS_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false)).thenReturn(this.listOfItems);

    ProductItemsVo result = this.productServiceImpl.getProductAndItems(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC, false, true, false, false,
        true, false);

    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.itemService).getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_SYNC, ProductServiceImplTest.IS_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, this.productSync);
    assertNotNull(result);
    assertNotNull(result.getItemVoList());
  }

  @Test
  public void getProductAndItemsTestWithBlankProductSku() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductAndItems(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, null, false, true, false, false,
        false, false));
  }

  @Test
  public void getProductAndItemsTestWithBlankRequestId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductAndItems(ProductServiceImplTest.STORE_ID, null,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC, false, true, false,
        false, false, false));
  }

  @Test
  public void getProductAndItemsTestWithBlankStoreId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductAndItems(null, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC, false, true, false,
        false, false, false));
  }

  @Test
  public void getProductAndItemsTestWithProductNotFound() throws Exception {
    try {
      this.productServiceImpl.getProductAndItems(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND, false, true, false, false, false, false);
    } catch (Exception e) {
      verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
          ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND);
      assertTrue(e instanceof ApplicationRuntimeException);
    }
  }

  @Test
  public void getProductAndItemsTestWithUnsynchronizedProduct() throws Exception {
    systemParameter.setValue(Boolean.TRUE.toString());
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false)).thenReturn(this.listOfItems);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItems(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false, true, false, false,
        true, false);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);

    verify(this.productHelperService).findAndConstructOfflineItems(ProductServiceImplTest.STORE_ID, this.listOfItems);

    verify(this.itemService).getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
  }

  @Test
  public void getProductAndItemsTestWitForceReviewOff() throws Exception {
    systemParameter.setValue(Boolean.TRUE.toString());
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false)).thenReturn(this.listOfItems);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItems(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false, true, false, false,
        false, false);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);

    verify(this.productHelperService).findAndConstructOfflineItems(ProductServiceImplTest.STORE_ID, this.listOfItems);

    verify(this.itemService).getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
  }

  @Test
  public void getProductAndItemsTestWithUnsynchronizedNeedProductDataTrueProduct() throws Exception {
    systemParameter.setValue(Boolean.TRUE.toString());
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false)).thenReturn(this.listOfItems);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result =
        this.productServiceImpl.getProductAndItems(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false, true, false, true, true, false);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);

    verify(this.productHelperService).findAndConstructOfflineItems(ProductServiceImplTest.STORE_ID, this.listOfItems);

    verify(this.itemService).getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
  }

  @Test
  public void getProductAndItemsTestWithUnsynchronizedProduct_PvSwitchTrueTest() throws Exception {
    systemParameter.setValue(Boolean.TRUE.toString());
    this.productAndItemsVO.setProduct(this.productUnsync);
    ReflectionTestUtils.setField(productServiceImpl, "isProductVisibilityEnabled", true);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false)).thenReturn(this.listOfItems);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(productUnsync);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItems(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false, true, false, false,
        true, false);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.masterDataConstructorService).constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true, IN_ALL_PRODUCTS);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);

    verify(this.itemService).getItemsForViewByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.IS_NOT_SYNCHRONIZED,
        ProductServiceImplTest.MERCHANT_CODE, false, true, false, false);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
    verify(this.productHelperService).findAndConstructOfflineItems(ProductServiceImplTest.STORE_ID, this.listOfItems);
  }

  @Test
  public void getProductAndItemDetailsWithUnsynchronizedTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "enableCombineOtherBundling", true);
    SystemParameter systemParameter1 = new SystemParameter();
    systemParameter1.setValue(Boolean.FALSE.toString());
    ReflectionTestUtils.setField(productServiceImpl, "updatedErrorMessageInGetProductAndItems", Boolean.FALSE);
    systemParameter.setValue(Boolean.TRUE.toString());
    Price price = new Price();
    DiscountPrice discountPrice = new DiscountPrice();
    discountPrice.setExclusiveProduct(true);
    discountPrice.setDiscountPrice(120);
    price.setListOfDiscountPrices(List.of(discountPrice));
    itemPickupPoint.setPrice(Collections.singleton(price));
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC),eq(false), eq(true), eq(false), any())).thenReturn(this.listOfItems);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(itemPickupPointService.findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID,
        PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE, false)).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(itemService.getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true))).thenReturn(listOfItems);
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItemDetails(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.PICKUP_POINT_CODE,
        false, true, false, false, true, null);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), any());
    Mockito.verify(itemPickupPointService)
        .findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID, PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE,
            false);
    verify(itemService).getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true));
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
  }


  @Test
  public void getProductAndItemDetailsWithnullItemPickUpPointTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "updatedErrorMessageInGetProductAndItems", Boolean.TRUE);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_WITH_UNSYNC)).thenReturn(product);
    when(this.itemService.getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap())).thenReturn(this.listOfItems);
    try {
      Assertions.assertThrows(ApiIncorrectInputDataException.class, () -> this.productServiceImpl.getProductAndItemDetails(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
          ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.PICKUP_POINT_CODE,
          false, true, false, false, true, null));
    } finally {
      Mockito.verify(itemPickupPointService)
          .findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID, PRODUCT_SKU_WITH_UNSYNC,
              PICKUP_POINT_CODE, false);
      verify(this.productCacheableService).findProductByStoreIdAndProductSku(
          ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    }
  }

  @Test
  public void getProductAndItemsDetailsTestWitForceReviewOff() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "enableCombineOtherBundling", true);
    productAndItemsVO.getProduct().setSizeChartCode(SIZE_CHART_CODE);
    ReflectionTestUtils.setField(productServiceImpl, "updatedErrorMessageInGetProductAndItems", Boolean.FALSE);
    systemParameter.setValue(Boolean.TRUE.toString());
    listOfItems.get(0).setArchived(true);
    ReflectionTestUtils.setField(productServiceImpl,"overrideArchivalFlagAtl4ByL3",true);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap())).thenReturn(this.listOfItems);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(itemPickupPointService.findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID,
        PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE, false)).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(itemService.getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true))).thenReturn(listOfItems);
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItemDetails(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.PICKUP_POINT_CODE,
        false, true, false, false, false, null);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap());
    Mockito.verify(itemPickupPointService)
        .findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID, PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE, false);
    verify(itemService).getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true));
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
    assertFalse(result.getItemVoList().get(0).isArchived());
    assertEquals(SIZE_CHART_CODE, result.getProductVo().getSizeChartCode());
  }

  @Test
  public void getProductAndItemsDetailsTestWithUnsynchronizedNeedProductDataTrueProduct() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "enableCombineOtherBundling", true);
    SystemParameter systemParameter1 = new SystemParameter();
    systemParameter1.setValue(Boolean.FALSE.toString());
    ReflectionTestUtils.setField(productServiceImpl, "updatedErrorMessageInGetProductAndItems", Boolean.FALSE);
    systemParameter.setValue(Boolean.TRUE.toString());
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    Mockito.when(itemPickupPointService.findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID,
        PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE, false)).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(itemService.getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true))).thenReturn(listOfItems);
    when(this.itemService.getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap())).thenReturn(this.listOfItems);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItemDetails(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.PICKUP_POINT_CODE,
        false, true, false, false, false, null);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap());
    Mockito.verify(itemPickupPointService)
        .findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID, PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE,
            false);
    verify(itemService).getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true));
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
  }

  @Test
  public void getProductAndItemsDetailsTestWithUnsynchronizedProduct_PvSwitchTrueTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "enableCombineOtherBundling", true);
    SystemParameter systemParameter1 = new SystemParameter();
    systemParameter1.setValue(Boolean.FALSE.toString());
    ReflectionTestUtils.setField(productServiceImpl, "updatedErrorMessageInGetProductAndItems", Boolean.FALSE);
    systemParameter.setValue(Boolean.TRUE.toString());
    this.productAndItemsVO.setProduct(this.productUnsync);
    ReflectionTestUtils.setField(productServiceImpl, "isProductVisibilityEnabled", true);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS))
        .thenReturn(this.productAndItemsVO);
    Mockito.when(itemPickupPointService.findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID,
        PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE, false)).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(itemService.getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true))).thenReturn(listOfItems);
    when(this.itemService.getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap())).thenReturn(this.listOfItems);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(productUnsync);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItemDetails(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.PICKUP_POINT_CODE,
        false, true, false, true, true, null);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.masterDataConstructorService).constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false, IN_ALL_PRODUCTS);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap());
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.REQUEST_ID),
        any(Product.class));
    Mockito.verify(itemPickupPointService)
        .findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID, PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE,
            false);
    verify(itemService).getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true));
  }

  @Test
  public void getProductAndItemsDetailsTestWithFilterMfdFalseProductAttributes_mfdAsTrue() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "enableCombineOtherBundling", true);
    List<MasterDataProductAttribute> masterDataProductAttributeList = new ArrayList<>();
    masterDataProductAttributeList.add(masterDataProductAttributeUpdated);
    productUnsync.setMasterDataProduct(masterDataProduct);
    masterDataProduct.setMasterDataProductAttributes((masterDataProductAttributeList));
    masterDataProductAttributeUpdated.setMarkForDelete(true);
    ReflectionTestUtils.setField(productServiceImpl, "updatedErrorMessageInGetProductAndItems", Boolean.FALSE);
    systemParameter.setValue(Boolean.TRUE.toString());
    this.productAndItemsVO.setProduct(this.productUnsync);
    ReflectionTestUtils.setField(productServiceImpl, "filterMfdFalseProductAttributes", true);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false,
        IN_ALL_PRODUCTS)).thenReturn(this.productAndItemsVO);
    Mockito.when(itemPickupPointService.findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID,
        PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE, false)).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(itemService.getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true))).thenReturn(listOfItems);
    when(this.itemService.getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap())).thenReturn(
        this.listOfItems);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(productUnsync);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
        Collections.singletonList(MERCHANT_CODE))).thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItemDetails(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.PICKUP_POINT_CODE, false, true, false,
        true, true, null);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.masterDataConstructorService).constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false,
        IN_ALL_PRODUCTS);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap());
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(eq(ProductServiceImplTest.USERNAME),
        eq(ProductServiceImplTest.REQUEST_ID), any(Product.class));
    Mockito.verify(itemPickupPointService)
        .findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID, PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE,
            false);
    verify(itemService).getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true));
    assertEquals(result.getProductVo().getMasterDataProduct().getMasterDataProductAttributes().size(), 0);
  }


  @Test
  public void getProductAndItemsDetailsTestWithFilterMfdFalseProductAttributes_mfdAsFalse() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "enableCombineOtherBundling", true);
    List<MasterDataProductAttribute> masterDataProductAttributeList = new ArrayList<>();
    masterDataProductAttributeList.add(masterDataProductAttributeUpdated);
    productUnsync.setMasterDataProduct(masterDataProduct);
    masterDataProduct.setMasterDataProductAttributes((masterDataProductAttributeList));
    masterDataProductAttributeUpdated.setMarkForDelete(false);
    ReflectionTestUtils.setField(productServiceImpl, "updatedErrorMessageInGetProductAndItems", Boolean.FALSE);
    systemParameter.setValue(Boolean.TRUE.toString());
    this.productAndItemsVO.setProduct(this.productUnsync);
    ReflectionTestUtils.setField(productServiceImpl, "filterMfdFalseProductAttributes", true);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false,
        IN_ALL_PRODUCTS)).thenReturn(this.productAndItemsVO);
    Mockito.when(itemPickupPointService.findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID,
        PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE, false)).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(itemService.getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true))).thenReturn(listOfItems);
    when(this.itemService.getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap())).thenReturn(
        this.listOfItems);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(productUnsync);
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
        Collections.singletonList(MERCHANT_CODE))).thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    ProductItemsVo result = this.productServiceImpl.getProductAndItemDetails(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, ProductServiceImplTest.PICKUP_POINT_CODE, false, true, false,
        true, true, null);
    Mockito.verify(this.businessPartnerPromoService)
        .findByStoreIdAndBusinessPartnerList(STORE_ID, Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService)
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.masterDataConstructorService).constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, false,
        IN_ALL_PRODUCTS);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).getItemsForViewByProductSkuAndPickUpPoint(eq(ProductServiceImplTest.STORE_ID),
        eq(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC), eq(false), eq(true), eq(false), anyMap());
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(eq(ProductServiceImplTest.USERNAME),
        eq(ProductServiceImplTest.REQUEST_ID), any(Product.class));
    Mockito.verify(itemPickupPointService)
        .findItemPickupPointsByProductSkuAndPPCodeWithShowDeleted(STORE_ID, PRODUCT_SKU_WITH_UNSYNC, PICKUP_POINT_CODE,
            false);
    verify(itemService).getItemsWithDiscountAndPickUpPointDetails(eq(STORE_ID), eq(PRODUCT_SKU_WITH_UNSYNC),
        eq(PICKUP_POINT_CODE), eq(listOfItems), anyList(), anyMap(), eq(true));
    assertFalse(
        result.getProductVo().getMasterDataProduct().getMasterDataProductAttributes().get(0).getMarkForDelete());
    assertEquals(result.getProductVo().getMasterDataProduct().getMasterDataProductAttributes().size(), 1);
  }

  @Test
  public void deleteProductByStoreIdAndProductSkusTest() throws Exception {
    Set<String> productSkuSet = new HashSet<>();
    productSkuSet.add(PRODUCT_SKU);
    Mockito.when(productRepository.deleteByStoreIdAndProductSkuIn(STORE_ID, productSkuSet))
        .thenReturn(new ArrayList<>());
    productServiceImpl.deleteProductByStoreIdAndProductSkus(STORE_ID, productSkuSet);
    Mockito.verify(productRepository).deleteByStoreIdAndProductSkuIn(STORE_ID, productSkuSet);
  }

  @Test
  public void deleteProductByStoreIdAndProductSkusInvalidStoreIdTest() throws Exception {
    Set<String> productSkuSet = new HashSet<>();
    productSkuSet.add(PRODUCT_SKU);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.deleteProductByStoreIdAndProductSkus(StringUtils.EMPTY, productSkuSet));
  }

  @Test
  public void deleteProductByStoreIdAndProductSkusProductSkuSetEmptyTest() throws Exception {
    Set<String> productSkuSet = new HashSet<>();
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.deleteProductByStoreIdAndProductSkus(STORE_ID, productSkuSet));
  }

  @Test
  public void getProductAndItemsByItemSkusTest() throws Exception {
    Set<String> itemSkus = Stream.of(ProductServiceImplTest.ITEM_SKU).collect(toSet());
    List<ItemCatalogVO> itemCatalogs = new ArrayList<>();

    List<Item> items = Arrays.asList(item);
    when(masterDataConstructorService.constructProductAndItemWithMasterData(STORE_ID, USERNAME,
        REQUEST_ID, productSync, items, false, IN_ALL_PRODUCTS)).thenReturn(new ProductAndItemsVO(productSync, items));
    when(catalogService.getItemCatalogsWithCategoryHierarchy(USERNAME, REQUEST_ID, productSync))
        .thenReturn(itemCatalogs);

    this.productServiceImpl.getProductAndItemsByItemSkus(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, itemSkus);
    verify(this.productHelperService).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, items, null);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, false);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(catalogService).getItemCatalogsWithCategoryHierarchy(USERNAME, REQUEST_ID, productSync);
  }

  @Test
  public void getProductAndItemsByItemSkusTest_withInvalidItemSku() throws Exception {
    String invalidItemSku = "invalidItemSku";
    Set<String> itemSkus = Stream.of(invalidItemSku).collect(toSet());
    this.productServiceImpl.getProductAndItemsByItemSkus(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, itemSkus);
  }

  @Test
  public void getProductAndItemsByItemSkusTest_withItemNotExists() throws Exception {
    Set<String> itemSkus = Stream.of(ProductServiceImplTest.ITEM_SKU_2).collect(toSet());
    List<ItemCatalogVO> itemCatalogs = new ArrayList<>();

    List<Item> items = Arrays.asList(item);
    when(masterDataConstructorService.constructProductAndItemWithMasterData(STORE_ID, USERNAME,
        REQUEST_ID, productSync, items, false, IN_ALL_PRODUCTS)).thenReturn(new ProductAndItemsVO(productSync, items));
    when(catalogService.getItemCatalogsWithCategoryHierarchy(USERNAME, REQUEST_ID, productSync))
        .thenReturn(itemCatalogs);

    this.productServiceImpl.getProductAndItemsByItemSkus(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, itemSkus);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_2, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, false);
    verify(this.itemPickupPointService).findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU_2);
  }

  @Test
  public void getProductAndItemsByItemSkusWithEmptyItemCatalogsTest() throws Exception {
    when(this.skuValidator.isItemSku(ProductServiceImplTest.ITEM_SKU_2)).thenReturn(true);
    when(this.itemService.getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_2, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, false))
        .thenReturn(this.item);

    Set<String> itemSkus = Stream.of(ProductServiceImplTest.ITEM_SKU).collect(toSet());
    itemSkus.add(ITEM_SKU_2);
    List<ItemCatalogVO> itemCatalogs = new ArrayList<>();
    ItemCatalogVO itemCatalog = new ItemCatalogVO();
    itemCatalogs.add(itemCatalog);

    List<Item> items = Arrays.asList(item);
    when(masterDataConstructorService.constructProductAndItemWithMasterData(STORE_ID, USERNAME,
        REQUEST_ID, productSync, items, false, IN_ALL_PRODUCTS)).thenReturn(new ProductAndItemsVO(productSync, items));
    when(catalogService.getItemCatalogsWithCategoryHierarchy(USERNAME, REQUEST_ID, productSync))
        .thenReturn(itemCatalogs);

    this.productServiceImpl.getProductAndItemsByItemSkus(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, itemSkus);
    verify(this.productHelperService, times(2)).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, items, null);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, false);
    verify(this.productCacheableService, times(2)).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(catalogService).getItemCatalogsWithCategoryHierarchy(USERNAME, REQUEST_ID, productSync);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_2, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, false);
  }

  @Test
  public void getProductAndSingleItemByItemSkuTest() throws Exception {
    ProductAndItemsVO productAndItemsVO = new ProductAndItemsVO(productSync, Arrays.asList(this.item));
    List<Item> items = Arrays.asList(this.item);
    when(this.itemService
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false, true)).thenReturn(this.item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS)).thenReturn(productAndItemsVO);
    when(itemPickupPointService.findByItemSkuInAndDelivery(eq(STORE_ID), anyList(), eq(true))).thenReturn(Arrays.asList(
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(item.getPickupPointCode()).build()));
    doNothing().when(itemPriceService).validateAndSetDiscountPrice(Collections.singletonList(item));
    BusinessPartnerPromo businessPartnerPromo = new BusinessPartnerPromo();
    Set<String> activePromoBundlings = new HashSet<>();
    activePromoBundlings.add(ACTIVE_PROMO_BUNDLING_TEST);
    businessPartnerPromo.setActivePromoBundlings(activePromoBundlings);
    when(businessPartnerPromoService.findByBusinessPartnerCode(product.getMerchantCode()))
        .thenReturn(businessPartnerPromo);
    SystemParameter systemParameter = new SystemParameter();
    systemParameter.setValue(TRUE_SYSTEM_PARAMETER);
    when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH))
        .thenReturn(systemParameter);
    this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
        false, null, true);
    verify(this.productHelperService).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, true);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS);
    verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(businessPartnerPromoService).findByStoreIdAndBusinessPartnerList(eq(STORE_ID), anyList());
    verify(this.productSearchHelperService)
        .setItemCatalogs(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, true, Collections.singletonList(productAndItemsVO),
            Collections.singletonMap(productAndItemsVO.getProduct().getProductCode(),
                productAndItemsVO.getProduct().getMasterDataProduct()));
    verify(itemPriceService).validateAndSetDiscountPrice(Collections.singletonList(item));
    verify(itemPickupPointService).findByItemSkuInAndDelivery(eq(STORE_ID), anyList(), eq(true));
  }

  @Test
  public void getProductAndSingleItemByItemSkuBusinessPartnerPromoNullTest() throws Exception {
    ProductAndItemsVO productAndItemsVO = new ProductAndItemsVO(productSync, Arrays.asList(this.item));
    item.setActivePromoBundlings(new HashSet<>());
    List<Item> items = Arrays.asList(this.item);
    when(this.itemService
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false, true)).thenReturn(this.item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS)).thenReturn(productAndItemsVO);
    SystemParameter systemParameter = new SystemParameter();
    systemParameter.setValue(TRUE_SYSTEM_PARAMETER);
    when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH))
        .thenReturn(systemParameter);
    when(businessPartnerPromoService.findByBusinessPartnerCode(product.getMerchantCode()))
        .thenReturn(null);
    Mockito.when(itemPickupPointService.findByItemSkuInAndDelivery(eq(STORE_ID), any(), eq(true))).thenReturn(null);
    this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
        false, null, true);
    verify(this.productHelperService).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, true);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS);
    verify(businessPartnerPromoService).findByStoreIdAndBusinessPartnerList(eq(STORE_ID), anyList());
    verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productSearchHelperService)
        .setItemCatalogs(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, true, Collections.singletonList(productAndItemsVO),
            Collections.singletonMap(productAndItemsVO.getProduct().getProductCode(),
                productAndItemsVO.getProduct().getMasterDataProduct()));
  }

  @Test
  public void getProductAndSingleItemByItemSkuBusinessPartnerPromoEmptyTest() throws Exception {
    ProductAndItemsVO productAndItemsVO = new ProductAndItemsVO(productSync, Arrays.asList(this.item));
    item.setActivePromoBundlings(new HashSet<>());
    List<Item> items = Arrays.asList(this.item);
    when(this.itemService
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false, true)).thenReturn(this.item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS)).thenReturn(productAndItemsVO);
    SystemParameter systemParameter = new SystemParameter();
    systemParameter.setValue(TRUE_SYSTEM_PARAMETER);
    when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH))
        .thenReturn(systemParameter);
    BusinessPartnerPromo businessPartnerPromo = new BusinessPartnerPromo();
    Set<String> activePromoBundlings = new HashSet<>();
    businessPartnerPromo.setActivePromoBundlings(activePromoBundlings);
    when(businessPartnerPromoService.findByBusinessPartnerCode(product.getMerchantCode()))
        .thenReturn(businessPartnerPromo);
    Mockito.when(itemPickupPointService.findByItemSkuInAndDelivery(eq(STORE_ID), any(), eq(true))).thenReturn(null);
    this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
        false, null, true);
    verify(this.productHelperService).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, true);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS);
    verify(businessPartnerPromoService).findByStoreIdAndBusinessPartnerList(eq(STORE_ID), anyList());
    verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productSearchHelperService)
        .setItemCatalogs(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, true, Collections.singletonList(productAndItemsVO),
            Collections.singletonMap(productAndItemsVO.getProduct().getProductCode(),
                productAndItemsVO.getProduct().getMasterDataProduct()));

  }

  @Test
  public void getProductAndSingleItemByItemSkuActivePromoBundlingFalseTest() throws Exception {
    ProductAndItemsVO productAndItemsVO = new ProductAndItemsVO(productSync, Arrays.asList(this.item));
    item.setActivePromoBundlings(new HashSet<>());
    List<Item> items = Arrays.asList(this.item);
    when(this.itemService
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false, true)).thenReturn(this.item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS)).thenReturn(productAndItemsVO);
    SystemParameter systemParameter = new SystemParameter();
    systemParameter.setValue(TRUE_SYSTEM_PARAMETER);
    when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH))
        .thenReturn(systemParameter);
    BusinessPartnerPromo businessPartnerPromo = new BusinessPartnerPromo();
    Set<String> activePromoBundlings = new HashSet<>();
    activePromoBundlings.add(ACTIVE_PROMO_BUNDLING_TEST);
    businessPartnerPromo.setActivePromoBundlings(activePromoBundlings);
    when(businessPartnerPromoService.findByBusinessPartnerCode(product.getMerchantCode()))
        .thenReturn(businessPartnerPromo);
    Mockito.when(itemPickupPointService.findByItemSkuInAndDelivery(eq(STORE_ID), any(), eq(true))).thenReturn(null);
    this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
        false, null, true);
    verify(this.productHelperService).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, true);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS);
    verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(businessPartnerPromoService).findByStoreIdAndBusinessPartnerList(eq(STORE_ID), anyList());
    verify(this.productSearchHelperService)
        .setItemCatalogs(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, true, Collections.singletonList(productAndItemsVO),
            Collections.singletonMap(productAndItemsVO.getProduct().getProductCode(),
                productAndItemsVO.getProduct().getMasterDataProduct()));
  }

  @Test
  public void getProductAndSingleItemByItemSkuSystemParameterFalseTest() throws Exception {
    ProductAndItemsVO productAndItemsVO = new ProductAndItemsVO(productSync, Arrays.asList(this.item));
    item.setActivePromoBundlings(new HashSet<>());
    List<Item> items = Arrays.asList(this.item);
    when(this.itemService
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false, true)).thenReturn(this.item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS)).thenReturn(productAndItemsVO);
    SystemParameter systemParameter = new SystemParameter();
    systemParameter.setValue(FALSE_SYSTEM_PARAMETER);
    when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(itemPickupPointService.findByItemSkuInAndDelivery(eq(STORE_ID), any(), eq(true))).thenReturn(null);
    this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
        false, null, true);
    verify(this.productHelperService).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, true);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, IN_ALL_PRODUCTS);
    verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID, SELLER_PROMO_BUNDLINGS_SWITCH);
    verify(this.productSearchHelperService)
        .setItemCatalogs(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, true, Collections.singletonList(productAndItemsVO),
            Collections.singletonMap(productAndItemsVO.getProduct().getProductCode(),
                productAndItemsVO.getProduct().getMasterDataProduct()));
  }

  @Test
  public void getProductAndSingleItemByItemSku_WhenProductAndItemsNullTest()
      throws Exception {

    when(this.itemService
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false, true))
        .thenReturn(this.item);
    this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false,
        null, true);
    verify(this.productHelperService)
        .findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService)
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false, true);
    verify(this.productCacheableService)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_SKU_SYNC);
  }

  @Test
  public void getProductAndSingleItemByItemSkuTest_usingOfflineItemSku_nullOfflineItem() throws Exception {
    when(this.itemService.getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false, true))
        .thenReturn(null);
    when(this.itemPickupPointService.findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU))
        .thenReturn(null);

    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () ->  this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
          false, null, true));
    } finally {
      verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
          false, false, null, false, true);
      verify(this.itemPickupPointService).findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU);
    }
  }

  @Test
  public void getProductAndSingleItemByItemSkuTest_usingOfflineItemSku_nullItemFromOfflineItem() throws Exception {
    when(this.itemService.getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false, true))
        .thenReturn(null);
    itemPickupPoint.setItemSku(ITEM_SKU_OFFLINE_ITEM);
    when(this.itemPickupPointService.findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU))
        .thenReturn(this.itemPickupPoint);
    when(this.itemService.getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false, false))
        .thenReturn(null);

    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
          false, null, true));
    } finally {
      verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
          false, false, null, false, true);
      verify(this.itemPickupPointService).findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU);
      verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
          false, false, null, false, false);
    }
  }

  @Test
  public void getProductAndSingleItemByItemSkuTest_usingOfflineItemSku_success() throws Exception {
    when(this.itemService.getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false, true))
        .thenReturn(null);
    itemPickupPoint.setItemSku(ITEM_SKU_OFFLINE_ITEM);
    when(this.itemPickupPointService.findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU))
        .thenReturn(this.itemPickupPoint);
    when(this.itemService.getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false, false))
        .thenReturn(item);

    this.productServiceImpl
        .getProductAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false, null, true);

    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false, true);
    verify(this.itemPickupPointService).findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU);
    verify(this.itemService).getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false, false);
    verify(this.productHelperService).constructOfflineItem(this.item, CommonUtil.getOfflineItemByPickupPoint(itemPickupPoint, false, null));
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
  }

  @Test
  public void getProductForViewTestBlankProductSku() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductForView(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, null,
        ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false));
  }

  @Test
  public void getProductForViewTestBlankRequestId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductForView(ProductServiceImplTest.STORE_ID, null,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC,
        ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false));
  }

  @Test
  public void getProductForViewTestBlankStoreId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductForView(null, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC,
        ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false));
  }

  @Test
  public void getProductForViewTestWithNullProduct() {
    try {
      this.productServiceImpl.getProductForView(ProductServiceImplTest.STORE_ID_NOT_FOUND,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC,
          ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false);
    } catch (Exception e) {
      verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
          ProductServiceImplTest.STORE_ID_NOT_FOUND,
          ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
      assertTrue(e instanceof ApplicationRuntimeException);
    }
  }

  @Test
  public void getProductForViewTestWithUnsynchorizedProduct() throws Exception {
    Product result = this.productServiceImpl.getProductForView(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC,
        ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);

    assertNotNull(result);
  }

  @Test
  public void getProductByProductSkuAndShowDeletedTest() throws Exception {
    when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    productServiceImpl.getProductByProductSkuAndShowDeleted(STORE_ID, PRODUCT_SKU, false);
    verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void getProductByProductSkuAndShowDeletedShowDeletedTrueTest() throws Exception {
    when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    productServiceImpl.getProductByProductSkuAndShowDeleted(STORE_ID, PRODUCT_SKU, true);
    verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void getProductByProductSkuAndShowDeletedFalseTest() throws Exception {
    product.setMarkForDelete(true);
    when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    try {
      Assertions.assertThrows(ApiIncorrectInputDataException.class, () -> productServiceImpl.getProductByProductSkuAndShowDeleted(STORE_ID, PRODUCT_SKU, false));
    } finally {
      verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    }
  }

  @Test
  public void getProductByProductSkuAndShowDeletedSuspendedTest() throws Exception {
    product.setMarkForDelete(true);
    product.setSuspended(true);
    when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    try {
      Assertions.assertThrows(
          ApiIncorrectInputDataException.class, () ->  productServiceImpl.getProductByProductSkuAndShowDeleted(STORE_ID, PRODUCT_SKU, false));
    } finally {
      verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    }
  }

  @Test
  public void getProductByProductSkuAndShowDeletedTakenDownTest() throws Exception {
    product.setMarkForDelete(true);
    product.setTakenDown(true);
    when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    try {
      Assertions.assertThrows(ApiIncorrectInputDataException.class, () -> productServiceImpl.getProductByProductSkuAndShowDeleted(STORE_ID, PRODUCT_SKU, false));
    } finally {
      verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    }
  }

  @Test
  public void getProductByProductSkuAndShowDeletedProductNullTest() throws Exception {
    try {
      Assertions.assertThrows(ApiIncorrectInputDataException.class, () -> productServiceImpl.getProductByProductSkuAndShowDeleted(STORE_ID, PRODUCT_SKU, true));
    } finally {
      verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    }
  }

  @Test
  public void getProductsByMerchantCodeTest() {
    List<Product> products = new ArrayList<>();
    products.addAll(setOfProducts);
    List<Product> result = this.productServiceImpl.getProductsByMerchantCode(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.MERCHANT_CODE);

    verify(this.productRepository).findProductsByStoreIdAndMerchantCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.MERCHANT_CODE);
    assertThat(result, notNullValue());
    assertTrue(result.contains(this.productSync));
  }

  @Test
  public void getProductsSuccess() throws Exception {
    Set<String> productSkus = new HashSet<>();
    productSkus.add(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.productServiceImpl.getProducts(ProductServiceImplTest.STORE_ID, productSkus);
    verify(this.productRepository).findProductByStoreIdAndProductSkuInAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, productSkus);
  }

  @Test
  public void getProductsWithBlankStoreId() throws Exception {
    Set<String> productSkus = new HashSet<>();
    productSkus.add(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProducts("", productSkus));
  }

  @Test
  public void getProductsWithInvalidSku() throws Exception {
    Set<String> productSkus = new HashSet<>();
    productSkus.add("PRODUCT_SKU_SYNC");
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProducts(STORE_ID, productSkus));
  }

  @Test
  public void getProductsWithEmptyList() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProducts(ProductServiceImplTest.STORE_ID, new HashSet<String>()));
  }

  @Test
  public void getProductsWithNullList() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProducts(ProductServiceImplTest.STORE_ID, null));
  }

  @Test
  public void getProductTest() throws Exception {
    Product result = this.productServiceImpl.getProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    assertNotNull(result);
  }

  @Test
  public void getProductFromDBTest() throws Exception {
    Product result = this.productServiceImpl.getProductFromDB(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC, false);
    assertNotNull(result);
  }

  @Test
  public void getProductTestWithProductSkuBlank() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProduct(ProductServiceImplTest.STORE_ID, null));
  }

  @Test
  public void getProductTestWithStoreIdBlank() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProduct(null, ProductServiceImplTest.PRODUCT_SKU_SYNC));
  }

  @BeforeEach
  public void setUp() throws Exception {
    initMocks(this);
    classLoader = getClass().getClassLoader();
    this.productSync = new Product();
    this.productSync.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.productSync.setSynchronized(true);
    this.productSync.setProductCode(ProductServiceImplTest.PRODUCT_CODE);
    this.productSync.setMerchantCode(ProductServiceImplTest.MERCHANT_CODE);
    this.productSync.setProductScore(new ProductScore(10, 10, 10, 10, 10, 10, 10, 10, 10, 1, 90));
    productSpecialAttribute.setAttributeCode(ATTRIBUTE_CODE);
    productSpecialAttribute.setAttributeValue(ALLOWED_ATTRIBUTE_VALUE);
    ReflectionTestUtils.setField(productServiceImpl, "productBasicInfoFetchBatchSize", 10);

    this.productSync.setProductSpecialAttributes(Arrays.asList(productSpecialAttribute));

    this.masterDataProduct = new MasterDataProduct();

    this.productUnsync = new Product();
    this.productUnsync.setSynchronized(false);
    this.productUnsync.setProductCode(ProductServiceImplTest.PRODUCT_CODE);
    this.productUnsync.setMasterDataProduct(this.masterDataProduct);
    this.productUnsync.setMerchantCode(ProductServiceImplTest.MERCHANT_CODE);
    this.productUnsync.setProductSpecialAttributes(Collections.emptyList());
    this.productUnsync.setProductScore(new ProductScore(10, 10, 10, 10, 10, 10, 10, 10, 10, 1, 90));

    this.productUnsyncWithoutMasterData = new Product();
    this.productUnsyncWithoutMasterData.setSynchronized(false);
    this.productUnsyncWithoutMasterData.setProductCode(ProductServiceImplTest.PRODUCT_CODE);
    this.productUnsyncWithoutMasterData.setMerchantCode(ProductServiceImplTest.MERCHANT_CODE);

    profileResponse1 = new ProfileResponse();
    CompanyDTO companyDTO = new CompanyDTO();
    List<String> salesChannel = new ArrayList<>();
    salesChannel.add(Constants.B2C_SELLER_CHANNEL);
    companyDTO.setSalesChannel(salesChannel);
    profileResponse1.setCompany(companyDTO);

    this.productCategoryResponses = new ArrayList<>();
    categoryResponse.setCategoryCode(CATEGORY_CODE);
    categoryResponse.setCatalog(new CatalogResponse(NAME, MASTER_CATALOG_CODE, CatalogType.MASTER_CATALOG.name()));
    productCategoryResponse.setCategory(categoryResponse);
    this.productCategoryResponses.add(productCategoryResponse);
    this.masterCatalog = new MasterCatalog();
    this.salesCatalogs = new ArrayList<>();

    this.item = new Item();
    this.item.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.item.setItemSku(ITEM_SKU);
    this.item.setItemCode(ITEM_CODE);
    this.item.setGeneratedItemName(GENERATED_ITEM_NAME);
    MasterDataItem masterDataItem = new MasterDataItem();
    MasterDataItemAttributeValue masterDataItemAttributeValue = new MasterDataItemAttributeValue();
    masterDataItemAttributeValue.setAttributeValue(BRAND);
    masterDataItemAttributeValue.setMasterDataAttribute(masterDataAttributeExisting);
    masterDataItem.setMasterDataItemAttributeValues(Collections.singletonList(masterDataItemAttributeValue));
    masterDataItem.setUpcCode(UPC_CODE);
    item.setMasterDataItem(masterDataItem);

    this.emptyList = new ArrayList<>();
    this.listOfItems = new ArrayList<>();
    this.listOfItems.add(this.item);
    this.listOfItemRequestVO = Arrays.asList(this.item);
    this.productWithMasterData = new Product();
    this.productWithMasterData.setStoreId(ProductServiceImplTest.STORE_ID);
    this.productWithMasterData.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.productWithMasterData.setSynchronized(true);
    this.productWithMasterData.setMasterDataProduct(this.masterDataProduct);
    this.salesCategoryList.add(ProductServiceImplTest.SALES_CATEGORY_CODE);

    this.category = new Category();
    this.category.setCategoryCode(ProductServiceImplTest.CATEGORY_CODE_UPDATED);
    this.category.setCatgroupId(ProductServiceImplTest.CATEGORY_CODE_UPDATED);
    this.masterCatalog.setCatalogCode(ProductServiceImplTest.MASTER_CATALOG_CODE);
    this.masterCatalog.setCategory(this.category);

    this.listOfCategories = new ArrayList<>();
    this.listOfCategories.add(this.category);
    this.salesCatalog = new SalesCatalog();
    this.salesCatalog.setCatalogCode(ProductServiceImplTest.SALES_CATALOG_CODE);
    this.salesCatalog.setListOfCategories(this.listOfCategories);

    this.ListOfsalesCatalogs = new ArrayList<>();
    this.ListOfsalesCatalogs.add(this.salesCatalog);

    this.productSync.setMasterCatalog(this.masterCatalog);
    this.productSync.setSalesCatalogs(this.ListOfsalesCatalogs);

    this.categoryTobeUpdated = new Category();
    this.categoryTobeUpdated.setCategoryCode(ProductServiceImplTest.CATEGORY_CODE);
    this.masterCatalogTobeUpdated = new MasterCatalog();
    this.masterCatalogTobeUpdated.setCatalogCode(ProductServiceImplTest.MASTER_CATALOG_CODE);
    this.masterCatalogTobeUpdated.setCategory(this.categoryTobeUpdated);

    this.listOfCategoriesTobeUpdated = new ArrayList<>();
    this.listOfCategoriesTobeUpdated.add(this.categoryTobeUpdated);
    this.salesCatalogTobeUpdated = new SalesCatalog();
    this.salesCatalogTobeUpdated.setCatalogCode(ProductServiceImplTest.SALES_CATALOG_CODE);
    this.salesCatalogTobeUpdated.setListOfCategories(this.listOfCategoriesTobeUpdated);

    this.ListOfsalesCatalogsTobeUpdated = new ArrayList<>();
    this.ListOfsalesCatalogsTobeUpdated.add(this.salesCatalogTobeUpdated);

    this.productTobeUpdated = new Product();
    this.productTobeUpdated.setStoreId(ProductServiceImplTest.STORE_ID);
    this.productTobeUpdated.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.productTobeUpdated.setMasterCatalog(this.masterCatalogTobeUpdated);
    this.productTobeUpdated.setSalesCatalogs(this.ListOfsalesCatalogsTobeUpdated);
    this.productSyncUpdated = new Product();
    this.productSyncUpdated.setStoreId(ProductServiceImplTest.STORE_ID);
    this.productSyncUpdated.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.productSyncUpdated.setMasterCatalog(this.masterCatalog);
    this.productSyncUpdated.setSalesCatalogs(this.ListOfsalesCatalogs);

    masterDataAttributeExisting.setAttributeCode(ATTRIBUTE_CODE);
    masterDataAttributeExisting.setAttributeName(BRAND);
    MasterDataAllowedAttributeValue masterDataAllowedAttributeValueExisting = new MasterDataAllowedAttributeValue();
    masterDataAllowedAttributeValueExisting.setAllowedAttributeValueCode(ALLOWED_ATTRIBUTE_VALUE_CODE);
    masterDataAllowedAttributeValueExisting.setValue(ALLOWED_ATTRIBUTE_VALUE);
    PredefinedAllowedAttributeValue predefinedAllowedAttributeValue = new PredefinedAllowedAttributeValue();
    predefinedAllowedAttributeValue.setPredefinedAllowedAttributeCode(OLD_BRAND_CODE);
    predefinedAllowedAttributeValue.setValue(BRAND);
    MasterDataProductAttributeValue masterDataProductAttributeValueExisting = new MasterDataProductAttributeValue();
    masterDataProductAttributeValueExisting.setAllowedAttributeValue(masterDataAllowedAttributeValueExisting);
    masterDataProductAttributeValueExisting.setPredefinedAllowedAttributeValue(predefinedAllowedAttributeValue);
    MasterDataProductAttribute masterDataProductAttributeExisting = new MasterDataProductAttribute();
    masterDataProductAttributeExisting.setMasterDataAttribute(masterDataAttributeExisting);
    masterDataProductAttributeExisting.setMasterDataProductAttributeValues(new ArrayList<>());
    masterDataProductAttributeExisting.getMasterDataProductAttributeValues().add(masterDataProductAttributeValueExisting);

    this.masterDataProductUpdated = new MasterDataProduct();
    this.masterDataProductUpdated.setHeight(ProductServiceImplTest.UPDATED_DOUBLE);
    this.masterDataProductUpdated.setWeight(ProductServiceImplTest.UPDATED_DOUBLE);
    this.masterDataProductUpdated.setShippingWeight(ProductServiceImplTest.UPDATED_DOUBLE);
    this.masterDataProductUpdated.setWidth(ProductServiceImplTest.UPDATED_DOUBLE);
    this.masterDataProductUpdated.setLength(ProductServiceImplTest.UPDATED_DOUBLE);
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.NEW_PRODUCT_NAME);
    this.masterDataProductUpdated.setMasterDataProductAttributes(new ArrayList<>());
    this.masterDataProductUpdated.getMasterDataProductAttributes().add(masterDataProductAttributeExisting);

    this.productUpdated = new Product();
    this.productUpdated.setStoreId(ProductServiceImplTest.STORE_ID);
    this.productUpdated.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productUpdated.setProductType(ProductType.REGULAR);
    this.productUpdated.setSettlementType(ProductServiceImplTest.SETTLEMENT_TYPE_UPDATED);
    this.productUpdated.setMasterDataProduct(this.masterDataProductUpdated);

    this.productUnsyncUpdated = new Product();
    this.productUnsyncUpdated.setStoreId(ProductServiceImplTest.STORE_ID);
    this.productUnsyncUpdated.setProductSku(ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    this.productUnsyncUpdated.setProductType(ProductType.REGULAR);
    this.productUnsyncUpdated.setSettlementType(ProductServiceImplTest.SETTLEMENT_TYPE_UPDATED);
    this.productUnsyncUpdated.setMasterDataProduct(this.masterDataProductUpdated);
    this.productUnsyncUpdated.setProductSpecialAttributes(Collections.emptyList());

    this.masterDataProductToBeUpdated = new MasterDataProduct();
    this.masterDataProductToBeUpdated.setBrand(ProductServiceImplTest.BRAND);
    this.masterDataProductToBeUpdated.setHeight(ProductServiceImplTest.HEIGHT);
    this.masterDataProductToBeUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    this.masterDataProductToBeUpdated.setMasterDataProductAttributes(new ArrayList<>());
    this.masterDataProductToBeUpdated.getMasterDataProductAttributes().add(masterDataProductAttributeExisting);

    this.productSyncTobeUpdated = new Product();
    this.productSyncTobeUpdated.setStoreId(ProductServiceImplTest.STORE_ID);
    this.productSyncTobeUpdated.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setProductType(ProductType.BOPIS);
    this.productSyncTobeUpdated.setProductCode(ProductServiceImplTest.PRODUCT_CODE);
    this.productSyncTobeUpdated.setSettlementType(ProductServiceImplTest.SETTLEMENT_TYPE);
    this.productSyncTobeUpdated.setSynchronized(ProductServiceImplTest.IS_SYNCHRONIZED);
    this.productSyncTobeUpdated.setMasterDataProduct(this.masterDataProductToBeUpdated);
    this.productSyncTobeUpdated.setProductSpecialAttributes(Collections.emptyList());
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);

    this.productUnSyncTobeUpdated = new Product();
    this.productUnSyncTobeUpdated.setStoreId(ProductServiceImplTest.STORE_ID);
    this.productUnSyncTobeUpdated
        .setProductSku(ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    this.productUnSyncTobeUpdated.setProductType(ProductType.BOPIS);
    this.productUnSyncTobeUpdated.setSettlementType(ProductServiceImplTest.SETTLEMENT_TYPE);
    this.productUnSyncTobeUpdated.setSynchronized(!ProductServiceImplTest.IS_SYNCHRONIZED);
    this.productUnSyncTobeUpdated.setMasterDataProduct(this.masterDataProductToBeUpdated);
    this.productUnSyncTobeUpdated.setProductSpecialAttributes(Collections.emptyList());

    this.itemBuyableSchedules = new ItemBuyableSchedule();
    this.itemBuyableSchedules.setBuyable(ProductServiceImplTest.IS_DISPLAYABLE);

    this.itemDiscoverableSchedules = new ItemDiscoverableSchedule();
    this.itemDiscoverableSchedules.setDiscoverable(ProductServiceImplTest.IS_DISCOVERABLE);

    this.productViewConfigAdded = new ItemViewConfig();
    this.productViewConfigAdded.setChannel(ProductServiceImplTest.CHANNEL_WEB);
    this.productViewConfigAdded.setItemBuyableSchedules(this.itemBuyableSchedules);
    this.productViewConfigAdded.setDiscoverable(true);
    this.productViewConfigAdded.setBuyable(true);

    this.itemViewConfigs = new HashSet<>();
    this.itemViewConfigs.add(this.productViewConfigAdded);

    this.productWithProductViewConfigAdded = new Product();
    this.productWithProductViewConfigAdded.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);

    this.productWithProductViewConfigToBeAdded = new Product();
    this.productWithProductViewConfigToBeAdded
        .setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);

    this.productDisplayableSchedulesUpdated = new ItemBuyableSchedule();
    this.productDisplayableSchedulesUpdated.setBuyable(!ProductServiceImplTest.IS_DISPLAYABLE);

    this.productDiscoverableSchedulesUpdated = new ItemDiscoverableSchedule();
    this.productDiscoverableSchedulesUpdated
        .setDiscoverable(!ProductServiceImplTest.IS_DISCOVERABLE);

    this.productViewConfigWithChannelNotFound = new ItemViewConfig();
    this.productViewConfigWithChannelNotFound.setChannel(ProductServiceImplTest.CHANNEL_MOBILE);

    this.productWithProductViewConfigDeleted = new Product();
    this.productWithProductViewConfigDeleted.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);

    this.productDetailResponse = new ProductDetailResponse();
    this.productDetailResponse.setProductCategoryResponses(this.productCategoryResponses);
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setShippingWeight(10.0);
    AttributeResponse attributeResponse = new AttributeResponse();
    attributeResponse.setAttributeCode(ATTRIBUTE_CODE);
    ProductAttributeResponse productAttributeResponse = new ProductAttributeResponse();
    productAttributeResponse.setAttribute(attributeResponse);
    ProductAttributeValueResponse productAttributeValueResponse = new ProductAttributeValueResponse();
    productAttributeValueResponse.setDescriptiveAttributeValue(
        com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.SINGLE.name());
    productAttributeResponse.setProductAttributeValues(Arrays.asList(productAttributeValueResponse));
    this.productDetailResponse.setProductAttributeResponses(Arrays.asList(productAttributeResponse));
    productDetailResponse.setProductItemResponses(new HashSet<>());
    this.productDetailResponseGdn =
        new GdnRestSingleResponse<>(this.productDetailResponse, ProductServiceImplTest.REQUEST_ID);


    this.setOfProducts = new HashSet<>();
    this.setOfProducts.add(this.productSync);

    this.offlineItem = new OfflineItem();
    this.offlineItem.setItemSku(ITEM_SKU_OFFLINE_ITEM);

    this.product = new Product();
    this.product.setProductSku(ProductServiceImplTest.PRODUCT_SKU);
    this.product.setMerchantCode(ProductServiceImplTest.MERCHANT_CODE);
    this.product.setProductCode(ProductServiceImplTest.PRODUCT_CODE);

    productScoreRequest.setItemRequests(new ArrayList<>());
    productScoreRequest.setProductAttributeRequests(new ArrayList<>());
    productScoreRequest.setCategoryCode(CATEGORY_CODE);
    productScoreRequest.setBrand(BRAND);
    productScoreVo = ProductScoreVo.builder().descriptionScore(10).totalScore(80).build();


    ProductSolr productSolr = new ProductSolr();
    productSolr.setProductSku(PRODUCT_SKU);
    productSolr.setProductName(NEW_PRODUCT_NAME);
    productSolr.setSuspended(false);
    productSolr.setMasterCatalog("10001#_#CAT-CODE");
    productSolr.setSalesCatalog(Arrays.asList("10001#_#CAT-CODE"));
    productSolr.setProductCenterUpdatedDate(new Date());
    productSolrPage = new PageImpl<>(Arrays.asList(productSolr), PageRequest.of(0, 100), 1);

    productSolr2 = new ProductSolr();
    productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    productSolr2.setProductCode(PRODUCT_CODE);
    productSolr2.setProductName(PRODUCT_NAME);
    productSolr2.setBrand(BRAND);
    productSolr2.setMerchantCode(MERCHANT_CODE);
    productSolr2.setStoreId(STORE_ID);
    productSolr.setMasterCatalog("10001#_#CAT-CODE2");
    productSolr.setSalesCatalog(Arrays.asList("10001#_#CAT-CODE2"));
    productSolr2.setProductScoreTotal(80.0);
    productSolr2.setProductCenterUpdatedDate((new SimpleDateFormat("yyyy/MM/dd").parse("2021/01/20")));
    productSolr2.setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolr2.setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolr2.setIsArchived(false);
    productSolr2.setOff2OnChannelActive(false);
    productSolr2.setInStock(true);
    productSolr2.setIsPreOrderActive(false);
    productSolr2.setVariantCount(1);
    productAndL5MigrationRequest= new ProductAndL5MigrationRequest();
    Map categoryMap = new HashMap();
    categoryMap.put("CAT-CODE", "CAT-NAME");
    categoryNamesResponse = new CategoryNamesResponse(categoryMap);

    salesCategoryUpdateRequest = SalesCategoryUpdateRequest.builder().categoryCode(CATEGORY_CODE).
        catalogCode(CATALOG_CODE).build();
    salesCategoryUpdateRequest1 = SalesCategoryUpdateRequest.builder().categoryCode(CATEGORY_CODE_UPDATED)
        .catalogCode(CATALOG_CODE).build();

    ReflectionTestUtils.setField(productServiceImpl, "isPVSwitchEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "b2bSalesCatalogCode", "12052");
    ReflectionTestUtils.setField(productServiceImpl, "multiGetItemsInL3Listing", true);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productSync);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND))
        .thenReturn(null);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC))
        .thenReturn(this.productUnsync);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_NOT_FOUND, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC))
        .thenReturn(null);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC, false))
        .thenReturn(this.productSync);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND, false))
        .thenReturn(null);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false))
        .thenReturn(this.productUnsync);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_NOT_FOUND, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false))
        .thenReturn(null);

    when(this.productCategoryBaseClient.getProductDetailByProductCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        this.productSync.getProductCode())).thenReturn(this.productDetailResponse);

    when(this.productCategoryBaseClient.getProductDetailByProductCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);

    when(this.objectConverterService.convertToMasterDataProduct(this.productDetailResponse))
        .thenReturn(this.masterDataProduct);

    when(this.saveOperationService.saveProduct(this.productSync)).thenReturn(this.productSync);
    when(this.saveOperationService.saveProduct(this.productUnsync)).thenReturn(this.productUnsync);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_TOBE_UPDATED))
        .thenReturn(this.productTobeUpdated);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_TOBE_UPDATED, false))
        .thenReturn(this.productTobeUpdated);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_NOT_FOUND, ProductServiceImplTest.PRODUCT_SKU_TOBE_UPDATED))
        .thenReturn(null);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_NOT_FOUND, ProductServiceImplTest.PRODUCT_SKU_TOBE_UPDATED, false))
        .thenReturn(null);

    when(this.saveOperationService.saveProduct(this.productTobeUpdated))
        .thenReturn(this.productSyncUpdated);

    when(this.saveOperationService.saveProduct(this.productSyncTobeUpdated))
        .thenReturn(this.productUpdated);

    when(this.saveOperationService.saveProduct(this.productRequestVO))
        .thenReturn(this.productRequestVO);

    when(this.saveOperationService.saveItems(this.listOfItems, null)).thenReturn(this.listOfItems);

    when(this.itemService.getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(this.listOfItems);
    when(this.itemService.getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS)).thenReturn(this.emptyList);
    when(this.productRepository.save(this.productUnSyncTobeUpdated))
        .thenReturn(this.productUnsyncUpdated);

    when(this.itemService.getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(this.listOfItems);

    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.listOfItems);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS))
        .thenReturn(this.emptyList);
    when(this.productRepository.save(this.productUnSyncTobeUpdated))
        .thenReturn(this.productUnsyncUpdated);

    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC))
        .thenReturn(this.listOfItems);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS))
        .thenReturn(this.productSyncTobeUpdated);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS, false))
        .thenReturn(this.productSyncTobeUpdated);

    when(this.saveOperationService.saveProduct(this.productSyncTobeUpdated))
        .thenReturn(this.productSyncTobeUpdated);

    when(this.itemService.getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS)).thenReturn(this.emptyList);
    when(this.saveOperationService.saveItems(this.emptyList, null)).thenReturn(this.emptyList);

    when(this.itemService.getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(this.listOfItems);

    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS))
        .thenReturn(this.emptyList);
    when(this.saveOperationService.saveItems(this.emptyList, null)).thenReturn(this.emptyList);

    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.listOfItems);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED))
        .thenReturn(this.productUnSyncTobeUpdated);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED))
        .thenReturn(this.productSyncTobeUpdated);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_FOR_PRODUCT_VIEW_CONFIG_ADDED,
        ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productWithProductViewConfigToBeAdded);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(this.productUnSyncTobeUpdated);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false))
        .thenReturn(this.productSyncTobeUpdated);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_FOR_PRODUCT_VIEW_CONFIG_ADDED,
        ProductServiceImplTest.PRODUCT_SKU_SYNC, false))
        .thenReturn(this.productWithProductViewConfigToBeAdded);

    when(this.saveOperationService.saveProduct(this.productWithProductViewConfigAdded))
        .thenReturn(this.productWithProductViewConfigAdded);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_PRODUCT_VIEW_CONFIG_UPDATED,
        ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productWithProductViewConfigToBeAddedWithExistingChannel);

    when(this.saveOperationService.saveProduct(this.productWithProductViewConfigUpdated))
        .thenReturn(this.productWithProductViewConfigUpdated);

    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID_WITH_CHANNEL_NOT_FOUND,
        ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productWithProductViewConfigToBeAdded);
    when(this.productRepository.save(this.productWithProductViewConfigDeleted))
        .thenReturn(this.productWithProductViewConfigDeleted);

    when(this.productHelperService.setMasterDataProductFromMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, this.productSync)).thenReturn(this.productSync);

    when(this.productHelperService.setMasterDataProductFromMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, this.productUnsync)).thenReturn(this.productUnsync);

    when(this.productScoreUtil.getProductScoreByProductScoreRequest(productScoreRequest)).thenReturn(productScoreVo);
    this.productCodes = new HashSet<>();
    this.productCodes.add(ProductServiceImplTest.PRODUCT_CODE);
    Map<String, MasterDataProduct> mapOfMasterDataProduct = new HashMap<>();
    mapOfMasterDataProduct.put(ProductServiceImplTest.PRODUCT_CODE,
        ProductServiceImplTest.MASTER_DATA_PRODUCT);
    when(this.masterDataService.getMasterDataProducts(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, this.productCodes))
        .thenReturn(mapOfMasterDataProduct);

    this.masterDataItem = new MasterDataItem();
    this.masterDataItem.setItemHeight(ProductServiceImplTest.HEIGHT);

    this.itemWithMasterDataItem = new Item();
    this.itemWithMasterDataItem.setMasterDataItem(this.masterDataItem);

    this.listOfItemWithMasterDataItem = new ArrayList<>();
    this.listOfItemWithMasterDataItem.add(this.itemWithMasterDataItem);

    when(this.productHelperService.setMultipleMasterDataItemsFromMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, this.listOfItems))
        .thenReturn(this.listOfItemWithMasterDataItem);

    when(this.itemService.getItemsByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED)).thenReturn(this.emptyList);

    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED))
        .thenReturn(this.emptyList);

    when(this.productHelperService.modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME))
        .thenReturn(this.emptyList);

    when(this.saveOperationService.saveItems(this.emptyList, null)).thenReturn(this.emptyList);

    this.productRequestVO = new Product();
    this.productRequestVO.setMerchantCode(ProductServiceImplTest.MERCHANT_CODE);
    this.productRequestVO.setProductCode(ProductServiceImplTest.PRODUCT_CODE);

    this.productAndItemsVO = new ProductAndItemsVO();
    this.productAndItemsVO.setItems(this.listOfItemRequestVO);
    this.productAndItemsVO.setProduct(this.productSync);

    this.productCounterResponse = new ProductCounterResponse();
    this.productCounterResponse.setBusinessPartnerCode(ProductServiceImplTest.MERCHANT_CODE);
    this.productCounterResponse.setCounter(ProductServiceImplTest.PRODUCT_COUNTER);

    editProductDetailDTO = new EditProductDetailDTO();
    editProductDetailDTO.setProduct(productSyncTobeUpdated);
    editProductDetailDTO.setProductDetailResponse(productDetailResponse);

    this.productCounterResponseGdn =
        new GdnRestSingleResponse<>(this.productCounterResponse, ProductServiceImplTest.REQUEST_ID);

    when(this.xbpOutbound.productCounterIncrementAndGet(any(), any(), any(),
        eq(ProductServiceImplTest.MERCHANT_CODE))).thenReturn(productCounterResponse);

    when(this.productHelperService.setProductDetail(ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.STORE_ID, this.productSync,
        this.productDetailResponse)).thenReturn(this.productSync);

    when(this.productRepository.findProductsByStoreIdAndMerchantCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.MERCHANT_CODE))
        .thenReturn(this.setOfProducts);
    when(this.itemService.getItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false, false))
        .thenReturn(this.item);
    when(this.skuValidator.isItemSku(ProductServiceImplTest.ITEM_SKU)).thenReturn(true);
    when(this.skuValidator.isItemSkuL4OrL5(ProductServiceImplTest.ITEM_SKU)).thenReturn(true);
    when(this.skuValidator.isItemSkuL4OrL5(ProductServiceImplTest.ITEM_SKU_2)).thenReturn(true);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND))
        .thenReturn(true);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(true);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED))
        .thenReturn(true);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED))
        .thenReturn(true);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU_TOBE_UPDATED))
        .thenReturn(true);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC))
        .thenReturn(true);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS))
        .thenReturn(true);

    when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.PRODUCT_AVAILIBILITY_REQUEST_LIMIT))
        .thenReturn(new SystemParameter(STORE_ID,
            SystemParameterNames.PRODUCT_AVAILIBILITY_REQUEST_LIMIT, "2", ""));

    when(this.productCacheableService
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productSync);

    systemParameter.setValue(CATEGORY_CODE_FOR_UNSYNC_CHECK);
    systemParameter.setVariable(Constants.CATEGORY_CODE_VARIABLE);
    when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE))
        .thenReturn(systemParameter);


    masterDataAttributeUpdated.setAttributeCode(ATTRIBUTE_CODE);
    masterDataProductAttributeValueUpdated.setDescriptiveAttributeValue("123456");
    masterDataProductAttributeValueUpdated.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);
    masterDataAttributeUpdated.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE);
    masterDataProductAttributeValues.add(masterDataProductAttributeValueUpdated);
    masterDataProductAttributeUpdated.setMasterDataProductAttributeValues(masterDataProductAttributeValues);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);

    oldSalesCategoryList = new ArrayList<>();
    oldSalesCategoryList.add(OLD_CAT_1);
    oldSalesCategoryList.add(OLD_CAT_2);
    oldSalesCategoryList.add(OLD_CAT_3);
    newSalesCategoryList = new ArrayList<>();
    newSalesCategoryList.add(NEW_CAT_1);
    newSalesCategoryList.add(NEW_CAT_2);
    newUmkmSalesCategoryList = new ArrayList<>();
    newUmkmSalesCategoryList.add(NEW_UMKM_CAT_1);
    newUmkmSalesCategoryList.add(NEW_UMKM_CAT_2);
    ReflectionTestUtils.setField(productServiceImpl, "salesCategoryCatalogCode", "12051");

    masterDataPredefinedAttributeValueUpdated.setValue(PREDEFINED_ATTRIBUTE_VALUE);
    masterDataPredefinedAttributeValueExisting.setValue(PREDEFINED_ATTRIBUTE_VALUE_2);

    masterDataProductImage.setProductCode(PRODUCT_CODE);
    masterDataProductImage.setMainImage(true);
    masterDataProductImage.setLocationPath(LOCATION_PATH);

    productSalesCategoryMapping = new ProductSalesCategoryMapping();
    productSalesCategoryMapping.setOldSalesCategoryCodes(oldSalesCategoryList);
    productSalesCategoryMapping.setNewSalesCategoryCodes(newSalesCategoryList);
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(newUmkmSalesCategoryList);

    CategoryDomainEventModel categoryDomainEventModel = new CategoryDomainEventModel();
    categoryDomainEventModel.setCategoryCode(CATEGORY_CODE);
    categoryDomainEventModel.setCatalog(new CatalogDomainEventModel(NAME, CATALOG_CODE, CATALOG_CODE));
    productCategoryDomainEventModel = new ProductCategoryDomainEventModel(categoryDomainEventModel);

    BeanUtils.copyProperties(productSalesCategoryMappingResponse, productSalesCategoryMapping);

    oldProductScore.setDescriptionScore(10.0);
    oldProductScore.setImageScore(10.0);
    oldProductScore.setMandatoryAttributeScore(10.0);
    oldProductScore.setProductTitleScore(10.0);
    oldProductScore.setRecommendedAttributeScore(10.0);
    oldProductScore.setRemainingAttributeScore(10.0);
    oldProductScore.setUspScore(10.0);
    oldProductScore.setVariantCreatingScore(10.0);
    oldProductScore.setVideoUrlScore(10.0);
    oldProductScore.setTotalScore(90.0);

    BeanUtils.copyProperties(productScoreVo, oldProductScore);
    productItemResponse.setUpcCode(UPC_CODE);
    productItemResponse.setImages(new ArrayList<>());

    videoListResponse = new VideoListResponse();
    PageInfo pageInfo = new PageInfo();
    pageInfo.setTotalResults(2);
    videoListResponse.setPageInfo(pageInfo);
    ReflectionTestUtils.setField(productServiceImpl, "youTubeDataApiKey", API_KEY);

    this.productSolr1.setProductSku(PRODUCT_SKU);
    this.productSolr1.setMasterCatalog(STORE_ID + "#_#" + CATEGORY_CODE);
    this.productSolr1.setProductCode(PRODUCT_CODE);
    this.productSolr1.setSuspended(true);
    this.productSolr1.setProductName(NEW_PRODUCT_NAME);
    this.productSolr1.setProductMainImage("abc.jpg");
    this.productSolr1.setMerchantCode(MERCHANT_CODE);
    this.productSolr1.setMarkForDelete(false);
    this.productSolr1.setProductCenterUpdatedDate(new Date());

    productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    productSolr2.setProductCode(PRODUCT_CODE);
    productSolr2.setProductName(PRODUCT_NAME);
    productSolr2.setBrand(BRAND);
    productSolr2.setMerchantCode(MERCHANT_CODE);
    productSolr2.setStoreId(STORE_ID);
    productSolr2.setProductScoreTotal(80.0);
    productSolr2.setProductCenterUpdatedDate((new SimpleDateFormat("yyyy/MM/dd").parse("2021/01/20")));
    productSolr2.setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolr2.setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolr2.setIsArchived(false);
    productSolr2.setOff2OnChannelActive(false);
    productSolr2.setInStock(true);
    productSolr2.setIsPreOrderActive(false);
    productSolr2.setVariantCount(1);

    preOrder = new PreOrder();
    preOrder.setIsPreOrder(true);
    preOrder.setPreOrderType(PREORDER_TYPE);
    preOrder.setPreOrderValue(PREORDER_VALUE);
    preOrder.setPreOrderDate(new Date());

    video = new Video();
    video.setVideoId("videoId");
    video.setSourceUrl("sourceUrl");
    video.setFinalUrl("finalUrl");
    video.setCoverImagePath("/gcs/coverImagePath");

    preOrderDTO = new PreOrderDTO();
    stringBooleanMap.put(PRODUCT_SKU, true);
    itemActivationRequest =
        NeedCorrectionItemActivationRequest.builder().itemSku(ITEM_SKU).isBuyable(true).isDiscoverable(true)
            .listPrice(10.0).offerPrice(11.0).merchantSku(MERCHANT_SKU).pickupPointCode(PICKUP_POINT_CODE).build();

    this.businessPartnerPromo.setBusinessPartnerCode(MERCHANT_CODE);
    this.businessPartnerPromo.setActivePromoBundlings(Collections.singleton(CATALOG_CODE));
    this.productAndItemInfoResponse = new ProductAndItemInfoResponse(new ProductInfoResponse(),
        new ItemInfoResponse());
    this.productAndItemInfoResponse.getProduct().setMerchantCode(MERCHANT_CODE);
    this.productAndItemsResponse = new ProductAndItemsResponse(new ProductResponse(),
        Collections.singletonList(new ItemResponse()));
    this.productAndItemsResponse.getProduct().setMerchantCode(MERCHANT_CODE);
    this.productAndItemsDTO = new ProductAndItemsDTO(new ProductResponse(),
        Collections.singletonList(new ItemResponse()));
    this.productAndItemsDTO.getProduct().setMerchantCode(MERCHANT_CODE);
    this.productItemsVo =
        new ProductItemsVo(new ProductVo(), Collections.singletonList(new ItemVo()));
    this.productItemsVo.getProductVo().setMerchantCode(MERCHANT_CODE);

    itemPickupPoint = new ItemPickupPoint();
    itemPickupPoint.setItemSku(ITEM_SKU);
    itemViewConfigList = new HashSet<>(Arrays
        .asList(new ItemViewConfig(true, false, "DEFAULT", new ItemDiscoverableSchedule(), new ItemBuyableSchedule())));
    prices = new HashSet<>(Arrays.asList(new Price("$", 10, 10, "", "", new Date())));
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    itemPickupPoint.setPrice(prices);
    itemPickupPoint.setMerchantPromoDiscount(true);
    when(itemPickupPointService.findByItemSkuInAndDelivery(anyString(), anyList(), anyBoolean()))
        .thenReturn(Arrays.asList(itemPickupPoint));
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(product, Arrays.asList(item)));
    message = new ProductDomainEventModel();
    businessPartner = new BusinessPartner();
    List<String> sellerChannel = new ArrayList<>();
    sellerChannel.add(Constants.B2B_SELLER_CHANNEL);
    sellerChannel.add(Constants.B2C_SELLER_CHANNEL);
    businessPartner.setSalesChannel(sellerChannel);
    ReflectionTestUtils.setField(productServiceImpl, "salesCatalogCodes", "12051,12052");
    ReflectionTestUtils.setField(productServiceImpl, "updateMasterDataDetailsForUnsyncProducts", false);
    ReflectionTestUtils.setField(productServiceImpl, "skipMfdUpdateForSuspendedProduct", false);
    halalHistoryUpdateEventModel = new HalalHistoryUpdateEventModel();
    halalHistoryUpdateEventModel.setStoreId(STORE_ID);
    halalHistoryUpdateEventModel.setProductSku(PRODUCT_SKU);
    halalHistoryUpdateEventModel.setActivity(ACTIVITY);
    halalHistoryUpdateEventModel.setPreviousValue(PREVIOUS_VALUE);
    halalHistoryUpdateEventModel.setCurrentValue(CURRENT_VALUE);
    halalHistoryUpdateEventModel.setUserName(USERNAME);


    itemBuyableSchedule = new ItemBuyableSchedule();
    itemDiscoverableSchedule = new ItemDiscoverableSchedule();
    itemBuyableSchedule.setBuyable(true);
    itemBuyableSchedule.setStartDateTime(TEN_DAYS_AGO);
    itemBuyableSchedule.setEndDateTime(TEN_DAYS_AFTER);
    itemDiscoverableSchedule.setDiscoverable(true);
    itemDiscoverableSchedule.setStartDateTime(TEN_DAYS_AGO);
    itemDiscoverableSchedule.setEndDateTime(TEN_DAYS_AFTER);

  }

  @AfterEach
  public void tearDown() throws Exception {
    verifyNoMoreInteractions(this.objectConverterService);
    verifyNoMoreInteractions(this.productCategoryBaseClient);
    verifyNoMoreInteractions(this.productCacheableService);
    verifyNoMoreInteractions(this.productHelperService);
    verifyNoMoreInteractions(this.itemService);
    verifyNoMoreInteractions(this.masterDataAttributeService);
    verifyNoMoreInteractions(this.saveOperationService);
    verifyNoMoreInteractions(this.catalogService);
    verifyNoMoreInteractions(this.cacheEvictHelperService);
    verifyNoMoreInteractions(this.productRepository);
    verifyNoMoreInteractions(this.offlineItemService);
    verifyNoMoreInteractions(this.productSearchHelperService);
    verifyNoMoreInteractions(this.saveAndPublishService);
    verifyNoMoreInteractions(this.cacheItemHelperService);
    verifyNoMoreInteractions(this.systemParameterService);
    verifyNoMoreInteractions(this.businessPartnerService);
    verifyNoMoreInteractions(this.productScoreUtil);
    verifyNoMoreInteractions(this.productScoreHistoryL3Service);
    verifyNoMoreInteractions(this.productCenterHistoryService);
    verifyNoMoreInteractions(this.productSolrRepository);
    verifyNoMoreInteractions(this.solrDataConstructor, this.productAndItemSolrIndexerService);
    verifyNoMoreInteractions(this.businessPartnerPromoService);
    verifyNoMoreInteractions(this.businessPartnerPickupPointService);
    verifyNoMoreInteractions(this.itemPriceService);
    verifyNoMoreInteractions(this.gdnMapperMock);
    verifyNoMoreInteractions(this.xbpOutbound);
    verifyNoMoreInteractions(this.cachedService);
  }

  @Test
  public void synchronizeProductTest() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, ProductServiceImplTest.USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.REQUEST_ID_KEY_PARAMETER,  ProductServiceImplTest.REQUEST_ID);

    this.productSync.setSynchronized(false);
    this.listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.listOfItems);
    ProductAndItemsVO vo = new ProductAndItemsVO(this.productSync, this.listOfItemWithMasterDataItem);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterDataAndEvictCaches(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync, this.listOfItems)).thenReturn(vo);
    when(this.saveOperationService.saveProductAndItemsWithoutUpdatingSolr(any(ProductAndItemsVO.class)))
        .thenReturn(productAndItemsVO);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.masterDataService.getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    ProductAndItemsVO result = this.productServiceImpl.synchronizeProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.masterDataService).getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE);
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.masterDataConstructorService).constructProductAndItemWithMasterDataAndEvictCaches(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync, this.listOfItems);
    verify(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeProduct(this.productSync);
    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeItems(this.listOfItemWithMasterDataItem);
    verify(this.saveOperationService).saveProductAndItemsWithoutUpdatingSolr(productAndItemsVOArgumentCaptor.capture());
    verify(this.productAndItemSolrIndexerService).updateSolrOnSyncUnsyncAction(productAndItemsVO);
    for(Item item : listOfItems){
      Assertions.assertEquals(ItemChangeEventType.SYNC_UNSYNC_FLAG_CHANGE,
          item.getItemChangeEventTypes().get(0));
    }
    assertNotNull(result);
    MDC.clear();
  }

  @Test
  public void synchronizeProductTestWithProductCodeIsNull() throws Exception {
    this.productSync.setProductCode(null);
    ProductAndItemsVO result = null;
    try {
      result = this.productServiceImpl.synchronizeProduct(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.PRODUCT_SKU_SYNC);
    } catch (Exception e) {
      assertNull(result);
    }
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC, false);
  }

  @Test
  public void synchronizeProductTestWithProductIsSync() throws Exception {
    ProductAndItemsVO result = null;
    try {
      result = this.productServiceImpl.synchronizeProduct(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.PRODUCT_SKU_SYNC);
    } catch (Exception e) {
      assertNull(result);
    }
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC, false);
  }

  @Test
  public void synchronizeProductTestWithEmptyItemsFound() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, ProductServiceImplTest.USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.REQUEST_ID_KEY_PARAMETER,  ProductServiceImplTest.REQUEST_ID);
    this.productSyncTobeUpdated.setSynchronized(false);
    System.out.println("check: " +productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());
    when(this.masterDataService.getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE))
        .thenReturn(this.productDetailResponse);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    ProductAndItemsVO result = this.productServiceImpl.synchronizeProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS, false);

    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS);
    verify(this.masterDataService).getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE);
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutUpdatingSolr(new ProductAndItemsVO(this.productSyncTobeUpdated, this.emptyList));
    verify(this.productAndItemSolrIndexerService)
        .updateSolrOnSyncUnsyncAction(any());
    assertNull(result);
  }

  @Test
  public void synchronizeProductTestWithProductNotFound() {
    try {
      this.productServiceImpl.synchronizeProduct(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND);
    } catch (Exception e) {
      verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
          ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND, false);

      assertTrue(e instanceof ApplicationRuntimeException);
    }
  }

  @Test
  public void unsynchronizeProductTestWithEmptyItemsFound() throws Exception {
    ProductAndItemsVO result = this.productServiceImpl.unsynchronizeProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS, false);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS, false);

    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITHOUT_ITEMS);

    verify(this.saveOperationService)
        .saveProductAndItemsWithoutUpdatingSolr(new ProductAndItemsVO(this.productSyncTobeUpdated, this.emptyList));
    verify(this.productAndItemSolrIndexerService)
        .updateSolrOnSyncUnsyncAction(any());

    assertNull(result);
  }

  @Test
  public void unsynchronizeProductTestWithNotOverwriteAndMasterDataExists() throws Exception {
    this.productUnsync.setSynchronized(true);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC))
        .thenReturn(this.listOfItemWithMasterDataItem);
    when(this.saveOperationService.saveProductAndItemsWithoutUpdatingSolr(any(ProductAndItemsVO.class)))
        .thenReturn(productAndItemsVO);
    ProductAndItemsVO result = this.productServiceImpl.unsynchronizeProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.saveOperationService).saveProductAndItemsWithoutUpdatingSolr(
        new ProductAndItemsVO(this.productUnsync, this.listOfItemWithMasterDataItem));
    verify(this.productAndItemSolrIndexerService)
        .updateSolrOnSyncUnsyncAction(any(ProductAndItemsVO.class));

    assertNotNull(result);
  }

  @Test
  public void unsynchronizeProductTestWithNotOverwriteAndMasterDataNotExists() throws Exception {
    this.productUnsync.setMasterDataProduct(null);
    this.productUnsync.setSynchronized(true);
    ProductAndItemsVO vo =
        new ProductAndItemsVO(this.productUnsync, this.listOfItemWithMasterDataItem);
    when(this.saveOperationService.saveProductAndItemsWithoutUpdatingSolr(any(ProductAndItemsVO.class)))
        .thenReturn(productAndItemsVO);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems)).thenReturn(vo);
    ProductAndItemsVO result = this.productServiceImpl.unsynchronizeProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);

    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeProduct(this.productUnsync);
    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeItems(this.listOfItemWithMasterDataItem);

    verify(this.saveOperationService).saveProductAndItemsWithoutUpdatingSolr(
        new ProductAndItemsVO(this.productUnsync, this.listOfItemWithMasterDataItem));
    verify(this.productAndItemSolrIndexerService)
        .updateSolrOnSyncUnsyncAction(any(ProductAndItemsVO.class));
    verify(this.masterDataConstructorService)
        .constructItemDimensionFields(any(MasterDataItem.class), any());
    for(Item item : listOfItemWithMasterDataItem) {
      Assertions.assertEquals(ItemChangeEventType.SYNC_UNSYNC_FLAG_CHANGE,
          item.getItemChangeEventTypes().get(0));
    }
    assertNotNull(result);
  }

  @Test
  public void unsynchronizeProductTestWithOverwriteAndMasterDataExists() throws Exception {
    this.productUnsync.setSynchronized(true);
    ProductAndItemsVO vo =
        new ProductAndItemsVO(this.productUnsync, this.listOfItemWithMasterDataItem);
    when(this.masterDataConstructorService.constructProductAndItemWithMasterData(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems)).thenReturn(vo);
    ProductAndItemsVO result = this.productServiceImpl.unsynchronizeProduct(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, true);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeProduct(this.productUnsync);
    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeItems(this.listOfItemWithMasterDataItem);
    verify(this.saveOperationService).saveProductAndItemsWithoutUpdatingSolr(productAndItemsVOArgumentCaptor.capture());
    verify(this.productAndItemSolrIndexerService)
        .updateSolrOnSyncUnsyncAction(any());
    verify(this.masterDataConstructorService)
        .constructItemDimensionFields(any(MasterDataItem.class), any(MasterDataProduct.class));
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getItems().get(0).isContentChanged());

  }

  @Test
  public void unsynchronizeProductTestWithProductNotFound() {
    try {
      this.productServiceImpl.unsynchronizeProduct(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND, false);
    } catch (Exception e) {
      verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
          ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_NOT_FOUND, false);

      assertTrue(e instanceof ApplicationRuntimeException);
    }
  }

  @Test
  public void addProductAttribute_MasterDataProductAttributeIsNull_Test() throws Exception {
    this.masterDataProductAttribute = new MasterDataProductAttribute();
    this.productUnsync.getMasterDataProduct().setMasterDataProductAttributes(null);
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(products);
    Boolean result =
        this.productServiceImpl.addProductAttribute(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterDataProductAttribute);

    verify(this.productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(this.productUnsync);
    verify(this.masterDataAttributeService).setAndSaveMasterDataAttributeProduct(this.productUnsync);
    assertNotNull(result);
  }

  @Test
  public void addProductAttribute_MasterDataProductAttributeIsNull() throws Exception {
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(products);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl
        .addProductAttribute(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, null));
  }

  @Test
  public void addProductAttribute_CategoryCodeIsExists_Test() throws Exception {
    this.masterDataAttribute = new MasterDataAttribute();
    this.masterDataAttribute.setAttributeCode(ATTRIBUTE_CODE);
    this.masterDataProductAttribute = new MasterDataProductAttribute();
    this.masterDataProductAttribute.setMasterDataAttribute(masterDataAttribute);
    List<MasterDataProductAttribute> masterDataProductAttributes = new ArrayList<>();
    masterDataProductAttributes.add(masterDataProductAttribute);
    this.productUnsync.getMasterDataProduct().setMasterDataProductAttributes(masterDataProductAttributes);
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(products);
    Boolean result =
        this.productServiceImpl.addProductAttribute(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterDataProductAttribute);

    verify(this.productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    assertNotNull(result);
  }

  @Test
  public void addProductAttribute_CategoryCodeIsNotExists_Test() throws Exception {
    this.masterDataProductAttribute = new MasterDataProductAttribute();
    List<MasterDataProductAttribute> masterDataProductAttributes = new ArrayList<>();
    this.productUnsync.getMasterDataProduct().setMasterDataProductAttributes(masterDataProductAttributes);
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(products);

    this.masterDataAttribute2 = new MasterDataAttribute();
    this.masterDataAttribute2.setAttributeCode(ATTRIBUTE_CODE2);
    this.masterDataProductAttribute2 = new MasterDataProductAttribute();
    this.masterDataProductAttribute2.setMasterDataAttribute(masterDataAttribute2);
    Boolean result =
        this.productServiceImpl.addProductAttribute(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterDataProductAttribute2);

    verify(this.productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(this.productUnsync);
    verify(this.masterDataAttributeService).setAndSaveMasterDataAttributeProduct(this.productUnsync);
    assertNotNull(result);
  }

  @Test
  public void addProductAttributeByProductSku_MasterDataProductAttributeIsNull_Test() throws Exception {
    this.masterDataProductAttribute = new MasterDataProductAttribute();
    this.productUnsync.getMasterDataProduct()
        .setMasterDataProductAttributes(null);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false))
        .thenReturn(this.productUnsync);
    Boolean result = this.productServiceImpl.addProductAttributeByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterDataProductAttribute);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false);
    verify(this.saveOperationService).saveProduct(this.productUnsync);
    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeProduct(this.productUnsync);
    assertNotNull(result);
  }

  @Test
  public void addProductAttributeByProductSku_CategoryCodeIsExists_Test() throws Exception {
    this.masterDataAttribute = new MasterDataAttribute();
    this.masterDataAttribute.setAttributeCode(ATTRIBUTE_CODE);
    this.masterDataProductAttribute = new MasterDataProductAttribute();
    this.masterDataProductAttribute.setMasterDataAttribute(masterDataAttribute);
    List<MasterDataProductAttribute> masterDataProductAttributes = new ArrayList<>();
    masterDataProductAttributes.add(masterDataProductAttribute);
    this.productUnsync.getMasterDataProduct()
        .setMasterDataProductAttributes(masterDataProductAttributes);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false))
        .thenReturn(this.productUnsync);
    Boolean result = this.productServiceImpl.addProductAttributeByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterDataProductAttribute);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false);
    assertNotNull(result);
  }

  @Test
  public void addProductAttributeByProductSku_CategoryCodeIsNotExists_Test() throws Exception {
    this.masterDataAttribute = new MasterDataAttribute();
    this.masterDataAttribute.setAttributeCode(ATTRIBUTE_CODE);

    this.masterDataProductAttribute = new MasterDataProductAttribute();
    this.masterDataProductAttribute.setMasterDataAttribute(masterDataAttribute);

    List<MasterDataProductAttribute> masterDataProductAttributes = new ArrayList<>();
    masterDataProductAttributes.add(masterDataProductAttribute);
    this.productUnsync.getMasterDataProduct()
        .setMasterDataProductAttributes(masterDataProductAttributes);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false))
        .thenReturn(this.productUnsync);
    this.masterDataAttribute2 = new MasterDataAttribute();
    this.masterDataAttribute2.setAttributeCode(ATTRIBUTE_CODE2);
    this.masterDataProductAttribute2 = new MasterDataProductAttribute();
    this.masterDataProductAttribute2.setMasterDataAttribute(masterDataAttribute2);
    Boolean result = this.productServiceImpl.addProductAttributeByProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterDataProductAttribute2);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false);
    verify(this.saveOperationService).saveProduct(this.productUnsync);
    verify(this.masterDataAttributeService)
        .setAndSaveMasterDataAttributeProduct(this.productUnsync);
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogByProductCodeTest() throws Exception {
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(products);

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productUnsync.getProductSku()))
        .thenReturn(listOfItems);


    Boolean result =
        this.productServiceImpl.updateProductSalesCatalogByProductCode(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.salesCatalog, true);

    verify(this.productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    this.productUnsync.setMasterCatalog(this.masterCatalogTobeUpdated);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(productUnsync, listOfItems);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productUnsync.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyOldSalesCategoryTest() {
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(OLD_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(3)
            .getCategoryCode());
    assertEquals(4, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyProductTest() {
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(null);
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    assertTrue(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeRemoveOldSalesCategoryTest() {
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    assertEquals(3, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyNewSalesCategoryTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    assertEquals(1, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateCncActivatedByProductSkuAndSolrL3Test() {
    Set<String> productSkuSet = new HashSet<>();
    productSkuSet.add(PRODUCT_SKU);
    productSkuSet.add(PRODUCT_SKU2);

    Mockito.when(productRepository.updateCncActivatedByProductSkusMarkForDeleteFalse(STORE_ID,
        productSkuSet, false, USERNAME)).thenReturn(Arrays.asList(product, productSync));

    productServiceImpl.updateCncActivatedByProductSkuAndSolrL3(STORE_ID, productSkuSet, false, USERNAME);

    Mockito.verify(productRepository).updateCncActivatedByProductSkusMarkForDeleteFalse(STORE_ID, productSkuSet, false, USERNAME);
    Mockito.verify(cacheEvictHelperService).evictProductData(STORE_ID, product);
    Mockito.verify(cacheEvictHelperService).evictProductData(STORE_ID, productSync);
    Mockito.verify(solrRepository).updateCncActivatedByProductSkuSetSolr(STORE_ID, Set.of(product.getProductSku()), false,
        MERCHANT_CODE);
    Mockito.verify(solrRepository).updateCncActivatedByProductSkuSetSolr(STORE_ID, Set.of(productSync.getProductSku()), false,
        MERCHANT_CODE);
  }

  @Test
  public void updateCncActivatedByProductSkuAndSolrL3NullTest() {
    Set<String> productSkuSet = new HashSet<>();
    productSkuSet.add(PRODUCT_SKU);
    productSkuSet.add(PRODUCT_SKU2);
    List<Product> products = new ArrayList<>();
    products.add(null);

    Mockito.when(productRepository.updateCncActivatedByProductSkusMarkForDeleteFalse(STORE_ID,
        productSkuSet, false, USERNAME)).thenReturn(products);
    productServiceImpl.updateCncActivatedByProductSkuAndSolrL3(STORE_ID, productSkuSet, false, USERNAME);
    Mockito.verify(productRepository).updateCncActivatedByProductSkusMarkForDeleteFalse(STORE_ID, productSkuSet, false, USERNAME);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyNewAndOldSalesCategoryTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(OLD_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    assertEquals(2, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2b() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewB2bSalesCategoryCodes(new ArrayList<>(Collections.singleton(CATEGORY_CODE)));
    profileResponse1.getCompany().getSalesChannel().add(Constants.B2B_SELLER_CHANNEL);
    productSync.setSalesCatalogs(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, true));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2bFalse() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewB2bSalesCategoryCodes(new ArrayList<>());
    productSync.setSalesCatalogs(new ArrayList<>());
    profileResponse1.getCompany().getSalesChannel().add(Constants.B2B_SELLER_CHANNEL);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, true));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2bFalseElse() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>(Collections.singleton(CATEGORY_CODE)));
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewB2bSalesCategoryCodes(new ArrayList<>());
    productSync.setSalesCatalogs(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2bSalesFalseElse() {
    SalesCatalog b2bSalesCatalog = new SalesCatalog();
    b2bSalesCatalog.setCatalogCode(ProductServiceImplTest.B2B_SALES_CATALOG_CODE);
    b2bSalesCatalog.setListOfCategories(this.listOfCategories);
    this.ListOfsalesCatalogs.add(b2bSalesCatalog);
    productSync.setSalesCatalogs(new ArrayList<>(this.ListOfsalesCatalogs));
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldB2bSalesCategoryCodes(new ArrayList<>(Collections.singleton(CATEGORY_CODE)));
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2bSalesFalseElseSame() {
    SalesCatalog b2bSalesCatalog = new SalesCatalog();
    b2bSalesCatalog.setCatalogCode(ProductServiceImplTest.B2B_SALES_CATALOG_CODE);
    b2bSalesCatalog.setListOfCategories(this.listOfCategories);
    this.ListOfsalesCatalogs.add(b2bSalesCatalog);
    productSync.setSalesCatalogs(new ArrayList<>(this.ListOfsalesCatalogs));
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldB2bSalesCategoryCodes(new ArrayList<>(Collections.singleton(OLD_CAT_1)));
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2bMerchantSalesFalseElseSame() {
    SalesCatalog b2bSalesCatalog = new SalesCatalog();
    b2bSalesCatalog.setCatalogCode(ProductServiceImplTest.B2B_SALES_CATALOG_CODE);
    b2bSalesCatalog.setListOfCategories(this.listOfCategories);
    this.ListOfsalesCatalogs.add(b2bSalesCatalog);
    productSync.setSalesCatalogs(new ArrayList<>(this.ListOfsalesCatalogs));
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldB2bSalesCategoryCodes(new ArrayList<>(Collections.singleton(OLD_CAT_1)));
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    profileResponse1.getCompany().getSalesChannel().add(Constants.B2B_SELLER_CHANNEL);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, true));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2bMerchantSalesFalseElseSameCategoryEmpty(){
    productSalesCategoryMapping.setOldB2bSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.getOldB2bSalesCategoryCodes().add(CATEGORY_CODE_UPDATED);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).setCatalogCode(B2B_SALES_CATALOG_CODE);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertEquals(0, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().size());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyb2bSalesFalseElseOld() {
    SalesCatalog b2bSalesCatalog = new SalesCatalog();
    b2bSalesCatalog.setCatalogCode(ProductServiceImplTest.B2B_SALES_CATALOG_CODE);
    b2bSalesCatalog.setListOfCategories(this.listOfCategories);
    this.ListOfsalesCatalogs.add(b2bSalesCatalog);
    productSync.setSalesCatalogs(new ArrayList<>(this.ListOfsalesCatalogs));
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldB2bSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyProductSalesCategoryTest() {
    productSync.setSalesCatalogs(null);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    assertEquals(2, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeRemoveAllExistingSalesCategoryTest() {
    productSalesCategoryMapping.getOldSalesCategoryCodes().add(CATEGORY_CODE_UPDATED);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertEquals(0, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().size());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogOnCategoryChangeEmptyProductAndNewSalesCategoryTest() {
    productSync.setSalesCatalogs(null);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertEquals(productArgumentCaptor.getAllValues().get(0).getSalesCatalogs(), new ArrayList<>());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmMerchantProductSalesCatalogOnCategoryChangeEmptyOldSalesCategoryTest() {
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(OLD_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(3)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(4)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(5)
            .getCategoryCode());
    assertEquals(6, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductSalesCatalogOnCategoryChangeRemoveOldSalesCategoryTest() {
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(3)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(4)
            .getCategoryCode());
    assertEquals(5, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductSalesCatalogOnCategoryChangeEmptyNewSalesCategoryTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    assertEquals(3, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductSalesCatalogOnCategoryChangeEmptyNewAndOldSalesCategoryTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(OLD_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(3)
            .getCategoryCode());
    assertEquals(4, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductSalesCatalogOnCategoryChangeEmptyProductSalesCategoryTest() {
    productSync.setSalesCatalogs(null);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(3)
            .getCategoryCode());
    assertEquals(4, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductSalesCatalogOnCategoryChangeRemoveAllExistingSalesCategoryTest() {
    productSalesCategoryMapping.getOldSalesCategoryCodes().add(CATEGORY_CODE_UPDATED);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    assertEquals(2, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductSalesCatalogOnCategoryChangeEmptyProductAndNewSalesCategoryTest() {
    productSync.setSalesCatalogs(null);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    assertEquals(2, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateNonUmkmMerchantProductSalesCatalogOnCategoryChangeEmptyOldSalesCategoryTest() {
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(OLD_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(3)
            .getCategoryCode());
    assertEquals(4, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateNonUmkmProductSalesCatalogOnCategoryChangeRemoveOldSalesCategoryTest() {
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    assertEquals(3, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateNonUmkmProductSalesCatalogOnCategoryChangeEmptyNewSalesCategoryTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    assertEquals(1, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateNonUmkmProductSalesCatalogOnCategoryChangeEmptyNewAndOldSalesCategoryTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setOldSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(OLD_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    assertEquals(2, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateNonUmkmProductSalesCatalogOnCategoryChangeEmptyProductSalesCategoryTest() {
    productSync.setSalesCatalogs(null);
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(NEW_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    assertEquals(2, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateNonUmkmProductSalesCatalogOnCategoryChangeRemoveAllExistingSalesCategoryTest() {
    productSalesCategoryMapping.getOldSalesCategoryCodes().add(CATEGORY_CODE_UPDATED);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertEquals(0, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().size());
    assertNotNull(result);
  }

  @Test
  public void updateNonUmkmProductSalesCatalogOnCategoryChangeEmptyProductAndNewSalesCategoryTest() {
    productSync.setSalesCatalogs(null);
    productSalesCategoryMapping.setNewUmkmSalesCategoryCodes(new ArrayList<>());
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping, new ArrayList<>(), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(),anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    assertEquals(productArgumentCaptor.getAllValues().get(0).getSalesCatalogs(), new ArrayList<>());
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogByProductCodeWithReplaceFalseTest() throws Exception {
    this.salesCatalogs.add(this.salesCatalog);
    productUnsync.setSalesCatalogs(this.salesCatalogs);
    productUnsync.setProductSku("sku");
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(products);

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, "sku"))
        .thenReturn(listOfItems);

    Boolean result =
        this.productServiceImpl.updateProductSalesCatalogByProductCode(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.salesCatalog, false);

    verify(this.productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    this.productUnsync.setMasterCatalog(this.masterCatalogTobeUpdated);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, "sku");
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(productUnsync, listOfItems);
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogByProductSkuTest() throws Exception {
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false))
        .thenReturn(this.productUnsync);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(listOfItems);

    Boolean result = this.productServiceImpl.updateProductSalesCatalogByProductSku(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED,
        this.salesCatalog, true);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false);
    this.productUnsync.setMasterCatalog(this.masterCatalogTobeUpdated);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(productUnsync, listOfItems);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    assertNotNull(result);
  }

  @Test
  public void updateProductSalesCatalogByProductSkuWithReplaceFalseTest() throws Exception {
    this.salesCatalogs.add(this.salesCatalog);
    productUnsync.setSalesCatalogs(this.salesCatalogs);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false))
        .thenReturn(this.productUnsync);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(listOfItems);

    Boolean result = this.productServiceImpl.updateProductSalesCatalogByProductSku(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED,
        this.salesCatalog, false);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false);
    this.productUnsync.setMasterCatalog(this.masterCatalogTobeUpdated);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(productUnsync, listOfItems);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    assertNotNull(result);
  }

  @Test
  public void updateProductMasterCatalogTest() throws Exception {
    this.productUnsync.setMasterCatalog(this.masterCatalog);
    this.productUnsync.getMasterDataProduct().setMasterCatalog(this.masterCatalog);
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(products);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productUnsync.getProductSku()))
        .thenReturn(listOfItems);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(productUnsync);
    Boolean result =
        this.productServiceImpl.updateProductMasterCatalog(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterCatalogTobeUpdated);
    verify(this.productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    this.productUnsync.setMasterCatalog(this.masterCatalogTobeUpdated);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(this.productAndItemSolrIndexerService).updateSolrOnMasterCatalogChanges(this.productUnsync, listOfItems);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productUnsync.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    assertNotNull(result);
  }

  @Test
  public void updateProductMasterCatalogWithSameCategoryCodeTest() throws Exception {
    this.productUnsync.setMasterCatalog(this.masterCatalog);
    this.productUnsync.getMasterDataProduct().setMasterCatalog(this.masterCatalog);
    List<Product> products = new ArrayList<>();
    products.add(this.productUnsync);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(productUnsync);
    when(this.productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(products);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productUnsync.getProductSku()))
        .thenReturn(listOfItems);
    Boolean result =
        this.productServiceImpl.updateProductMasterCatalog(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, this.masterCatalog);
    verify(this.productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(this.productAndItemSolrIndexerService).updateSolrOnMasterCatalogChanges(productUnsync, listOfItems);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productUnsync.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    assertNotNull(result);
  }

  @Test
  public void updateProductMasterCatalogByProductSkuByProductSkuTest() throws Exception {
    this.productUnsync.setMasterCatalog(this.masterCatalog);
    this.productUnsync.getMasterDataProduct().setMasterCatalog(this.masterCatalog);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false))
        .thenReturn(this.productUnsync);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(listOfItems);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(productUnsync);
    Boolean result = this.productServiceImpl.updateProductMasterCatalogByProductSku(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED,
        this.masterCatalogTobeUpdated);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false);
    this.productUnsync.setMasterCatalog(this.masterCatalogTobeUpdated);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(this.productAndItemSolrIndexerService).updateSolrOnMasterCatalogChanges(productUnsync, listOfItems);

    assertNotNull(result);
  }

  @Test
  public void updateProductMasterCatalogByProductSkuWithSameCategoryCodeTest() throws Exception {
    this.productUnsync.setMasterCatalog(this.masterCatalog);
    this.productUnsync.getMasterDataProduct().setMasterCatalog(this.masterCatalog);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false))
        .thenReturn(this.productUnsync);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(productUnsync);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED))
        .thenReturn(listOfItems);
    Boolean result = this.productServiceImpl.updateProductMasterCatalogByProductSku(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED,
        this.masterCatalog);

    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, false);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.productUnsync, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(this.productAndItemSolrIndexerService).updateSolrOnMasterCatalogChanges(productUnsync, listOfItems);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveAndPublishService).publishListOfItems(listOfItems);
    assertNotNull(result);
  }

  @Test
  public void updateProductSyncTest() throws Exception {
    Mockito.when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false)).thenReturn(productSyncTobeUpdated);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUpdated, false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(this.productSyncTobeUpdated);
    Assertions.assertNotNull(product);
  }

  @Test
  public void updateProductSyncFreeSampleTest() throws Exception {
    productUpdated.setFreeSample(true);
    productUpdated.setOff2OnChannelActive(true);
    Mockito
        .when(itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED))
        .thenReturn(Collections.singletonList(item));
    Mockito.when(itemPickupPointService.findByItemSkuAndDelivery(Constants.DEFAULT_STORE_ID, item.getItemSku()))
        .thenReturn(itemPickupPoint);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class)))
        .thenReturn(productAndItemsVO);
    Mockito.when(this.productRepository
            .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, this.productSyncTobeUpdated.getProductSku(), false))
        .thenReturn(productSyncTobeUpdated);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUpdated, false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false);
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, true,SYSTEM, new ArrayList<>(),
            REQUEST_ID);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(saveOperationService).saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class));
    Assertions.assertNotNull(product);
  }

  @Test
  public void updateProductSyncFreeSampleNoChangeTest() throws Exception {
    productUpdated.setFreeSample(false);
    productUpdated.setOff2OnChannelActive(false);
    productSyncTobeUpdated.setFreeSample(true);
    productSyncTobeUpdated.setOff2OnChannelActive(true);
    Mockito.when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false)).thenReturn(productSyncTobeUpdated);
    Mockito.when(
            itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED))
        .thenReturn(Collections.singletonList(item));
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class)))
        .thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUpdated, false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(saveOperationService).changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
        "x-product", new ArrayList<>(), REQUEST_ID);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class));
    Assertions.assertNotNull(product);
  }

  @Test
  public void updateProductSyncTest_WithNoChanges() throws Exception {
    Mockito.when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false)).thenReturn(productSyncTobeUpdated);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productSyncTobeUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Assertions.assertNotNull(product);
  }

  @Test
  public void updateProductSyncTestWithBlankStoreId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.updateProduct(null, ProductServiceImplTest.REQUEST_ID, this.productUpdated, false));
  }

  @Test
  public void updateProductSyncTestWithNullProduct() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, null, false));
  }

  @Test
  public void updateProductTestWithProductNotFound() {
    try {
      this.productServiceImpl.updateProduct(ProductServiceImplTest.STORE_ID_NOT_FOUND, ProductServiceImplTest.REQUEST_ID,
          this.productUpdated, false);

    } catch (Exception e) {
      verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
          ProductServiceImplTest.STORE_ID_NOT_FOUND,
          ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false);
      assertTrue(e instanceof Exception);
    }
  }

  @Test
  public void updateProductUnSyncTest() {
    productUnsyncUpdated.setPreOrder(preOrder);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductSyncWithPreOrderChangeTest() throws Exception {
    productUpdated.setPreOrder(preOrder);
    productSyncTobeUpdated.setProductSpecialAttributes(new ArrayList<>());
    productSyncTobeUpdated.setSettlementType(SETTLEMENT_TYPE_UPDATED);
    productUpdated.setProductSpecialAttributes(new ArrayList<>());
    Mockito.when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false)).thenReturn(productSyncTobeUpdated);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUpdated, false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(this.productSyncTobeUpdated);
    Assertions.assertNotNull(product);
    Assertions.assertTrue(product.getPreOrder().getIsPreOrder());
    Assertions.assertEquals(PREORDER_TYPE, product.getPreOrder().getPreOrderType());
    Assertions.assertEquals(PREORDER_VALUE, product.getPreOrder().getPreOrderValue());
  }

  @Test
  public void updateProductUnSyncWithPreOrderChangeTest() {
    productUnsyncUpdated.setPreOrder(preOrder);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest() {
    masterDataAttributeUpdated.setAttributeCode(ATTRIBUTE_CODE);
    masterDataProductAttributeValueExisting.setPredefinedAllowedAttributeValue(masterDataPredefinedAttributeValueExisting);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);
    masterDataProductAttributeUpdated.setMasterDataProductAttributeValues(
        Collections.singletonList(masterDataProductAttributeValueExisting));
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0).getMasterDataProductAttributeValues()
        .get(0).setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0).getMasterDataProductAttributeValues()
        .get(0).setPredefinedAllowedAttributeValue(masterDataPredefinedAttributeValueUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.productHelperService).generateSpecificationDetail(productUnSyncTobeUpdated);
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    Assertions.assertEquals(Collections.singletonList(masterDataProductAttributeUpdated),
        product.getMasterDataProduct().getMasterDataProductAttributes());
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest_new() {
    masterDataAttributeExisting.setAttributeCode(ATTRIBUTE_CODE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValue("12345");
    masterDataAttributeExisting.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);

    masterDataProductAttributeValuesExisting.add(masterDataProductAttributeValueExisting);
    masterDataProductAttributeExisting.setMasterDataProductAttributeValues(masterDataProductAttributeValuesExisting);
    masterDataProductAttributeExisting.setMasterDataAttribute(masterDataAttributeExisting);
    masterDataProductExisting
        .setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeExisting));
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);
    masterDataProductAttributeUpdated
        .setMasterDataProductAttributeValues(Collections.singletonList(masterDataProductAttributeValueExisting));
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.setActivated(true);
    masterDataProduct.setUom("");
    masterDataProduct.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    this.productUnsync.setMasterDataProduct(masterDataProductExisting);
    this.productUnsync.setProductType(this.productUnsyncUpdated.getProductType());
    this.productUnsync.setProductSku(PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    this.productUnsync.getMasterDataProduct().setProductName(OLD_PRODUCT_NAME);
    this.productUnsync.setProductCode(PRODUCT_CODE);
    this.productUnsync.setStoreId(STORE_ID);
    this.productUnsync.getMasterDataProduct().setWeight(10.0);
    this.productUnsync.getMasterDataProduct().setLength(10.0);
    this.productUnsync.getMasterDataProduct().setWidth(10.0);
    this.productUnsync.getMasterDataProduct().setHeight(10.0);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(anyString(), anyString(), eq(false)))
        .thenReturn(this.productUnsync);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0)
        .getMasterDataProductAttributeValues().get(0)
        .setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0)
        .getMasterDataProductAttributeValues().get(0)
        .setPredefinedAllowedAttributeValue(masterDataPredefinedAttributeValueUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class)))
        .thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList, ProductServiceImplTest.OLD_PRODUCT_NAME,
        ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingItemChange(any());
    verify(this.productHelperService).generateSpecificationDetail(any());
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest_2New() {
    this.productUnsyncUpdated.getMasterDataProduct()
        .setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));

    masterDataAttributeExisting.setAttributeCode(ATTRIBUTE_CODE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValue("12345");
    masterDataAttributeExisting.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);

    masterDataProductAttributeValuesExisting.add(masterDataProductAttributeValueExisting);
    masterDataProductAttributeExisting.setMasterDataProductAttributeValues(masterDataProductAttributeValuesExisting);
    masterDataProductAttributeExisting.setMasterDataAttribute(masterDataAttributeExisting);
    masterDataProductExisting.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeExisting));
    this.productUnsync.setMasterDataProduct(masterDataProductExisting);
    this.productUnsync.setProductType(this.productUnsyncUpdated.getProductType());
    this.productUnsync.setProductSku(PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    this.productUnsync.getMasterDataProduct().setProductName(OLD_PRODUCT_NAME);
    this.productUnsync.setProductCode(PRODUCT_CODE);
    this.productUnsync.setStoreId(STORE_ID);
    this.productUnsync.getMasterDataProduct().setWeight(10.0);
    this.productUnsync.getMasterDataProduct().setLength(10.0);
    this.productUnsync.getMasterDataProduct().setWidth(10.0);
    this.productUnsync.getMasterDataProduct().setHeight(10.0);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(anyString(), anyString(), eq(false)))
        .thenReturn(this.productUnsync);
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.setActivated(true);
    masterDataProduct.setUom("");
    masterDataProduct.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService)
        .findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(any());
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    Assertions.assertEquals(Collections.singletonList(masterDataProductAttributeUpdated),
        product.getMasterDataProduct().getMasterDataProductAttributes());
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest_2() {
    this.productUnsyncUpdated.getMasterDataProduct()
        .setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));

    masterDataAttributeExisting.setAttributeCode(ATTRIBUTE_CODE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValue("12345");
    masterDataAttributeExisting.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);

    masterDataProductAttributeValuesExisting.add(masterDataProductAttributeValueExisting);
    masterDataProductAttributeExisting.setMasterDataProductAttributeValues(masterDataProductAttributeValuesExisting);
    masterDataProductAttributeExisting.setMasterDataAttribute(masterDataAttributeExisting);
    masterDataProductExisting.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeExisting));
    this.productUnsync.setMasterDataProduct(masterDataProductExisting);
    this.productUnsync.setProductType(this.productUnsyncUpdated.getProductType());
    this.productUnsync.setProductSku(PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    this.productUnsync.getMasterDataProduct().setProductName(OLD_PRODUCT_NAME);
    this.productUnsync.setProductCode(PRODUCT_CODE);
    this.productUnsync.setStoreId(STORE_ID);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(anyString(), anyString(), eq(false)))
        .thenReturn(this.productUnsync);
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService)
        .findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(any());
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    Assertions.assertEquals(Collections.singletonList(masterDataProductAttributeUpdated),
        product.getMasterDataProduct().getMasterDataProductAttributes());
  }

  @Test
  public void updateProductUnSyncTestWithoutUpdateProductName() {
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(this.productUnsyncUpdated);
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    assertEquals(ProductServiceImplTest.OLD_PRODUCT_NAME,
        this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  private Product getUnSyncProductForPreOrder() {
    this.productUnsyncUpdated.getMasterDataProduct()
        .setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));

    masterDataAttributeExisting.setAttributeCode(ATTRIBUTE_CODE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValue("12345");
    masterDataAttributeExisting.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);

    masterDataProductAttributeValuesExisting.add(masterDataProductAttributeValueExisting);
    masterDataProductAttributeExisting.setMasterDataProductAttributeValues(masterDataProductAttributeValuesExisting);
    masterDataProductAttributeExisting.setMasterDataAttribute(masterDataAttributeExisting);
    masterDataProductExisting.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeExisting));
    this.productUnsync.setMasterDataProduct(masterDataProductExisting);
    this.productUnsync.setProductType(this.productUnsyncUpdated.getProductType());
    this.productUnsync.setProductSku(PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    this.productUnsync.getMasterDataProduct().setProductName(OLD_PRODUCT_NAME);
    this.productUnsync.setProductCode(PRODUCT_CODE);
    this.productUnsync.setStoreId(STORE_ID);
    this.productUnsync.setPreOrder(preOrder);
    return productUnsync;
  }

  @Test
  public void updateProductUnSyncTestWithPreOrderNull() {
    Product productUnsync = getUnSyncProductForPreOrder();
    productUnsync.setPreOrder(preOrder);
    productUnsync.setProductScore(null);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(productUnsync);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    assertNotNull(product);
    assertEquals(OLD_PRODUCT_NAME, this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  @Test
  public void updateProductUnSyncTestWithPreOrderFlagChange() {
    Product productUnsync = getUnSyncProductForPreOrder();
    productUnsyncUpdated.setPreOrder(preOrder);
    PreOrder preOrder1 = new PreOrder();
    preOrder1.setIsPreOrder(false);
    productUnsyncUpdated.setPreOrder(preOrder1);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(productUnsync);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    assertNotNull(product);
    assertEquals(OLD_PRODUCT_NAME, this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  @Test
  public void updateProductUnSyncTestWithPreOrderFlagFalseInRequest() {
    Product productUnsync = getUnSyncProductForPreOrder();
    productUnsync.getPreOrder().setIsPreOrder(false);
    PreOrder preOrder1 = new PreOrder();
    preOrder1.setIsPreOrder(true);
    preOrder1.setPreOrderType(PREORDER_TYPE);
    preOrder1.setPreOrderValue(PREORDER_VALUE);
    productUnsyncUpdated.setPreOrder(preOrder1);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(productUnsync);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    assertNotNull(product);
    assertEquals(ProductServiceImplTest.OLD_PRODUCT_NAME,
        this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  @Test
  public void updateProductUnSyncTestWithPreOrderTypeWeek() {
    Product productUnsync = getUnSyncProductForPreOrder();
    PreOrder preOrder1 = new PreOrder();
    preOrder1.setIsPreOrder(true);
    preOrder1.setPreOrderType(PREORDER_WEEK_TYPE);
    preOrder1.setPreOrderValue(PREORDER_VALUE);
    productUnsyncUpdated.setPreOrder(preOrder1);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(productUnsync);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    assertNotNull(product);
    assertEquals(ProductServiceImplTest.OLD_PRODUCT_NAME,
        this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  @Test
  public void updateProductUnSyncTestWithWrongPreOrderType() {
    Product productUnsync = getUnSyncProductForPreOrder();
    productUnsync.getPreOrder().setPreOrderDate(null);
    productUnsync.getPreOrder().setPreOrderType(PRODUCT_CODE);
    PreOrder preOrder1 = new PreOrder();
    preOrder1.setIsPreOrder(true);
    preOrder1.setPreOrderType(PRODUCT_CODE);
    preOrder1.setPreOrderValue(PREORDER_VALUE);
    productUnsyncUpdated.setPreOrder(preOrder1);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(productUnsync);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    assertNotNull(product);
    assertEquals(ProductServiceImplTest.OLD_PRODUCT_NAME,
        this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  @Test
  public void updateProductUnSyncTestWithPreOrderValueChange() {
    Product productUnsync = getUnSyncProductForPreOrder();
    PreOrder preOrder1 = new PreOrder();
    preOrder1.setIsPreOrder(true);
    preOrder1.setPreOrderType(PREORDER_TYPE);
    preOrder1.setPreOrderValue(15);
    productUnsyncUpdated.setPreOrder(preOrder1);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(productUnsync);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    assertNotNull(product);
    assertEquals(ProductServiceImplTest.OLD_PRODUCT_NAME,
        this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  @Test
  public void updateProductUnSyncTestWithPreOrderDateChange() {
    Product productUnsync = getUnSyncProductForPreOrder();
    Date currentDate = new Date();
    Calendar cal = Calendar.getInstance();
    cal.setTime(currentDate);
    cal.add(Calendar.DATE, 10);
    PreOrder preOrder1 = new PreOrder();
    preOrder1.setIsPreOrder(true);
    preOrder1.setPreOrderType(PREORDER_TYPE);
    preOrder1.setPreOrderValue(PREORDER_VALUE);
    preOrder1.setPreOrderDate(cal.getTime());
    productUnsyncUpdated.setPreOrder(preOrder1);
    productUnsyncUpdated.setSynchronized(false);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productAndItemsVO.getProduct());
    this.masterDataProductUpdated.setProductName(ProductServiceImplTest.OLD_PRODUCT_NAME);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false))
        .thenReturn(productUnsync);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    assertNotNull(product);
    assertEquals(ProductServiceImplTest.OLD_PRODUCT_NAME,
        this.productUnsyncUpdated.getMasterDataProduct().getProductName());
  }

  @Test
  public void updateProductUnSyncTest_WithNoChanges() {
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            this.productUnSyncTobeUpdated, false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  private static Product initializeProduct(String productSku){
    Product product = new Product();
    product.setProductSku(productSku);
    return product;
  }

  @Test
  public void publishAllProductsTest() throws Exception {
    when(productRepository.streamAllByStoreId(STORE_ID))
        .thenReturn(PRODUCT_STREAM);

    productServiceImpl.publishAllProducts(STORE_ID);

    verify(productRepository, times(1))
        .streamAllByStoreId(STORE_ID);
    verify(saveAndPublishService,times(1))
        .publishStreamOfProducts(PRODUCT_STREAM);
  }

  @Test
  public void publishAllProductsTestThrowException() throws Exception {
    doThrow(new ApplicationRuntimeException()).when(productRepository).streamAllByStoreId(BLANK);

    productServiceImpl.publishAllProducts(BLANK);

    verify(productRepository,times(1))
        .streamAllByStoreId(BLANK);
  }

  @Test
  public void republishProductsToAgpTest() throws Exception {
    when(productRepository.streamAllByStoreIdAndProductSkuIn(STORE_ID, PRODUCT_SKUS))
        .thenReturn(PRODUCT_STREAM);

    productServiceImpl.republishProductsToAgp(STORE_ID, PRODUCT_SKUS);

    verify(productRepository, times(1))
        .streamAllByStoreIdAndProductSkuIn(STORE_ID, PRODUCT_SKUS);
    verify(saveAndPublishService,times(1))
        .publishStreamOfProducts(PRODUCT_STREAM);
  }

  @Test
  public void republishProductsToAgpTestThrowException() throws Exception {
    doThrow(new ApplicationRuntimeException()).when(productRepository).streamAllByStoreIdAndProductSkuIn(BLANK,Collections.emptyList());

    productServiceImpl.republishProductsToAgp(BLANK,Collections.emptyList());

    verify(productRepository,times(1))
        .streamAllByStoreIdAndProductSkuIn(BLANK,Collections.emptyList());
  }

  @Test
  public void updateSalesCatalogAddTest() throws Exception {
    ReflectionTestUtils.setField(this.productServiceImpl, "ranchIntegrationEnabled", true);
    String oldCategoryCode = "old-category";
    String newCategoryCode = "new-category";
    String sku = "sku";
    List<String> skus = new ArrayList<>();
    skus.add(sku);

    List<Product> products = new ArrayList<>();
    Product product = new Product();
    product.setTradingProduct(true);
    product.setProductSku(sku);
    product.setB2cActivated(true);
    product.setB2bActivated(true);
    product.setDefiningAttributes(Arrays.asList(new ProductAttribute(), new ProductAttribute()));
    products.add(product);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category(oldCategoryCode, oldCategoryCode));
    product.setSalesCatalogs(new ArrayList<SalesCatalog>());
    product.getAllSalesCatalogs().add(salesCatalog2);

    List<SalesCatalog> salesCatalogList = new ArrayList<>();
    SalesCatalog salesCatalog3 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog3.getListOfCategories().add(new Category(oldCategoryCode, oldCategoryCode));
    salesCatalog3.getListOfCategories().add(new Category(newCategoryCode, newCategoryCode));
    salesCatalogList.add(salesCatalog3);

    when(this.productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus))
        .thenReturn(products);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, sku))
        .thenReturn(listOfItems);

    product.setDistributionStatus(null);
    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode))
        .thenReturn(new CategoryDetailResponse());
    when(this.productRepository.updateSalesCatalog(eq(STORE_ID), eq(sku), eq(salesCatalogList), any(Date.class))).thenReturn(product);

    this.productServiceImpl.updateProductSalesCategory(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, skus,
        ProductServiceImplTest.CATALOG_CODE, null, newCategoryCode);

    assertThat(salesCatalog2.getListOfCategories().size(), equalTo(2));
    verify(this.productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus);
    verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, sku);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productRepository).updateSalesCatalog(eq(STORE_ID), eq(sku), eq(salesCatalogList), any(Date.class));
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(skus.get(0)), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            any(), any());
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChangesForProductList(products, listOfItems);
    Mockito.verify(this.kafkaProducer)
        .send(eq(ProductDomainEventName.PRODUCT_CHANGE_EVENT_NAME), anyString(),
            productChangeArgumentCaptor.capture());
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
    assertTrue(productChangeArgumentCaptor.getValue().isMultiVariant());
    assertTrue(productChangeArgumentCaptor.getValue().isTradingProduct());
  }


  @Test
  public void updateSalesCatalogSkusTest() {
    List<String> skus = new ArrayList<>();
    skus.add(SKU);
    skus.add(SKU_2);
    List<Product> products = new ArrayList<>();
    Product product = new Product();
    product.setProductSku(SKU);
    product.setB2cActivated(false);
    Product product2 = new Product();
    product2.setProductSku(SKU_2);
    product2.setB2cActivated(false);
    products.add(product);
    products.add(product2);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category(OLD_CATEGORY, OLD_CATEGORY));
    product.setSalesCatalogs(new ArrayList<>());
    product.getAllSalesCatalogs().add(salesCatalog2);
    product2.setSalesCatalogs(new ArrayList<>());
    product2.getAllSalesCatalogs().add(salesCatalog2);

    List<SalesCatalog> salesCatalogList = new ArrayList<>();
    SalesCatalog salesCatalog3 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog3.getListOfCategories().add(new Category(OLD_CATEGORY, OLD_CATEGORY));
    salesCatalog3.getListOfCategories().add(new Category(NEW_CATEGORY, NEW_CATEGORY));
    salesCatalogList.add(salesCatalog3);

    when(this.productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus))
        .thenReturn(products);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, SKU)).thenReturn(listOfItems);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, SKU_2)).thenReturn(listOfItems);

    when(this.productCategoryBaseClient
        .getCategoryDetailByCategoryCode(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            NEW_CATEGORY)).thenReturn(new CategoryDetailResponse());
    when(this.productRepository.updateSalesCatalog(eq(STORE_ID), eq(SKU), eq(salesCatalogList), any(Date.class)))
        .thenReturn(product);
    when(this.productRepository.updateSalesCatalog(eq(STORE_ID), eq(SKU_2), eq(salesCatalogList), any(Date.class)))
        .thenReturn(product2);
    doNothing().when(this.productCenterHistoryService)
        .saveProductCenterHistory(skus.get(0), ProductCenterActivity.DELETE, REQUEST_ID, StringUtils.EMPTY,
            StringUtils.EMPTY);
    this.productServiceImpl
        .updateProductSalesCategory(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, skus, ProductServiceImplTest.CATALOG_CODE, null, NEW_CATEGORY);

    assertThat(salesCatalog2.getListOfCategories().size(), equalTo(2));
    verify(this.productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus);
    verify(this.productCategoryBaseClient)
        .getCategoryDetailByCategoryCode(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            NEW_CATEGORY);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, SKU);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, SKU_2);
    verify(saveAndPublishService, times(2)).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService, times(2)).evictProductData(anyString(), any(Product.class));
    verify(this.productRepository).updateSalesCatalog(eq(STORE_ID), eq(SKU), eq(salesCatalogList), any(Date.class));
    verify(this.productRepository).updateSalesCatalog(eq(STORE_ID), eq(SKU_2), eq(salesCatalogList), any(Date.class));
    verify(this.productCenterHistoryService, times(2))
        .saveProductCenterHistory(any(), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            any(), any());
    Mockito.verify(gdnMapperMock, times(2)).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
    List<Item> itemList = new ArrayList<>();
    itemList.addAll(listOfItems);
    itemList.addAll(listOfItems);
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChangesForProductList(products, itemList);
  }

  @Test
  public void updateSalesCatalogAddWithCategoryNotFoundInPCBTest() throws Exception {
    String oldCategoryCode = "old-category";
    String newCategoryCode = "new-category";
    String sku = "sku";
    List<String> skus = new ArrayList<>();
    skus.add(sku);

    List<Product> products = new ArrayList<>();
    Product product = new Product();
    product.setProductSku(sku);
    products.add(product);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category(oldCategoryCode, oldCategoryCode));
    product.setSalesCatalogs(new ArrayList<SalesCatalog>());
    product.getAllSalesCatalogs().add(salesCatalog2);

    when(this.productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus))
        .thenReturn(products);
    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode))
        .thenReturn(null);
    try {
      this.productServiceImpl.updateProductSalesCategory(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, skus,
          ProductServiceImplTest.CATALOG_CODE, null, newCategoryCode);
    } catch (Exception e) {
      assertThat(salesCatalog2.getListOfCategories().size(), equalTo(1));
      verify(this.productRepository)
          .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus);
      verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode);
    }
  }

  @Test
  public void updateSalesCatalogAddWithNewCategoryCodeNull() throws Exception {
    String oldCategoryCode = "old-category";
    String sku = "sku";
    List<String> skus = new ArrayList<>();
    skus.add(sku);

    List<Product> products = new ArrayList<>();
    Product product = new Product();
    product.setProductSku(sku);
    products.add(product);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category(oldCategoryCode, oldCategoryCode));
    product.setSalesCatalogs(new ArrayList<>());
    product.getAllSalesCatalogs().add(salesCatalog2);

    when(this.productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus))
        .thenReturn(products);
    when(this.productCategoryBaseClient
        .getCategoryDetailByCategoryCode(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, null))
        .thenReturn(null);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl
          .updateProductSalesCategory(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
              ProductServiceImplTest.USERNAME, skus, ProductServiceImplTest.CATALOG_CODE, null, null));
    } finally {
      assertThat(salesCatalog2.getListOfCategories().size(), equalTo(1));
      verify(this.productRepository)
          .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus);
    }
  }

  @Test
  public void updateSalesCatalogDeleteTest() throws Exception {
    String oldCategoryCode = "old-category";
    String sku = "sku";
    List<String> skus = new ArrayList<>();
    skus.add(sku);

    List<Product> products = new ArrayList<>();
    Product product = new Product();
    products.add(product);
    product.setProductSku(sku);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category(oldCategoryCode, oldCategoryCode));
    product.setSalesCatalogs(new ArrayList<SalesCatalog>());
    product.getAllSalesCatalogs().add(salesCatalog2);

    MASTER_DATA_PRODUCT.setBrand(BRAND);
    MASTER_DATA_PRODUCT.setBrandLogoUrl(BRAND_LOGO_URL);
    product.setMasterDataProduct(MASTER_DATA_PRODUCT);
    products.get(0).setB2cActivated(true);

    when(this.productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus))
        .thenReturn(products);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, sku))
        .thenReturn(listOfItems);

    when(this.productRepository
        .updateSalesCatalog(eq(ProductServiceImplTest.STORE_ID), eq(sku), eq(salesCatalogs), any(Date.class)))
        .thenReturn(product);
    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(REQUEST_ID, USERNAME, oldCategoryCode))
        .thenReturn(new CategoryDetailResponse());
    doNothing().when(this.productCenterHistoryService)
        .saveProductCenterHistory(skus.get(0), ProductCenterActivity.DELETE, REQUEST_ID,
            StringUtils.EMPTY, StringUtils.EMPTY);
    this.productServiceImpl.updateProductSalesCategory(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, skus,
        ProductServiceImplTest.CATALOG_CODE, oldCategoryCode, null);
    assertThat(salesCatalog2.getListOfCategories().size(), equalTo(0));
    verify(this.productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus);
    verify(this.productRepository).updateSalesCatalog(eq(ProductServiceImplTest.STORE_ID), eq(sku), eq(salesCatalogs), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, sku);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(REQUEST_ID, USERNAME, oldCategoryCode);
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(skus.get(0)), eq(ProductCenterActivity.DELETE), eq(REQUEST_ID),
            any(), any());
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChangesForProductList(products, listOfItems);
  }

  @Test
  public void updateSalesCatalogMoveTest() throws Exception {
    String newCategoryCode = "new-category";
    String oldCategoryCode = "old-category";
    String sku = "sku";
    List<String> skus = new ArrayList<>();
    skus.add(sku);

    List<Product> products = new ArrayList<>();
    Product product = new Product();
    product.setProductSku(sku);
    products.add(product);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category(oldCategoryCode, oldCategoryCode));
    product.setSalesCatalogs(new ArrayList<SalesCatalog>());
    product.getAllSalesCatalogs().add(salesCatalog2);

    List<ProductAndItemSolr> solrResult = new ArrayList<>();

    List<SalesCatalog> salesCatalogList = new ArrayList<>();
    SalesCatalog salesCatalog3 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog3.getListOfCategories().add(new Category(newCategoryCode, newCategoryCode));
    salesCatalogList.add(salesCatalog3);

    when(this.productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus))
        .thenReturn(products);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, sku))
        .thenReturn(listOfItems);

    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode))
        .thenReturn(new CategoryDetailResponse());
    when(this.solrRepository
        .findByStoreIdAndProductCodeAndMerchantCodeAndMarkForDeleteFalseAndIsSynchronizedTrue(
            ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE,
            ProductServiceImplTest.MERCHANT_CODE)).thenReturn(solrResult);
    when(this.productRepository.updateSalesCatalog(eq(STORE_ID), eq(sku), eq(salesCatalogList), any(Date.class))).thenReturn(product);
    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(REQUEST_ID, USERNAME, oldCategoryCode))
        .thenReturn(new CategoryDetailResponse());
    doNothing().when(this.productCenterHistoryService)
        .saveProductCenterHistory(skus.get(0), ProductCenterActivity.MOVE, REQUEST_ID,
            StringUtils.EMPTY, StringUtils.EMPTY);
    this.productServiceImpl.updateProductSalesCategory(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, skus,
        ProductServiceImplTest.CATALOG_CODE, oldCategoryCode, newCategoryCode);

    assertThat(salesCatalog2.getListOfCategories().get(0).getCategoryCode(),
        equalTo(newCategoryCode));
    verify(this.productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, sku);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productRepository).updateSalesCatalog(eq(STORE_ID), eq(sku), eq(salesCatalogList), any(Date.class));
    verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(REQUEST_ID, USERNAME, oldCategoryCode);
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(skus.get(0)), eq(ProductCenterActivity.MOVE), eq(REQUEST_ID),
            any(), any());
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChangesForProductList(products, listOfItems);
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCatalogMoveWithCategoryNotFoundInPCBTest() throws Exception {
    String newCategoryCode = "new-category";
    String oldCategoryCode = "old-category";
    String sku = "sku";
    List<String> skus = new ArrayList<>();
    skus.add(sku);

    List<Product> products = new ArrayList<>();
    Product product = new Product();
    product.setProductSku(sku);
    products.add(product);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category(oldCategoryCode, oldCategoryCode));
    product.setSalesCatalogs(new ArrayList<SalesCatalog>());
    product.getAllSalesCatalogs().add(salesCatalog2);

    List<ProductAndItemSolr> solrResult = new ArrayList<>();
    when(this.productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus))
        .thenReturn(products);
    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode))
        .thenReturn(null);
    when(this.solrRepository
        .findByStoreIdAndProductCodeAndMerchantCodeAndMarkForDeleteFalseAndIsSynchronizedTrue(
            ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE,
            ProductServiceImplTest.MERCHANT_CODE)).thenReturn(solrResult);
    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(REQUEST_ID, USERNAME, oldCategoryCode))
        .thenReturn(new CategoryDetailResponse());
    try {
      this.productServiceImpl.updateProductSalesCategory(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, skus,
          ProductServiceImplTest.CATALOG_CODE, oldCategoryCode, newCategoryCode);
    } catch (Exception e) {
      assertThat(salesCatalog2.getListOfCategories().get(0).getCategoryCode(),
          equalTo(oldCategoryCode));
      verify(this.productRepository)
          .findByStoreIdAndProductSkusAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, skus);
      verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, newCategoryCode);
      verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(REQUEST_ID, USERNAME, oldCategoryCode);
    }
  }

  @Test
  public void getProductsByBrandNameTest() throws Exception {
    when(this.solrRepository
        .findByStoreIdAndBrandAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.BRAND)).thenReturn(1L);
    this.productServiceImpl
        .getProductsCountByBrand(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.BRAND);
    verify(this.solrRepository)
        .findByStoreIdAndBrandAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.BRAND);
  }

  @Test
  public void getProductsByProductCodeTest() throws Exception {
    when(this.productRepository
        .findByStoreIdAndProductCodeAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_CODE)))
        .thenReturn(Arrays.asList(productSync));
    List<Product> products = productServiceImpl.getProductsByProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productRepository)
        .findByStoreIdAndProductCodeAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_CODE));
    Assertions.assertNotNull(products);
    Assertions.assertEquals(productSync, products.get(0));
  }

  @Test
  public void alterSalesCategorySequence_SuccessTest() {
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    List<SalesCategorySequence> salesCategorySequences = new ArrayList<>();
    List<String> pristineIds = new ArrayList<>();
    pristineIds.add(PRISTINE_ID);
    when(this.skuValidator.isProductSku(eq(PRODUCT_SKU))).thenReturn(true);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_SKU), eq(false)))
        .thenReturn(product);
    when(itemService.getPristineIdsByProductSku(eq(STORE_ID), eq(PRODUCT_SKU)))
        .thenReturn(pristineIds);
    this.productServiceImpl
        .alterSalesCategorySequence(STORE_ID, PRODUCT_SKU, salesCategorySequences);
    verify(this.skuValidator).isProductSku(eq(PRODUCT_SKU));
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_SKU), eq(false));
    verify(this.saveOperationService).saveProduct(any(Product.class));
    verify(itemService).updateSalesCatalogForAllPristineProducts(pristineIds);
    verify(itemService).getPristineIdsByProductSku(eq(STORE_ID), eq(PRODUCT_SKU));
  }

  @Test
  public void alterSalesCategorySequenceWithProductNullTest() {
    List<SalesCategorySequence> salesCategorySequences = new ArrayList<>();
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_SKU), eq(false)))
        .thenReturn(null);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl
        .alterSalesCategorySequence(STORE_ID, PRODUCT_SKU, salesCategorySequences));
  }

  @Test
  public void alterSalesCategorySequenceWithPVFalseTest() {
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    List<SalesCategorySequence> salesCategorySequences = new ArrayList<>();
    List<String> pristineIds = new ArrayList<>();
    pristineIds.add(PRISTINE_ID);
    ReflectionTestUtils.setField(productServiceImpl, "isPVSwitchEnabled", false);
    when(this.skuValidator.isProductSku(eq(PRODUCT_SKU))).thenReturn(true);
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_SKU), eq(false)))
        .thenReturn(product);
    when(itemService.getPristineIdsByProductSku(eq(STORE_ID), eq(PRODUCT_SKU)))
        .thenReturn(pristineIds);
    this.productServiceImpl
        .alterSalesCategorySequence(STORE_ID, PRODUCT_SKU, salesCategorySequences);
    verify(this.skuValidator).isProductSku(eq(PRODUCT_SKU));
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_SKU), eq(false));
    verify(this.saveOperationService).saveProduct(any(Product.class));
  }

  private CategoryProductSkuMappingRequest generateMasterCategoryMappingRequest() {
    CategoryProductSkuMappingRequest mappingRequest = new CategoryProductSkuMappingRequest(CATEGORY_CODE,
        PRODUCT_SKU, RECAT_ID, null);
    mappingRequest.setStoreId(STORE_ID);
    mappingRequest.setRequestId(REQUEST_ID);
    mappingRequest.setUsername(USERNAME);
    return mappingRequest;
  }

  private ProductSkuToSalesCatalogMappingRequest generateSalesCategoryMappingRequest() {
    ProductSkuToSalesCatalogMappingRequest mappingRequest = new ProductSkuToSalesCatalogMappingRequest
        (SALES_CATALOG_CODE, CATEGORY_CODE, PRODUCT_SKU, RECAT_ID, null);
    mappingRequest.setStoreId(STORE_ID);
    mappingRequest.setRequestId(REQUEST_ID);
    mappingRequest.setUsername(USERNAME);
    return mappingRequest;
  }

  @Test
  public void processProductSkuToSalesCatalogMappingTest_WhenRequiredParamsMissing() throws Exception {
    ProductSkuToSalesCatalogMappingRequest mappingRequest = new ProductSkuToSalesCatalogMappingRequest();
    try {
      productServiceImpl.processProductSkuToSalesCatalogMapping(mappingRequest);
    } catch (ApplicationRuntimeException ex) {
      Assertions.assertTrue((StringUtils.isBlank(mappingRequest.getProductSku()) ||
          StringUtils.isBlank(mappingRequest.getSalesCatalog()) || StringUtils.isBlank(mappingRequest
          .getSalesCategory())));
    }
  }

  @Test
  public void processProductSkuToSalesCatalogMappingTest_WhenProductNotFound() throws Exception {
    ProductSkuToSalesCatalogMappingRequest mappingRequest = generateSalesCategoryMappingRequest();
    productServiceImpl.processProductSkuToSalesCatalogMapping(mappingRequest);
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(STORE_ID, Arrays.asList(PRODUCT_SKU));
    verify(kafkaProducer).send(eq(ProductDomainEventName.PRODUCT_SKU_TO_SALES_CATALOG_SAVE_EVENT)
        ,eq(PRODUCT_SKU), eq(mappingRequest));
    verify(this.productCategoryBaseClient)
        .getCategoryDetailByCategoryCode(ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            CATEGORY_CODE);
    verify(this.productAndItemSolrIndexerService)
        .updateSolrOnSalesCatalogChangesForProductList(anyList(), anyList());
    Assertions.assertEquals(FAILED_STATUS, mappingRequest.getStatus());
  }

  @Test
  public void processProductSkuToSalesCatalogMappingTest_ok() throws Exception {
    ReflectionTestUtils.setField(this.productServiceImpl, "ranchIntegrationEnabled", true);
    List<Product> products = new ArrayList<>();
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    products.add(product);
    SalesCatalog salesCatalog2 = new SalesCatalog(ProductServiceImplTest.CATALOG_CODE);
    salesCatalog2.getListOfCategories().add(new Category("oldCategory", "oldCategory"));
    product.setSalesCatalogs(new ArrayList<SalesCatalog>());
    product.getAllSalesCatalogs().add(salesCatalog2);

    ProductSkuToSalesCatalogMappingRequest mappingRequest = generateSalesCategoryMappingRequest();
    Mockito.when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(STORE_ID, Arrays.asList
        (PRODUCT_SKU))).thenReturn(products);
    when(this.productCategoryBaseClient.getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, CATEGORY_CODE))
        .thenReturn(new CategoryDetailResponse());
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(listOfItems);
    when(productRepository.updateSalesCatalog(eq(STORE_ID), eq(PRODUCT_SKU), eq(product.getSalesCatalogs()), any(Date.class))).thenReturn(PRODUCT1);
    doNothing().when(this.productCenterHistoryService)
        .saveProductCenterHistory(mappingRequest.getProductSku(), ProductCenterActivity.COPY, REQUEST_ID,
            StringUtils.EMPTY, StringUtils.EMPTY);
    productServiceImpl.processProductSkuToSalesCatalogMapping(mappingRequest);
    Mockito.verify(productRepository).findByStoreIdAndProductSkusAndMarkForDeleteFalse(STORE_ID, Arrays.asList
        (PRODUCT_SKU));
    verify(kafkaProducer).send(eq(ProductDomainEventName.PRODUCT_SKU_TO_SALES_CATALOG_SAVE_EVENT)
        ,eq(PRODUCT_SKU), eq(mappingRequest));
    verify(this.productCategoryBaseClient).getCategoryDetailByCategoryCode(
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME, CATEGORY_CODE);
    verify(this.productRepository).updateSalesCatalog(eq(STORE_ID), eq(PRODUCT_SKU), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productRepository)
        .updateSalesCatalog(eq(STORE_ID), eq(PRODUCT_SKU), eq(product.getSalesCatalogs()), any(Date.class));
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(mappingRequest.getProductSku()), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            any(), any());
    Assertions.assertEquals(COMPLETED_STATUS, mappingRequest.getStatus());
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChangesForProductList(products, listOfItems);
  }

  @Test
  public void processCategoryToProductSkuMappingTest_WhenRequiredParamsMissing() throws Exception {
    CategoryProductSkuMappingRequest mappingRequest = new CategoryProductSkuMappingRequest();
    try {
      productServiceImpl.processCategoryToProductSkuMapping(mappingRequest);
    } catch (ApplicationRuntimeException ex) {
      Assertions.assertTrue((StringUtils.isBlank(mappingRequest.getProductSku()) ||
          StringUtils.isBlank(mappingRequest.getCategoryCode())));
      Assertions.assertEquals("status must be FAILED", FAILED_STATUS, mappingRequest.getStatus());
    }
  }

  @Test
  public void processCategoryToProductSkuMappingTest_WhenProductNotFound() throws Exception {
    Mockito.when(productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false))
        .thenReturn(null);
    CategoryProductSkuMappingRequest mappingRequest = generateMasterCategoryMappingRequest();
    productServiceImpl.processCategoryToProductSkuMapping(mappingRequest);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false);
    verify(kafkaProducer).send(ProductDomainEventName.CATEGORY_TO_PRODUCT_SKU_SAVE_EVENT,
        CATEGORY_CODE,mappingRequest);
    Assertions.assertEquals(FAILED_STATUS, mappingRequest.getStatus());
  }

  @Test
  public void processCategoryToProductSkuMappingTest_updateMasterCatalog() throws Exception {
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    MasterCatalog masterCatalog = new MasterCatalog(ProductServiceImplTest.CATALOG_CODE, new Category("oldCategory",
        "groupId"));
    product.setMasterCatalog(masterCatalog);
    Mockito.when(productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(listOfItems);
    CategoryProductSkuMappingRequest mappingRequest = generateMasterCategoryMappingRequest();
    productServiceImpl.processCategoryToProductSkuMapping(mappingRequest);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false);
    verify(kafkaProducer).send(ProductDomainEventName.CATEGORY_TO_PRODUCT_SKU_SAVE_EVENT,
        CATEGORY_CODE, mappingRequest);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateSolrOnMasterCatalogChanges(any(), eq(listOfItems));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    Assertions.assertEquals(COMPLETED_STATUS, mappingRequest.getStatus());
  }

  @Test
  public void processCategoryToProductSkuMappingTest_null() throws Exception {
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    MasterCatalog masterCatalog = new MasterCatalog(ProductServiceImplTest.CATALOG_CODE, null);
    product.setMasterCatalog(masterCatalog);
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    masterDataProduct.setMasterCatalog(new MasterCatalog(ProductServiceImplTest.CATALOG_CODE, null));
    product.setMasterDataProduct(masterDataProduct);
    Mockito.when(productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(listOfItems);
    CategoryProductSkuMappingRequest mappingRequest = generateMasterCategoryMappingRequest();
    productServiceImpl.processCategoryToProductSkuMapping(mappingRequest);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false);
    verify(kafkaProducer).send(ProductDomainEventName.CATEGORY_TO_PRODUCT_SKU_SAVE_EVENT,
        CATEGORY_CODE,mappingRequest);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateSolrOnMasterCatalogChanges(any(), eq(listOfItems));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
  }

  @Test
  public void processCategoryToProductSkuMappingTest_null_2() throws Exception {
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    MasterCatalog masterCatalog =
        new MasterCatalog(ProductServiceImplTest.CATALOG_CODE, new Category(CATEGORY_CODE, "groupId"));
    product.setMasterCatalog(masterCatalog);
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    masterDataProduct.setMasterCatalog(
        new MasterCatalog(ProductServiceImplTest.CATALOG_CODE, new Category(CATEGORY_CODE, "groupId")));
    product.setMasterDataProduct(masterDataProduct);
    Mockito.when(productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(listOfItems);
    CategoryProductSkuMappingRequest mappingRequest = generateMasterCategoryMappingRequest();
    productServiceImpl.processCategoryToProductSkuMapping(mappingRequest);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false);
    verify(kafkaProducer).send(ProductDomainEventName.CATEGORY_TO_PRODUCT_SKU_SAVE_EVENT,
        CATEGORY_CODE,mappingRequest);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService)
        .updateSolrOnMasterCatalogChanges(any(), eq(listOfItems));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
  }

  @Test
  public void processCategoryToProductSkuMappingTest_updateMasterDataProduct() throws Exception {
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    MasterCatalog masterCatalog = new MasterCatalog(ProductServiceImplTest.CATALOG_CODE, new Category("oldCategory",
        "groupId"));
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    masterDataProduct.setMasterCatalog(masterCatalog);
    product.setMasterDataProduct(masterDataProduct);
    Mockito.when(productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(listOfItems);
    CategoryProductSkuMappingRequest mappingRequest = generateMasterCategoryMappingRequest();
    productServiceImpl.processCategoryToProductSkuMapping(mappingRequest);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, false);
    verify(kafkaProducer).send(ProductDomainEventName.CATEGORY_TO_PRODUCT_SKU_SAVE_EVENT,
        CATEGORY_CODE,mappingRequest);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    Mockito.verify(productAndItemSolrIndexerService).updateSolrOnMasterCatalogChanges(any(), eq(listOfItems));
    Assertions.assertEquals(COMPLETED_STATUS, mappingRequest.getStatus());
  }

  @Test
  public void findProductByStoreIdAndProductSkuAndMarkForDeleteFalseTest() throws Exception {
    Product product = new Product();
    when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_SKU), eq(false)))
        .thenReturn(product);
    when(this.skuValidator.isProductSku(ProductServiceImplTest.PRODUCT_SKU)).thenReturn(true);
    Product result = productServiceImpl
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    Mockito.verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(eq(STORE_ID), eq(PRODUCT_SKU), eq(false));
    Mockito.verify(this.skuValidator).isProductSku(ProductServiceImplTest.PRODUCT_SKU);
    Assertions.assertEquals(product, result);
  }

  @Test
  public void getProductsByProductCatentryIdsTest() throws Exception {
    Product product = new Product();
    Set<String> catentryIds = new HashSet<>();
    when(this.productRepository
        .findByStoreIdAndProductCatentryIdInAndMarkForDeleteFalse(eq(STORE_ID), eq(catentryIds)))
        .thenReturn(Arrays.asList(product));
    List<Product> result =
        productServiceImpl.getProductsByProductCatentryIds(STORE_ID, catentryIds);
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductCatentryIdInAndMarkForDeleteFalse(eq(STORE_ID), eq(catentryIds));
    Assertions.assertEquals(Arrays.asList(product), result);
  }

  @Test
  public void getProductsByProductCodesTest() throws Exception {
    Product product = new Product();
    Set<String> productCodes = new HashSet<>();
    when(this.productRepository
        .findByStoreIdAndProductCodeInAndMarkForDeleteFalse(eq(STORE_ID), eq(productCodes)))
        .thenReturn(Arrays.asList(product));
    List<Product> result = productServiceImpl.getProductsByProductCodes(STORE_ID, productCodes);
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductCodeInAndMarkForDeleteFalse(eq(STORE_ID), eq(productCodes));
    Assertions.assertEquals(Arrays.asList(product), result);
  }

  @Test
  public void getProductsByProductSkusTest() {
    Set<String> productSku = new HashSet<>();
    productSku.add(PRODUCT_SKU);
    String[] includedField = {ProductFieldNames.PRODUCT_SKU, ProductFieldNames.PRODUCT_NAME,
        ProductFieldNames.PRODUCT_NAME_IN_MASTER_DATA_PRODUCT, ProductFieldNames.IS_SYNCHRONIZED};
    Mockito.when(this.productRepository.findByStoreIdAndProductSkus(STORE_ID, productSku,  includedField, false))
        .thenReturn(new ArrayList<>());
    List<Product> result = this.productServiceImpl.getProductsByProductSkus(STORE_ID, productSku, includedField, false);
    Mockito.verify(this.productRepository).findByStoreIdAndProductSkus(STORE_ID, productSku,  includedField, false);
  }

  @Test
  public void getProductsByProductSkusEmptyWithEmptySetTest() {
    Set<String> productSku = new HashSet<>();
    String[] includedField = {ProductFieldNames.PRODUCT_SKU, ProductFieldNames.PRODUCT_NAME,
        ProductFieldNames.PRODUCT_NAME_IN_MASTER_DATA_PRODUCT, ProductFieldNames.IS_SYNCHRONIZED};
    Assertions.assertThrows(ApplicationRuntimeException.class, () ->
        this.productServiceImpl.getProductsByProductSkus(STORE_ID, productSku, includedField, false));
  }

  @Test
  public void getProductsByProductSkusStoreIdBlankTest() {
    Set<String> productSku = new HashSet<>();
    productSku.add(PRODUCT_SKU);
    String[] includedField = {ProductFieldNames.PRODUCT_SKU, ProductFieldNames.PRODUCT_NAME,
        ProductFieldNames.PRODUCT_NAME_IN_MASTER_DATA_PRODUCT, ProductFieldNames.IS_SYNCHRONIZED};
    Assertions.assertThrows(ApplicationRuntimeException.class, () ->
        this.productServiceImpl.getProductsByProductSkus(StringUtils.EMPTY, productSku, includedField, false));
  }

  @Test
  public void getProductsByProductSkusFieldsNullTest() {
    Set<String> productSku = new HashSet<>();
    productSku.add(PRODUCT_SKU);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductsByProductSkus(STORE_ID, productSku, null,false));
  }

  @Test
  public void findByStoreIdAndProductSkuInTest() {
    Mockito
        .when(productRepository.findByStoreIdAndProductSkuIn(STORE_ID, Arrays.asList(PRODUCT_SKU)))
        .thenReturn(Arrays.asList(productSync));
    List<Product> products =
        productServiceImpl.findByStoreIdAndProductSkuIn(STORE_ID, Arrays.asList(PRODUCT_SKU));
    Mockito
        .verify(productRepository).findByStoreIdAndProductSkuIn(STORE_ID, Arrays.asList(PRODUCT_SKU));
    Assertions.assertEquals(productSync, products.get(0));
  }

  @Test
  public void findByStoreIdAndProductSkuTest() {
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(productSync);
    Product product = productServiceImpl.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Assertions.assertEquals(productSync, product);
  }

  @Test
  public void findByStoreIdAndProductCodeAndMerchantCodeTest() {
    Mockito.when(productRepository.findByStoreIdAndProductCodeAndMerchantCode(STORE_ID, PRODUCT_CODE, MERCHANT_CODE))
        .thenReturn(Arrays.asList(productSync));
    List<Product> product =
        productServiceImpl.findByStoreIdAndProductCodeAndMerchantCode(STORE_ID, PRODUCT_CODE, MERCHANT_CODE);
    Mockito.verify(productRepository).findByStoreIdAndProductCodeAndMerchantCode(STORE_ID, PRODUCT_CODE, MERCHANT_CODE);
    Assertions.assertEquals(productSync, product.get(0));
  }

  @Test
  public void findByStoreIdAndProductCodeAndMerchantCode_withNullStoreIdTest() {
    try {
      List<Product> product =
          productServiceImpl.findByStoreIdAndProductCodeAndMerchantCode(null, PRODUCT_CODE, MERCHANT_CODE);
    } catch (Exception e) {
      Mockito.verify(productRepository, times(0))
          .findByStoreIdAndProductCodeAndMerchantCode(anyString(), anyString(), anyString());
    }
  }

  @Test
  public void findByStoreIdAndProductCodeAndMerchantCode_withNullProductCodeTest() {
    try {
      List<Product> product =
          productServiceImpl.findByStoreIdAndProductCodeAndMerchantCode(STORE_ID, null, MERCHANT_CODE);
    } catch (Exception e) {
      Mockito.verify(productRepository, times(0))
          .findByStoreIdAndProductCodeAndMerchantCode(anyString(), anyString(), anyString());
    }
  }

  @Test
  public void findByStoreIdAndProductCodeAndMerchantCode_withNullMerchantCodeTest() {
    try {
      List<Product> product =
          productServiceImpl.findByStoreIdAndProductCodeAndMerchantCode(STORE_ID, PRODUCT_CODE, null);
    } catch (Exception e) {
      Mockito.verify(productRepository, times(0))
          .findByStoreIdAndProductCodeAndMerchantCode(anyString(), anyString(), anyString());
    }
  }

  @Test
  public void findByStoreIdAndProductCodeInAndMarkForDeleteFalseTest() {
    Set<String> productCodes = new HashSet<>();
    productCodes.add(PRODUCT_CODE);
    Mockito.when(productRepository
            .findByStoreIdAndProductCodeInAndMarkForDeleteFalse(STORE_ID, productCodes))
        .thenReturn(Arrays.asList(productSync));
    List<Product> products = productServiceImpl
        .findByStoreIdAndProductCodeInAndMarkForDeleteFalse(STORE_ID, productCodes);
    Mockito.verify(productRepository)
        .findByStoreIdAndProductCodeInAndMarkForDeleteFalse(STORE_ID, productCodes);
    Assertions.assertEquals(productSync, products.get(0));
  }

  @Test
  public void findByStoreIdAndProductCodeTest() {
    Mockito.when(productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(Collections.singletonList(productSync));
    List<Product> products = productServiceImpl.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    Mockito.verify(productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    Assertions.assertEquals(productSync, products.get(0));
  }

  @Test
  public void getProductsByProductCodesAndFieldsTest() {
    String fields[] = {ProductFieldNames.PRODUCT_CODE, ProductFieldNames.PRODUCT_SKU};
    Set productCodes = new HashSet();
    List<Product> result = new ArrayList<>();
    result.add(productSyncTobeUpdated);
    Mockito
        .when(this.productRepository.findByStoreIdAndProductCodes(STORE_ID, productCodes, fields))
        .thenReturn(result);
    productCodes.add(PRODUCT_CODE);
    List<Product> products =
        this.productServiceImpl.getProductsByProductCodes(STORE_ID, productCodes, fields);
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductCodes(STORE_ID, productCodes, fields);
  }

  @Test
  public void getProductDeletedOrUndeletedTest() {
    when(skuValidator.isProductSku(PRODUCT_SKU)).thenReturn(true);
    productServiceImpl.getProductDeletedOrUndeleted(STORE_ID, PRODUCT_SKU);
    verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void getProductDeletedOrUndeleted_InvalidProductSkuTest() {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getProductDeletedOrUndeleted(STORE_ID, PRODUCT_SKU));
  }

  @Test
  public void getProductDeletedOrUndeleted_StoreIdNull() {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getProductDeletedOrUndeleted(null, PRODUCT_SKU));
  }

  @Test
  public void toggleSuspensionProduct_withSuspensionTrueTest() throws Exception {
    Mockito.when(productRepository.findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    Mockito.when(itemService.suspendItems(ProductServiceImplTest.STORE_ID, PRODUCT_SKU, ProductServiceImplTest.TRUE))
        .thenReturn(Pair.of(itemsMap, Collections.singletonList(item)));
    Mockito.when(saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(product);
    Mockito.doNothing().when(productAndItemSolrIndexerService).updateItemsInSolr(STORE_ID, PRODUCT_SKU, true, itemsMap, true,
        new ArrayList<>(), StringUtils.EMPTY);
    this.productServiceImpl.toggleSuspensionProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.TRUE, REQUEST_ID);
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    Mockito.verify(this.itemService).suspendItems(STORE_ID, PRODUCT_SKU, TRUE);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    Mockito.verify(productAndItemSolrIndexerService).updateItemsInSolr(STORE_ID, PRODUCT_SKU, true, itemsMap, true,
        Collections.singletonList(item), MERCHANT_CODE);
  }

  @Test
  public void toggleSuspensionProduct_withSuspensionFalseTest() throws Exception {
    product.setSuspended(Boolean.TRUE);
    product.setMarkForDelete(Boolean.TRUE);
    item.setArchivedBeforeSuspension(true);
    product.setCurationStatus(CurationStatus.APPROVED);
    productDetailResponse.getProductCategoryResponses().get(0).getCategory().setHalalCategory(true);
    Mockito.when(productRepository.findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    Mockito.when(itemService.suspendItems(ProductServiceImplTest.STORE_ID, PRODUCT_SKU, ProductServiceImplTest.FALSE))
        .thenReturn(Pair.of(itemsMap, Collections.singletonList(item)));
    Mockito.when(saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(product);
    Mockito.when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, product.getProductCode()))
        .thenReturn(productDetailResponse);
    Mockito.when(this.itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    Mockito.doNothing().when(this.productAndItemSolrIndexerService)
        .updateSolrOnMasterCatalogChanges(product, Arrays.asList(item));
    Mockito.doNothing().when(this.productAndItemSolrIndexerService)
        .updateSolrOnSalesCatalogChanges(product, Arrays.asList(item));
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));
    Mockito.when(this.productCategoryBaseClient
            .getSalesCategoryMappingByProductCode(STORE_ID, REQUEST_ID, USERNAME, product.getProductCode(), false))
        .thenReturn(new GdnRestSingleResponse<>(null, null, true, productSalesCategoryMappingResponse, REQUEST_ID));
    this.productServiceImpl
        .toggleSuspensionProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.FALSE, ProductServiceImplTest.REQUEST_ID);
    Mockito.verify(this.masterDataService)
        .getProductDetailFromMasterData(USERNAME, REQUEST_ID, product.getProductCode());
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    Mockito.verify(this.itemService).suspendItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
        ProductServiceImplTest.FALSE);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    Mockito.verify(productAndItemSolrIndexerService).updateItemsInSolr(STORE_ID, PRODUCT_SKU, false, itemsMap, false,
        Collections.singletonList(item), MERCHANT_CODE);
    Mockito.verify(this.itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(this.productAndItemSolrIndexerService)
        .updateSolrOnMasterCatalogChanges(product, Arrays.asList(item));
    Mockito.verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, Arrays.asList(item));
    Mockito.verify(this.productCategoryBaseClient)
        .getSalesCategoryMappingByProductCode(STORE_ID, REQUEST_ID, USERNAME, product.getProductCode(), false);
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(product.getSalesCatalogs().get(0).getListOfCategories().get(0).getCategoryCode(), NEW_CAT_1);
    Assertions.assertEquals(product.getMasterCatalog().getCategory().getCategoryCode(), CATEGORY_CODE);
  }

  @Test
  public void toggleSuspensionProduct_withSuspensionFalseProductCodeNullTest() throws Exception {
    product.setSuspended(Boolean.TRUE);
    product.setMarkForDelete(Boolean.TRUE);
    product.setProductCode(null);
    item.setArchivedBeforeSuspension(true);
    Mockito.when(productRepository.findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    Mockito.when(itemService.suspendItems(ProductServiceImplTest.STORE_ID, PRODUCT_SKU, ProductServiceImplTest.FALSE))
        .thenReturn(Pair.of(itemsMap, Collections.singletonList(item)));
    Mockito.when(saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(product);
    Mockito.when(this.itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    Mockito.doNothing().when(this.productAndItemSolrIndexerService)
        .updateSolrOnMasterCatalogChanges(product, Arrays.asList(item));
    Mockito.doNothing().when(this.productAndItemSolrIndexerService)
        .updateSolrOnSalesCatalogChanges(product, Arrays.asList(item));
    this.productServiceImpl
        .toggleSuspensionProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.FALSE, ProductServiceImplTest.REQUEST_ID);
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    Mockito.verify(this.itemService).suspendItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
        ProductServiceImplTest.FALSE);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    Mockito.verify(productAndItemSolrIndexerService).updateItemsInSolr(STORE_ID, PRODUCT_SKU, false, itemsMap, false,
        Collections.singletonList(item), MERCHANT_CODE);
    Mockito.verify(this.itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(this.productAndItemSolrIndexerService)
        .updateSolrOnMasterCatalogChanges(product, Arrays.asList(item));
    Mockito.verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, Arrays.asList(item));
  }

  @Test
  public void toggleSuspensionProductExceptionTest() throws Exception {
    Mockito.when(productRepository.findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, PRODUCT_SKU))
        .thenReturn(null);
    try {
      this.productServiceImpl
          .toggleSuspensionProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
              ProductServiceImplTest.USERNAME, ProductServiceImplTest.FALSE, REQUEST_ID);
    } catch (Exception e) {
      Mockito.verify(this.productRepository)
          .findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    }
  }

  @Test
  public void toggleSuspensionProduct_withIncorrectStateExceptionTest() throws Exception {
    product.setMarkForDelete(false);
    product.setSuspended(true);
    Mockito.when(productRepository.findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    try {
      this.productServiceImpl
          .toggleSuspensionProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
              ProductServiceImplTest.USERNAME, ProductServiceImplTest.FALSE, REQUEST_ID);
    } catch (Exception e) {
      Mockito.verify(this.productRepository)
          .findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    }
  }

  @Test
  public void toggleSuspensionProduct_withActivatingNonSuspendedProductTest() throws Exception {
    product.setMarkForDelete(true);
    product.setSuspended(false);
    Mockito.when(productRepository.findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    this.productServiceImpl.toggleSuspensionProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.FALSE, REQUEST_ID);
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);

  }

  @Test
  public void updateProductUnSyncTest_categoryCodeCheck() {
    productUnsyncUpdated.getMasterDataProduct().setMasterCatalog(new MasterCatalog());
    productUnsyncUpdated.getMasterDataProduct().getMasterCatalog().setCategory(category);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }


  @Test
  public void updateProductUnSyncTest_categoryCodeCheckExpectException() {
    category.setCategoryCode(CATEGORY_CODE_FOR_UNSYNC_CHECK);
    productUnSyncTobeUpdated.getMasterDataProduct().setMasterCatalog(new MasterCatalog());
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterCatalog().setCategory(category);
    when(this.saveOperationService.saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>())))
        .thenReturn(productAndItemsVO);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl
          .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
              true));
    } finally {
      verify(this.productRepository)
          .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
              ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
      verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
          PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
      verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    }
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChanges_updateDisabledTest() {
    masterDataAttributeUpdated.setAttributeCode(ATTRIBUTE_CODE);
    masterDataAllowedAttributeValueUpdated.setAllowedAttributeValueCode(ALLOWED_ATTRIBUTE_VALUE_CODE_1);
    masterDataAllowedAttributeValueUpdated.setValue(ALLOWED_ATTRIBUTE_VALUE_1);
    masterDataProductAttributeValueExisting.setAllowedAttributeValue(masterDataAllowedAttributeValueUpdated);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);
    masterDataProductAttributeUpdated.setMasterDataProductAttributeValues(
        Collections.singletonList(masterDataProductAttributeValueExisting));
    masterDataProduct.setProductName(OLD_PRODUCT_NAME);
    masterDataProduct.setBrand(BRAND);
    masterDataProduct.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));
    masterCatalog.getCategory().setCategoryCode(CATEGORY_CODE_FOR_UNSYNC_CHECK);
    masterDataProduct.setMasterCatalog(masterCatalog);
    this.productUnSyncTobeUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    when(this.saveOperationService.saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()))).thenReturn(productAndItemsVO);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl
          .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
              true));
    } finally {
      verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
      verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
          PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
      verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    }
  }

  @Test
  public void updateProductUnSync_WithMasterDataChanges_updateDisabledTest() {
    masterDataProduct.setProductName(OLD_PRODUCT_NAME);
    masterCatalog.getCategory().setCategoryCode(CATEGORY_CODE_FOR_UNSYNC_CHECK);
    masterDataProduct.setMasterCatalog(masterCatalog);
    this.productUnSyncTobeUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    when(this.saveOperationService.saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()))).thenReturn(productAndItemsVO);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () ->  this.productServiceImpl
          .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
              true));
    } finally {
      verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
      verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
          PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
      verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    }
  }

  @Test
  public void
  getProductDetailAndSingleItemByItemSkuTest() throws Exception {
    item.setContentChanged(false);
    item.setSourceItemCode(SOURCE_ITEM_CODE);
    ProductAndItemsVO productAndItemsVO = new ProductAndItemsVO(productSync, Arrays.asList(this.item));
    List<Item> items = Arrays.asList(this.item);
    when(this.itemService
        .getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false)).thenReturn(this.item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, true)).thenReturn(productAndItemsVO);
    Mockito.when(itemPickupPointService.findByItemSkuInAndDelivery(eq(STORE_ID), any(), eq(true))).thenReturn(null);
    ProductAndItemsVO response = this.productServiceImpl
        .getProductDetailAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false, null);
    verify(this.productHelperService).findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService).getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
        false);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items,
            false, true);
    verify(this.productSearchHelperService)
        .setItemCatalogs(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, true, Collections.singletonList(productAndItemsVO),
            Collections.singletonMap(productAndItemsVO.getProduct().getProductCode(),
                productAndItemsVO.getProduct().getMasterDataProduct()));
    assertEquals(SOURCE_ITEM_CODE, response.getItems().get(0).getSourceItemCode());
    assertFalse(response.getItems().get(0).isContentChanged());

  }

  @Test
  public void getProductDetailAndSingleItemByItemSku_WhenProductAndItemsNullTest()
      throws Exception {
    when(this.itemService
        .getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            true, true, false, false, null, false))
        .thenReturn(item);
    this.productServiceImpl.getProductDetailAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false,
        null);
    verify(this.productHelperService)
        .findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService)
        .getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false);
    verify(this.productCacheableService)
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
  }

  @Test
  public void getProductDetailAndSingleItemByItemSkuTest_usingOfflineItemSku_nullOfflineItem() throws Exception {
    when(this.itemService.getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false))
        .thenReturn(null);
    when(this.itemPickupPointService.findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU))
        .thenReturn(null);

    try {
      this.productServiceImpl.getProductDetailAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
          false, null);
    } catch (Exception e) {
      verify(this.itemService).getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
          false, false, null, false);
      verify(this.itemPickupPointService).findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU);
    }
  }

  @Test
  public void getProductDetailAndSingleItemByItemSkuTest_usingOfflineItemSku_nullItemFromOfflineItem() throws Exception {
    when(this.itemService.getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false))
        .thenReturn(null);
    itemPickupPoint.setItemSku(ITEM_SKU_OFFLINE_ITEM);
    when(this.itemPickupPointService.findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU))
        .thenReturn(this.itemPickupPoint);
    when(this.itemService.getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false))
        .thenReturn(null);

    try {
      this.productServiceImpl.getProductDetailAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL,
          false, null);
    } catch (Exception e) {
      verify(this.itemService).getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
          false, false, null, false);
      verify(this.itemPickupPointService).findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU);
      verify(this.itemService).getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
          false, false, null, false);
    }
  }

  @Test
  public void getProductDetailAndSingleItemByItemSkuTest_usingOfflineItemSku_success() throws Exception {
    when(this.itemService.getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, true, true,
        false, false, null, false))
        .thenReturn(null);
    itemPickupPoint.setItemSku(ITEM_SKU_OFFLINE_ITEM);
    when(this.itemPickupPointService.findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU))
        .thenReturn(this.itemPickupPoint);
    when(this.itemService.getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false))
        .thenReturn(item);

    this.productServiceImpl
        .getProductDetailAndSingleItemByItemSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false, null);

    verify(this.itemService).getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false);
    verify(this.itemPickupPointService).findByStoreIdAndOfflineItemIdAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.ITEM_SKU);
    verify(this.itemService).getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.ITEM_SKU_OFFLINE_ITEM, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true,
        false, false, null, false);
    verify(this.productHelperService).constructOfflineItem(this.item, CommonUtil.getOfflineItemByPickupPoint(itemPickupPoint, false, null));
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
  }

  @Test
  public void updateProductUnSyncTest_updateDescription() {
    this.productUnsyncUpdated.getMasterDataProduct().setDescription(UPDATED_DESCRIPTION);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_updateLongDescription() {
    this.productUnsyncUpdated.getMasterDataProduct().setLongDescription(UPDATED_LONG_DESCRIPTION);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl.updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        this.productUnsyncUpdated, false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest_newAttributeAdded() {
    masterDataAttributeUpdated.setAttributeCode(ATTRIBUTE_CODE_1);
    masterDataProductAttributeValueExisting.setPredefinedAllowedAttributeValue(masterDataPredefinedAttributeValueExisting);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);
    masterDataProductAttributeUpdated.setMasterDataProductAttributeValues(
        Collections.singletonList(masterDataProductAttributeValueExisting));
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.getMasterDataProductAttributes().add(masterDataProductAttributeUpdated);
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    when(this.masterDataAttributeService
        .getOrSaveNewMasterDataAttribute(masterDataAttributeUpdated)).thenReturn(masterDataAttributeUpdated);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.productHelperService).generateSpecificationDetail(productUnSyncTobeUpdated);
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.masterDataAttributeService)
        .getOrSaveNewMasterDataAttribute(masterDataAttributeUpdated);
    assertNotNull(product);
    Assertions.assertEquals(Collections.singletonList(masterDataProductAttributeUpdated),
        product.getMasterDataProduct().getMasterDataProductAttributes());
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest_newVariantCreationAttributeAdded() {
    masterDataAttributeUpdated.setAttributeCode(ATTRIBUTE_CODE_1);
    masterDataAttributeUpdated.setVariantCreation(true);
    masterDataProductAttributeValueExisting.setPredefinedAllowedAttributeValue(masterDataPredefinedAttributeValueExisting);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);
    masterDataProductAttributeUpdated.setMasterDataProductAttributeValues(
        Collections.singletonList(masterDataProductAttributeValueExisting));
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.getMasterDataProductAttributes().add(masterDataProductAttributeUpdated);
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(productUnSyncTobeUpdated);
    assertNotNull(product);
    Assertions.assertEquals(Collections.singletonList(masterDataProductAttributeUpdated),
        product.getMasterDataProduct().getMasterDataProductAttributes());
  }

  @Test
  public void updateProductUnSyncTest_updateProductStory() {
    this.productUnsyncUpdated.getMasterDataProduct().setProductStory(UPDATED_PRODUCT_STORY);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_updateUsp() {
    this.productUnsyncUpdated.getMasterDataProduct().setUniqueSellingPoint(UPDATED_USP);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_updateUom() {
    this.productUnsyncUpdated.getMasterDataProduct().setUom(UPDATED_UOM);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_updateUrl() {
    this.productUnsyncUpdated.getMasterDataProduct().setUrl(UPDATED_URL);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_updateMasterProductImage() {
    this.productUnsyncUpdated.getMasterDataProduct().setMasterDataProductImages(Arrays.asList(masterDataProductImage));
    this.productUnSyncTobeUpdated.getMasterDataProduct().setMasterDataProductImages(new ArrayList<>());
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_systemParamterException() {
    when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE))
        .thenThrow(ApplicationRuntimeException.class);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
  }

  @Test
  public void updateUmkmProductCatalogTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    listOfItems.get(0).setCategoryCode(CATEGORY_CODE_UPDATED);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping,
            Collections.singletonList(productCategoryDomainEventModel), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    verify(itemService).updateCategoryCodeByItemSkuList(any(), any(), any());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    assertEquals(3, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertEquals(CATEGORY_CODE,
        productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCategory().getCategoryCode());
    assertEquals(CATEGORY_CODE,
        productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCategory().getCatgroupId());
    assertEquals(CATALOG_CODE, productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCatalogCode());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductCatalogCategoryCodeTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    productSync.setCategoryCode(productCategoryDomainEventModel.getCategory().getCategoryCode());
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    listOfItems.get(0).setCategoryCode(CATEGORY_CODE);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping,
            Collections.singletonList(productCategoryDomainEventModel), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    assertEquals(3, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertEquals(CATEGORY_CODE,
        productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCategory().getCategoryCode());
    assertEquals(CATEGORY_CODE,
        productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCategory().getCatgroupId());
    assertEquals(CATALOG_CODE, productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCatalogCode());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductCatalogExceptionTest() {
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    productCategoryDomainEventModel.setCategory(null);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping,
            Collections.singletonList(productCategoryDomainEventModel), true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    Assertions.assertEquals(CATEGORY_CODE_UPDATED,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(0)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_1,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(1)
            .getCategoryCode());
    Assertions.assertEquals(NEW_UMKM_CAT_2,
        productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().get(2)
            .getCategoryCode());
    assertEquals(3, productArgumentCaptor.getAllValues().get(0).getSalesCatalogs().get(0).getListOfCategories().size());
    assertNotNull(result);
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest_nullExistingAttributeValue() {
    masterDataAttributeUpdated.setAttributeCode(ATTRIBUTE_CODE);
    masterDataProductAttributeValueExisting.setPredefinedAllowedAttributeValue(masterDataPredefinedAttributeValueExisting);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);
    masterDataProductAttributeUpdated.setMasterDataProductAttributeValues(
        Collections.singletonList(masterDataProductAttributeValueExisting));
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0).getMasterDataProductAttributeValues()
        .get(0).setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0).getMasterDataProductAttributeValues()
        .get(0).setPredefinedAllowedAttributeValue(null);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.productHelperService).generateSpecificationDetail(productUnSyncTobeUpdated);
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    Assertions.assertEquals(Collections.singletonList(masterDataProductAttributeUpdated),
        product.getMasterDataProduct().getMasterDataProductAttributes());
  }

  @Test
  public void saveProductWithoutUpdatingSolrTest() {
    Product product = new Product();
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(product, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP)).thenReturn(product);
    productServiceImpl.saveProductWithoutUpdatingSolr(product, new ArrayList<>(),
        StringUtils.EMPTY);
    Mockito.verify(this.saveOperationService).saveProductWithoutUpdatingSolr(product, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
  }

  @Test
  public void saveProductHalalConfigAndCaptureHistoryTest() {
    halalHistoryUpdateEventModel.setCurrentValue(PREVIOUS_VALUE);
    when(this.cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku())).thenReturn(
        this.listOfItems);
    productServiceImpl.saveProductHalalConfigAndCaptureHistory(product, halalHistoryUpdateEventModel, STORE_ID);
    Mockito.verify(saveOperationService).saveProduct(product);
    Mockito.verify(kafkaProducer)
        .send(ProductDomainEventName.HALAL_HISTORY_UPDATE, product.getProductSku(), halalHistoryUpdateEventModel);
    Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    Mockito.verify(saveAndPublishService).publishListOfItems(listOfItems);
  }

  @Test
  public void saveProductHalalConfigAndCaptureHistoryWhenHalalConfigChange() {
    boolean halalProduct = Boolean.parseBoolean(halalHistoryUpdateEventModel.getCurrentValue());
    when(this.cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku())).thenReturn(
        this.listOfItems);
    productServiceImpl.saveProductHalalConfigAndCaptureHistory(product, halalHistoryUpdateEventModel, STORE_ID);
    Mockito.verify(saveOperationService).saveProduct(product);
    Mockito.verify(kafkaProducer)
        .send(ProductDomainEventName.HALAL_HISTORY_UPDATE, product.getProductSku(), halalHistoryUpdateEventModel);
    Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    Mockito.verify(saveAndPublishService).publishListOfItemsForHalaConfigChange(listOfItems, halalProduct);
    Assertions.assertEquals(listOfItems.get(0).getItemChangeEventTypes(),Collections.EMPTY_LIST);
  }

  @Test
  public void saveProductHalalConfigAndCaptureHistoryWhenHalalConfigChangeSwitchOn() {
    boolean halalProduct = Boolean.parseBoolean(halalHistoryUpdateEventModel.getCurrentValue());
    ReflectionTestUtils.setField(productServiceImpl, "halaConfigUpdateEventTypeSwitch", true);
    when(this.cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku())).thenReturn(
        this.listOfItems);
    productServiceImpl.saveProductHalalConfigAndCaptureHistory(product, halalHistoryUpdateEventModel, STORE_ID);
    Mockito.verify(saveOperationService).saveProduct(product);
    Mockito.verify(kafkaProducer)
        .send(ProductDomainEventName.HALAL_HISTORY_UPDATE, product.getProductSku(), halalHistoryUpdateEventModel);
    Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    Mockito.verify(saveAndPublishService).publishListOfItemsForHalaConfigChange(listOfItems, halalProduct);
    Assertions.assertEquals(listOfItems.get(0).getItemChangeEventTypes(),Collections.singletonList(HALAL_CONFIG_CHANGE));
  }


  @Test
  public void updateProductSyncTest_forceReviewTrue() throws Exception {
    productSyncTobeUpdated.setForceReview(true);
    Mockito.when(this.productRepository
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
            this.productSyncTobeUpdated.getProductSku(), false)).thenReturn(productSyncTobeUpdated);
    try {
      Product product = this.productServiceImpl
          .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUpdated,
              false);
    } catch (ApplicationRuntimeException e) {

    } finally {
      verify(this.productRepository)
          .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
              this.productSyncTobeUpdated.getProductSku(), false);
    }
  }

  @Test
  public void checkProductAndItemsForForceReviewTest() {
    this.productServiceImpl.checkProductAndItemsForForceReview(Arrays.asList(product), Arrays.asList(item));
  }

  @Test
  public void toggleSuspensionProduct_withSuspensionFalseTest_synchronizedProduct() throws Exception {
    product.setSuspended(Boolean.TRUE);
    product.setMarkForDelete(Boolean.TRUE);
    product.setSynchronized(true);
    product.setMerchantCode(MERCHANT_CODE);
    item.setArchivedBeforeSuspension(true);
    item.setSynchronized(true);
    Mockito.when(productRepository.findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));
    Mockito.when(this.productCategoryBaseClient
            .getSalesCategoryMappingByProductCode(STORE_ID, REQUEST_ID, USERNAME, product.getProductCode(), true))
        .thenReturn(new GdnRestSingleResponse<>(null, null, true, productSalesCategoryMappingResponse, REQUEST_ID));
    Mockito.when(itemService.suspendItems(ProductServiceImplTest.STORE_ID, PRODUCT_SKU, ProductServiceImplTest.FALSE))
        .thenReturn(Pair.of(itemsMap, Collections.singletonList(item)));
    Mockito.when(saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP))).thenReturn(product);
    Mockito.when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, product.getProductCode()))
        .thenReturn(productDetailResponse);
    Mockito.when(this.itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    Mockito.doNothing().when(this.productAndItemSolrIndexerService).applyProduct(product, false);
    this.productServiceImpl
        .toggleSuspensionProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.FALSE, ProductServiceImplTest.REQUEST_ID);
    Mockito.verify(this.masterDataService)
        .getProductDetailFromMasterData(USERNAME, REQUEST_ID, product.getProductCode());
    Mockito.verify(this.productRepository)
        .findByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    Mockito.verify(this.itemService).suspendItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU,
        ProductServiceImplTest.FALSE);
    Mockito.verify(saveOperationService).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    Mockito.verify(productAndItemSolrIndexerService).updateItemsInSolr(STORE_ID, PRODUCT_SKU, false, itemsMap, false,
        Collections.singletonList(item), MERCHANT_CODE);
    Mockito.verify(this.productAndItemSolrIndexerService).applyProduct(product, false);
    Mockito.verify(this.productCategoryBaseClient)
        .getSalesCategoryMappingByProductCode(STORE_ID, REQUEST_ID, USERNAME, product.getProductCode(), true);
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());    Assertions.assertEquals(product.getSalesCatalogs().get(0).getListOfCategories().get(0).getCategoryCode(), NEW_CAT_1);
    Assertions.assertEquals(product.getMasterCatalog().getCategory().getCategoryCode(), CATEGORY_CODE);
  }

  private ProductDomainEventModel getProductDomainEventModelMessage() {
    message = new ProductDomainEventModel();
    message.setProductCode(PRODUCT_CODE);
    message.setBrand(NEW_BRAND);
    PredefinedAllowedAttributeValueDomainEventModel predefinedAllowedAttributeValueDomainEventModel =
        new PredefinedAllowedAttributeValueDomainEventModel();
    predefinedAllowedAttributeValueDomainEventModel.setPredefinedAllowedAttributeCode(NEW_BRAND_CODE);
    predefinedAllowedAttributeValueDomainEventModel.setValue(NEW_BRAND);
    ProductAttributeValueDomainEventModel productAttributeValueDomainEventModel =
        new ProductAttributeValueDomainEventModel();
    productAttributeValueDomainEventModel
        .setPredefinedAllowedAttributeValue(predefinedAllowedAttributeValueDomainEventModel);
    ProductAttributeDomainEventModel productAttributeDomainEventModel = new ProductAttributeDomainEventModel();
    AttributeDomainEventModel attributeDomainEventModel = new AttributeDomainEventModel();
    attributeDomainEventModel.setName(BRAND);
    productAttributeDomainEventModel.setAttribute(attributeDomainEventModel);
    productAttributeDomainEventModel
        .setProductAttributeValues(Collections.singletonList(productAttributeValueDomainEventModel));
    message.setProductAttributes(Collections.singletonList(productAttributeDomainEventModel));
    return message;
  }

  @Test
  public void updateBrandForUnsyncProductsTest() {
    ProductDomainEventModel message = getProductDomainEventModelMessage();
    when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(Arrays.asList(productUnSyncTobeUpdated));
    when(this.cacheItemHelperService
        .findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED))
        .thenReturn(this.listOfItems);
    productServiceImpl.updateBrandForUnsyncProducts(STORE_ID, message);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.cacheItemHelperService)
        .findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(), eq(new ArrayList<>()));
    Assertions.assertEquals(NEW_BRAND,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getBrand());
    Assertions.assertEquals(NEW_BRAND,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getMasterDataProductAttributes()
            .get(0).getMasterDataProductAttributeValues().get(0).getPredefinedAllowedAttributeValue().getValue());
    Assertions.assertEquals(NEW_BRAND_CODE,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getMasterDataProductAttributes()
            .get(0).getMasterDataProductAttributeValues().get(0).getPredefinedAllowedAttributeValue()
            .getPredefinedAllowedAttributeCode());
    Assertions.assertEquals(NEW_BRAND, productAndItemsVOArgumentCaptor.getValue().getItems().get(0).getMasterDataItem()
        .getMasterDataItemAttributeValues().get(0).getAttributeValue());
  }

  @Test
  public void updateBrandForUnsyncProductsWhenProductIsSyncTest() {
    ProductDomainEventModel message = getProductDomainEventModelMessage();
    productUnsync.setSynchronized(true);
    productUnsync.getMasterDataProduct().setMasterDataProductAttributes(
        productUnsync.getMasterDataProduct().getMasterDataProductAttributes().stream().filter(
            masterDataProductAttribute1 -> !masterDataProductAttribute1.getMasterDataAttribute().getAttributeName()
                .equalsIgnoreCase(BRAND)).collect(Collectors.toList()));
    when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(Arrays.asList(productUnSyncTobeUpdated));
    when(this.cacheItemHelperService
        .findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED))
        .thenReturn(this.listOfItems);
    productServiceImpl.updateBrandForUnsyncProducts(STORE_ID, message);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.cacheItemHelperService)
        .findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(), eq(new ArrayList<>()));
    Assertions.assertEquals(NEW_BRAND,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getBrand());
    Assertions.assertEquals(NEW_BRAND,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getMasterDataProductAttributes()
            .get(0).getMasterDataProductAttributeValues().get(0).getPredefinedAllowedAttributeValue().getValue());
    Assertions.assertEquals(NEW_BRAND_CODE,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getMasterDataProductAttributes()
            .get(0).getMasterDataProductAttributeValues().get(0).getPredefinedAllowedAttributeValue()
            .getPredefinedAllowedAttributeCode());
    Assertions.assertEquals(NEW_BRAND, productAndItemsVOArgumentCaptor.getValue().getItems().get(0).getMasterDataItem()
        .getMasterDataItemAttributeValues().get(0).getAttributeValue());
  }

  @Test
  public void updateBrandForSyncProuctsTest() {
    ProductDomainEventModel message = getProductDomainEventModelMessage();
    productUnsync.setSynchronized(true);
    when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(Arrays.asList(productUnsync));
    when(this.cacheItemHelperService
        .findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_UNSYNC_TOBE_UPDATED))
        .thenReturn(this.listOfItems);
    productServiceImpl.updateBrandForUnsyncProducts(STORE_ID, message);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
  }

  @Test
  public void updateBrandForUnsyncProductsWithEmptyProductAttributesTest() {
    ProductDomainEventModel message = getProductDomainEventModelMessage();
    message.setProductAttributes(new ArrayList<>());
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.updateBrandForUnsyncProducts(STORE_ID, message));
  }

  @Test
  public void updateBrandForUnsyncProductsWithNoBrandProductAttributesTest() {
    ProductDomainEventModel message = getProductDomainEventModelMessage();
    message.setProductAttributes(message.getProductAttributes().stream().filter(
        productAttributeDomainEventModel -> !productAttributeDomainEventModel.getAttribute().getName()
            .equalsIgnoreCase(BRAND)).collect(Collectors.toList()));
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.updateBrandForUnsyncProducts(STORE_ID, message));
  }

  @Test
  public void updateBrandForUnsyncProductsWithNoPredefinedValueTest() {
    ProductDomainEventModel message = getProductDomainEventModelMessage();
    message.getProductAttributes().get(0).getProductAttributeValues().get(0).setPredefinedAllowedAttributeValue(null);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.updateBrandForUnsyncProducts(STORE_ID, message));
  }

  @Test
  public void updateProductUnSync_WithMasterAttributeChangesTest_() {
    masterDataAttributeUpdated.setAttributeCode(ATTRIBUTE_CODE);
    masterDataAttributeUpdated.setVariantCreation(true);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValue(ATTRIBUTE_CODE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValue(DESCRIPTIVE_ATTRIBUTE_VALUE);
    masterDataProductAttributeValueExisting.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);
    masterDataProductAttributeUpdated.setMasterDataAttribute(masterDataAttributeUpdated);
    masterDataProductAttributeUpdated.setMasterDataProductAttributeValues(
        Collections.singletonList(masterDataProductAttributeValueExisting));
    masterDataProduct.setProductName(NEW_PRODUCT_NAME);
    masterDataProduct.setMasterDataProductAttributes(Collections.singletonList(masterDataProductAttributeUpdated));
    this.productUnsyncUpdated.setMasterDataProduct(masterDataProduct);
    productAndItemsVO.setProduct(productUnsyncUpdated);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0).getMasterDataProductAttributeValues()
        .get(0).setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0).getMasterDataProductAttributeValues()
        .get(0).setDescriptiveAttributeValue(DESCRIPTIVE_ATTRIBUTE_VALUE_2);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().get(0).getMasterDataAttribute()
        .setVariantCreation(true);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList,
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, this.emptyList));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    Assertions.assertEquals(Collections.singletonList(masterDataProductAttributeUpdated),
        product.getMasterDataProduct().getMasterDataProductAttributes());
  }

  @Test
  public void getProductAndItemsByItemSkusForAllItemsTest() throws Exception {
    ProductAndItemsVO productAndItemsVO = new ProductAndItemsVO(productSync, Arrays.asList(this.item));
    List<Item> items = Arrays.asList(this.item);
    when(this.itemService
        .getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false)).thenReturn(this.item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items, false, true))
        .thenReturn(productAndItemsVO);
    Set<String> itemSkusSet = new HashSet<>();
    itemSkusSet.add(ProductServiceImplTest.ITEM_SKU);
    this.productServiceImpl
        .getProductAndItemsByItemSkusForAllItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, itemSkusSet, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, false, false);
    verify(this.productHelperService)
        .findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, Arrays.asList(item), null);
    verify(this.itemService)
        .getDetailsForActiveOrSuspendedItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.ITEM_SKU,
            ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null, false);
    verify(this.productCacheableService)
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items, false, true);
    verify(this.catalogService)
        .getItemCatalogsWithCategoryHierarchy(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync);
  }

  @Test
  public void getAllSimpleProductTest() {
    when(productRepository.findByMarkForDeleteFalse()).thenReturn(Arrays.asList(product));
    List<Product> products = productServiceImpl.getAllSimpleProduct();
    Assertions.assertEquals(product, products.get(0));
    Mockito.verify(productRepository).findByMarkForDeleteFalse();
  }

  @Test
  public void updateProductUnSyncTest_productScoreChange() throws Exception {
    oldProductScore.setEanUpcScore(1.0);
    this.productUnSyncTobeUpdated.setProductScore(oldProductScore);
    this.productUnsyncUpdated.getMasterDataProduct().setDescription(DESCRIPTION);
    this.productUnSyncTobeUpdated.getMasterDataProduct()
        .setMasterCatalog(new MasterCatalog(CATALOG_CODE, new Category(CATEGORY_CODE, CATEGORY_CODE)));
    setMasterDataAttributes(this.productUnsyncUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE,
        PREDEFINED_ATTRIBUTE_VALUE, ALLOWED_ATTRIBUTE_VALUE);
    setMasterDataAttributes(this.productUnSyncTobeUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE_2,
        PREDEFINED_ATTRIBUTE_VALUE_2, ALLOWED_ATTRIBUTE_VALUE_1);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    when(this.itemService
        .findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, productUnSyncTobeUpdated.getProductSku()))
        .thenReturn(Collections.singletonList(item));
    when(this.productHelperService
        .modifyItemNames(Collections.singletonList(item),
            ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME))
        .thenReturn(Collections.singletonList(item));
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(Collections.singletonList(item),
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, Collections.singletonList(item)));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    assertNotNull(product);
  }

  private void setMasterDataAttributes(MasterDataProduct masterDataProduct, String descriptiveAttributeValue,
      String predefinedAttributeValue, String allowedAttributeValue) {
    masterDataProduct.setMasterDataProductAttributes(new ArrayList<>());

    MasterDataProductAttribute masterDataProductAttribute = new MasterDataProductAttribute();
    MasterDataAttribute masterDataAttribute = new MasterDataAttribute();
    MasterDataProductAttributeValue masterDataProductAttributeValue = new MasterDataProductAttributeValue();

    masterDataAttribute.setAttributeCode(ATTRIBUTE_CODE);
    masterDataAttribute.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE);
    masterDataAttribute.setAttributeName(ATTRIBUTE_CODE);
    masterDataProductAttributeValue.setDescriptiveAttributeValue(descriptiveAttributeValue);
    masterDataProductAttributeValue.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.SINGLE);

    masterDataProductAttribute.setMasterDataAttribute(masterDataAttribute);
    masterDataProductAttribute.setMasterDataProductAttributeValues(Collections.singletonList(masterDataProductAttributeValue));
    masterDataProduct.getMasterDataProductAttributes().add(masterDataProductAttribute);

    MasterDataProductAttribute masterDataProductAttribute1 = new MasterDataProductAttribute();
    MasterDataAttribute masterDataAttribute1 = new MasterDataAttribute();
    MasterDataProductAttributeValue masterDataProductAttributeValue1 = new MasterDataProductAttributeValue();
    PredefinedAllowedAttributeValue predefinedAllowedAttributeValue = new PredefinedAllowedAttributeValue();

    masterDataAttribute1.setAttributeCode(ATTRIBUTE_CODE_1);
    masterDataAttribute1.setAttributeType(MasterDataAttributeType.PREDEFINED_ATTRIBUTE);
    masterDataAttribute1.setAttributeName(ATTRIBUTE_CODE_1);
    predefinedAllowedAttributeValue.setValue(predefinedAttributeValue);
    masterDataProductAttributeValue1.setPredefinedAllowedAttributeValue(predefinedAllowedAttributeValue);
    masterDataProductAttributeValue1.setDescriptiveAttributeValueType(DescriptiveAttributeValueType.PREDEFINED);

    masterDataProductAttribute1.setMasterDataAttribute(masterDataAttribute1);
    masterDataProductAttribute1.setMasterDataProductAttributeValues(Collections.singletonList(masterDataProductAttributeValue1));
    masterDataProduct.getMasterDataProductAttributes().add(masterDataProductAttribute1);

    MasterDataProductAttribute masterDataProductAttribute2 = new MasterDataProductAttribute();
    MasterDataAttribute masterDataAttribute2 = new MasterDataAttribute();
    MasterDataProductAttributeValue masterDataProductAttributeValue2 = new MasterDataProductAttributeValue();
    MasterDataAllowedAttributeValue masterDataAllowedAttributeValue2 = new MasterDataAllowedAttributeValue();

    masterDataAttribute2.setAttributeCode(ATTRIBUTE_CODE2);
    masterDataAttribute2.setAttributeType(MasterDataAttributeType.DEFINING_ATTRIBUTE);
    masterDataAttribute2.setAttributeName(ATTRIBUTE_CODE2);
    masterDataAllowedAttributeValue2.setValue(allowedAttributeValue);
    masterDataProductAttributeValue2.setAllowedAttributeValue(masterDataAllowedAttributeValue2);

    masterDataProductAttribute2.setMasterDataAttribute(masterDataAttribute2);
    masterDataProductAttribute2.setMasterDataProductAttributeValues(Collections.singletonList(masterDataProductAttributeValue2));
    masterDataProduct.getMasterDataProductAttributes().add(masterDataProductAttribute2);
  }

  @Test
  public void updateProductSyncTest_productScoreChange() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    setProductAttributeResponses(productDetailResponse);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false))
        .thenReturn(this.productSyncTobeUpdated);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()))).thenReturn(productAndItemsVO);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productSyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());

    verify(this.saveOperationService).saveProduct(productSyncTobeUpdated);
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    assertNotNull(product);
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  private void setProductAttributeResponses(ProductDetailResponse productDetailResponse) {
    productDetailResponse.setProductAttributeResponses(new ArrayList<>());
    ProductAttributeResponse productAttributeResponse = new ProductAttributeResponse();
    AttributeResponse attributeResponse = new AttributeResponse();
    ProductAttributeValueResponse productAttributeValueResponse = new ProductAttributeValueResponse();

    attributeResponse.setAttributeCode(ATTRIBUTE_CODE);
    attributeResponse.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE.name());
    attributeResponse.setName(ATTRIBUTE_CODE);
    productAttributeValueResponse.setDescriptiveAttributeValue(DESCRIPTIVE_ATTRIBUTE_VALUE);
    productAttributeValueResponse.setDescriptiveAttributeValueType(
        com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.SINGLE);

    productAttributeResponse.setAttribute(attributeResponse);
    productAttributeResponse.setProductAttributeValues(Collections.singletonList(productAttributeValueResponse));
    productDetailResponse.getProductAttributeResponses().add(productAttributeResponse);

    ProductAttributeResponse productAttributeResponse1 = new ProductAttributeResponse();
    AttributeResponse attributeResponse1 = new AttributeResponse();
    ProductAttributeValueResponse productAttributeValueResponse1 = new ProductAttributeValueResponse();
    PredefinedAllowedAttributeValueResponse predefinedAllowedAttributeValueResponse =
        new PredefinedAllowedAttributeValueResponse();

    attributeResponse1.setAttributeCode(ATTRIBUTE_CODE_1);
    attributeResponse1.setAttributeType(MasterDataAttributeType.PREDEFINED_ATTRIBUTE.name());
    attributeResponse1.setName(ATTRIBUTE_CODE_1);
    predefinedAllowedAttributeValueResponse.setValue(PREDEFINED_ATTRIBUTE_VALUE);
    productAttributeValueResponse1.setPredefinedAllowedAttributeValue(predefinedAllowedAttributeValueResponse);
    productAttributeValueResponse1.setDescriptiveAttributeValueType(
        com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.PREDEFINED);

    productAttributeResponse1.setAttribute(attributeResponse1);
    productAttributeResponse1.setProductAttributeValues(Collections.singletonList(productAttributeValueResponse1));
    productDetailResponse.getProductAttributeResponses().add(productAttributeResponse1);

    ProductAttributeResponse productAttributeResponse2 = new ProductAttributeResponse();
    AttributeResponse attributeResponse2 = new AttributeResponse();
    ProductAttributeValueResponse productAttributeValueResponse2 = new ProductAttributeValueResponse();
    AllowedAttributeValueResponse allowedAttributeValueResponse = new AllowedAttributeValueResponse();

    attributeResponse2.setAttributeCode(ATTRIBUTE_CODE2);
    attributeResponse2.setAttributeType(MasterDataAttributeType.DEFINING_ATTRIBUTE.name());
    attributeResponse2.setName(ATTRIBUTE_CODE2);
    allowedAttributeValueResponse.setValue(ALLOWED_ATTRIBUTE_VALUE);
    productAttributeValueResponse2.setAllowedAttributeValue(allowedAttributeValueResponse);
    productAttributeValueResponse2.setDescriptiveAttributeValueType(
        com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.NONE);

    productAttributeResponse2.setAttribute(attributeResponse2);
    productAttributeResponse2.setProductAttributeValues(Collections.singletonList(productAttributeValueResponse2));
    productDetailResponse.getProductAttributeResponses().add(productAttributeResponse2);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeTest() throws Exception {
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setVariantCreatingScore(0);
    productScoreVo.setTotalScore(80.0);
    Image imageFinal = new Image();
    imageFinal.setMarkForDelete(FALSE);
    imageFinal.setMainImages(TRUE);
    imageFinal.setActive(TRUE);
    imageFinal.setLocationPath(LOCATION_PATH);
    imageFinal.setSequence(1);
    imageFinal.setCommonImage(TRUE);
    Image imageResized = new Image();
    imageResized.setMarkForDelete(TRUE);
    imageResized.setMainImages(TRUE);
    imageResized.setActive(FALSE);
    imageResized.setLocationPath(LOCATION_PATH);
    imageResized.setSequence(2);
    imageResized.setCommonImage(TRUE);
    productItemResponse.setImages(Arrays.asList(imageFinal,imageResized));
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    List<ProductAndItemsVO> productAndItemsVOS =
        this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false,
            null, false, false, null, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service, times(1))
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());

  }

  @Test
  public void updateProductScoreOnMasterDataChangeTest_videoAdded() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
        VIDEO_URL_CLIENT_ID);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setVariantCreatingScore(0);
    productScoreVo.setTotalScore(80.0);
    Image imageFinal = new Image();
    imageFinal.setMarkForDelete(FALSE);
    imageFinal.setMainImages(TRUE);
    imageFinal.setActive(TRUE);
    imageFinal.setLocationPath(LOCATION_PATH);
    imageFinal.setSequence(1);
    imageFinal.setCommonImage(TRUE);
    Image imageResized = new Image();
    imageResized.setMarkForDelete(TRUE);
    imageResized.setMainImages(TRUE);
    imageResized.setActive(FALSE);
    imageResized.setLocationPath(LOCATION_PATH);
    imageResized.setSequence(2);
    imageResized.setCommonImage(TRUE);
    productItemResponse.setImages(Arrays.asList(imageFinal, imageResized));
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    productDetailResponse.setVideoDTO(
        VideoDTO.builder().videoId(VIDEO_ID_1).videoName(VIDEO_NAME_1).build());
    VideoCompressionEventModel videoCompressionEventModel =
      VideoCompressionEventModel.builder().clientId(VIDEO_URL_CLIENT_ID).videoId(VIDEO_ID_1)
        .ownerId(MERCHANT_CODE).additionalFields(
          Map.of(Constants.PRODUCT_CODE, PRODUCT_CODE, Constants.PRODUCT_SKU, PRODUCT_SKU_SYNC))
        .build();

    AuditTrailDto auditTrailDto = new AuditTrailDto();
    auditTrailDto.setNewValue(VIDEO_NAME_1);
    auditTrailDto.setOldValue(Constants.HYPHEN);
    auditTrailDto.setProductSku(productSync.getProductSku());
    auditTrailDto.setActionKey(Constants.VIDEO_ADD_ACTION_KEY);
    auditTrailDto.setPickupPointCode(Constants.HYPHEN);
    auditTrailDto.setName(productSync.getProductName());
    auditTrailDto.setBusinessPartnerCode(productSync.getMerchantCode());

    AuditTrailListResponse auditTrailListResponse = new AuditTrailListResponse();
    auditTrailListResponse.setAccessChannel(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setChangedBy(null);
    auditTrailListResponse.setClientId(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setRequestId(Constants.DEFAULT_REQUEST_ID);
    auditTrailListResponse.setUpdateDirectly(true);
    auditTrailListResponse.setUpdateDirectlyToDB(true);
    auditTrailListResponse.setAuditTrailResponseList(Collections.singletonList(auditTrailDto));

    Mockito.when(
        this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
            Constants.DEFAULT_USERNAME, PRODUCT_CODE)).thenReturn(productDetailResponse);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(
            this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
                eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(
            saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    List<ProductAndItemsVO> productAndItemsVOS =
        this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false,
            null, false, false, null, null);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class),
        anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1)).getProductScoreByProductScoreRequest(
        any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service, times(1)).saveProductScoreHistoryL3(eq(STORE_ID),
        anyString(), any(ProductScore.class), any(ProductScore.class));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(this.saveAndPublishService).publishVideoCompressionEvent(eq(videoCompressionEventModel));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(kafkaProducer).send(eq(ProductDomainEventName.PRODUCT_SKU_UPDATE_HISTORY),
        eq(auditTrailListResponse));
    verifyNoMoreInteractions(kafkaProducer);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeTest_videoUpdated() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
        VIDEO_URL_CLIENT_ID);
    List<Product> productList = new ArrayList<>();
    Video video1 = new Video();
    video1.setVideoId(VIDEO_ID_1);
    video1.setVideoName(VIDEO_NAME_1);
    productSync.setVideo(video1);
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setVariantCreatingScore(0);
    productScoreVo.setTotalScore(80.0);
    Image imageFinal = new Image();
    imageFinal.setMarkForDelete(FALSE);
    imageFinal.setMainImages(TRUE);
    imageFinal.setActive(TRUE);
    imageFinal.setLocationPath(LOCATION_PATH);
    imageFinal.setSequence(1);
    imageFinal.setCommonImage(TRUE);
    Image imageResized = new Image();
    imageResized.setMarkForDelete(TRUE);
    imageResized.setMainImages(TRUE);
    imageResized.setActive(FALSE);
    imageResized.setLocationPath(LOCATION_PATH);
    imageResized.setSequence(2);
    imageResized.setCommonImage(TRUE);
    productItemResponse.setImages(Arrays.asList(imageFinal, imageResized));
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    productDetailResponse.setVideoDTO(
        VideoDTO.builder().videoId(VIDEO_ID_2).videoName(VIDEO_NAME_2).build());
    VideoCompressionEventModel videoCompressionEventModel =
      VideoCompressionEventModel.builder().clientId(VIDEO_URL_CLIENT_ID).videoId(VIDEO_ID_2)
        .oldVideoId(VIDEO_ID_1).ownerId(MERCHANT_CODE).additionalFields(
          Map.of(Constants.PRODUCT_CODE, PRODUCT_CODE, Constants.PRODUCT_SKU, PRODUCT_SKU_SYNC)).build();

    AuditTrailDto auditTrailDto = new AuditTrailDto();
    auditTrailDto.setNewValue(VIDEO_NAME_2);
    auditTrailDto.setOldValue(VIDEO_NAME_1);
    auditTrailDto.setProductSku(productSync.getProductSku());
    auditTrailDto.setActionKey(Constants.VIDEO_UPDATE_ACTION_KEY);
    auditTrailDto.setPickupPointCode(Constants.HYPHEN);
    auditTrailDto.setName(productSync.getProductName());
    auditTrailDto.setBusinessPartnerCode(productSync.getMerchantCode());

    AuditTrailListResponse auditTrailListResponse = new AuditTrailListResponse();
    auditTrailListResponse.setAccessChannel(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setChangedBy(null);
    auditTrailListResponse.setClientId(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setRequestId(Constants.DEFAULT_REQUEST_ID);
    auditTrailListResponse.setUpdateDirectly(true);
    auditTrailListResponse.setUpdateDirectlyToDB(true);
    auditTrailListResponse.setAuditTrailResponseList(Collections.singletonList(auditTrailDto));

    Mockito.when(
        this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
            Constants.DEFAULT_USERNAME, PRODUCT_CODE)).thenReturn(productDetailResponse);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(
            this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
                eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(
            saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    List<ProductAndItemsVO> productAndItemsVOS =
        this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false,
            null, false, false, null, null);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class),
        anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1)).getProductScoreByProductScoreRequest(
        any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service, times(1)).saveProductScoreHistoryL3(eq(STORE_ID),
        anyString(), any(ProductScore.class), any(ProductScore.class));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(this.saveAndPublishService).publishVideoCompressionEvent(eq(videoCompressionEventModel));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(kafkaProducer).send(eq(ProductDomainEventName.PRODUCT_SKU_UPDATE_HISTORY),
        eq(auditTrailListResponse));
    verifyNoMoreInteractions(kafkaProducer);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeTest_videoDeleted() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
        VIDEO_URL_CLIENT_ID);
    List<Product> productList = new ArrayList<>();
    Video video1 = new Video();
    video1.setVideoId(VIDEO_ID_1);
    video1.setVideoName(VIDEO_NAME_1);
    productSync.setVideo(video1);
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setVariantCreatingScore(0);
    productScoreVo.setTotalScore(80.0);
    Image imageFinal = new Image();
    imageFinal.setMarkForDelete(FALSE);
    imageFinal.setMainImages(TRUE);
    imageFinal.setActive(TRUE);
    imageFinal.setLocationPath(LOCATION_PATH);
    imageFinal.setSequence(1);
    imageFinal.setCommonImage(TRUE);
    Image imageResized = new Image();
    imageResized.setMarkForDelete(TRUE);
    imageResized.setMainImages(TRUE);
    imageResized.setActive(FALSE);
    imageResized.setLocationPath(LOCATION_PATH);
    imageResized.setSequence(2);
    imageResized.setCommonImage(TRUE);
    productItemResponse.setImages(Arrays.asList(imageFinal, imageResized));
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    VideoCompressionEventModel videoCompressionEventModel =
      VideoCompressionEventModel.builder().clientId(VIDEO_URL_CLIENT_ID).videoId(VIDEO_ID_1)
        .ownerId(MERCHANT_CODE).markForDelete(true).additionalFields(
          Map.of(Constants.PRODUCT_CODE, PRODUCT_CODE, Constants.PRODUCT_SKU, PRODUCT_SKU_SYNC))
        .build();

    AuditTrailDto auditTrailDto = new AuditTrailDto();
    auditTrailDto.setNewValue(Constants.HYPHEN);
    auditTrailDto.setOldValue(VIDEO_NAME_1);
    auditTrailDto.setProductSku(productSync.getProductSku());
    auditTrailDto.setActionKey(Constants.VIDEO_DELETE_ACTION_KEY);
    auditTrailDto.setPickupPointCode(Constants.HYPHEN);
    auditTrailDto.setName(productSync.getProductName());
    auditTrailDto.setBusinessPartnerCode(productSync.getMerchantCode());

    AuditTrailListResponse auditTrailListResponse = new AuditTrailListResponse();
    auditTrailListResponse.setAccessChannel(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setChangedBy(null);
    auditTrailListResponse.setClientId(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setRequestId(Constants.DEFAULT_REQUEST_ID);
    auditTrailListResponse.setUpdateDirectly(true);
    auditTrailListResponse.setUpdateDirectlyToDB(true);
    auditTrailListResponse.setAuditTrailResponseList(Collections.singletonList(auditTrailDto));

    Mockito.when(
        this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
            Constants.DEFAULT_USERNAME, PRODUCT_CODE)).thenReturn(productDetailResponse);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(
            this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
                eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(
            saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    List<ProductAndItemsVO> productAndItemsVOS =
        this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false,
            null, false, false, null, null);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class),
        anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1)).getProductScoreByProductScoreRequest(
        any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service, times(1)).saveProductScoreHistoryL3(eq(STORE_ID),
        anyString(), any(ProductScore.class), any(ProductScore.class));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(this.saveAndPublishService).publishVideoCompressionEvent(eq(videoCompressionEventModel));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(kafkaProducer).send(eq(ProductDomainEventName.PRODUCT_SKU_UPDATE_HISTORY),
        eq(auditTrailListResponse));
    verifyNoMoreInteractions(kafkaProducer);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeTest_videoNotUpdated() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
        VIDEO_URL_CLIENT_ID);
    List<Product> productList = new ArrayList<>();
    Video video1 = new Video();
    video1.setVideoId(VIDEO_ID_1);
    productSync.setVideo(video1);
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setVariantCreatingScore(0);
    productScoreVo.setTotalScore(80.0);
    Image imageFinal = new Image();
    imageFinal.setMarkForDelete(FALSE);
    imageFinal.setMainImages(TRUE);
    imageFinal.setActive(TRUE);
    imageFinal.setLocationPath(LOCATION_PATH);
    imageFinal.setSequence(1);
    imageFinal.setCommonImage(TRUE);
    Image imageResized = new Image();
    imageResized.setMarkForDelete(TRUE);
    imageResized.setMainImages(TRUE);
    imageResized.setActive(FALSE);
    imageResized.setLocationPath(LOCATION_PATH);
    imageResized.setSequence(2);
    imageResized.setCommonImage(TRUE);
    productItemResponse.setImages(Arrays.asList(imageFinal, imageResized));
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    productDetailResponse.setVideoDTO(VideoDTO.builder().videoId(VIDEO_ID_1).build());
    Mockito.when(
        this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
            Constants.DEFAULT_USERNAME, PRODUCT_CODE)).thenReturn(productDetailResponse);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(
            this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
                eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(
            saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    List<ProductAndItemsVO> productAndItemsVOS =
        this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false,
            null, false, false, null, null);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class),
        anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1)).getProductScoreByProductScoreRequest(
        any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service, times(1)).saveProductScoreHistoryL3(eq(STORE_ID),
        anyString(), any(ProductScore.class), any(ProductScore.class));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verifyNoMoreInteractions(kafkaProducer);
  }


  @Test
  public void updateProductScoreOnMasterDataChangeNoChangeInMasterDataTest() throws Exception {
    List<Product> productList = new ArrayList<>();
    productSync.setProductScore(null);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(1))
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
  }

  @Test
  public void updateProductScoreOnMasterDataChangeNoChangeTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", false);
    List<Product> productList = new ArrayList<>();
    ProductScore productScore = new ProductScore();
    productScore.setVariantCreatingScore(5.0);
    productScore.setTotalScore(5.0);
    productSync.setProductScore(productScore);
    productSync.setUrl(YOUTUBE_INVALID_URL);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setDescription(DESCRIPTION.getBytes());
    productDetailResponse.setUrl(YOUTUBE_URL);
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setShippingWeight(10.0);
    productDetailResponse.setUrl(StringUtils.EMPTY);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(new ProductScoreVo());
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient)
      .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreUtil, times(1))
      .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
      any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreHistoryL3Service, times(1))
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
  }

  @Test
  public void updateProductScoreOnMasterDataChangeNameTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", false);
    ReflectionTestUtils.setField(productServiceImpl, "publishProductChangeOnBrandOrNameChangeGenerateProductScore",
        true);
    List<Product> productList = new ArrayList<>();
    ProductScore productScore = new ProductScore();
    productScore.setVariantCreatingScore(5.0);
    productScore.setTotalScore(5.0);
    productSync.setProductScore(productScore);
    productSync.setUrl(StringUtils.EMPTY);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productSync.setProductName(PRODUCT_CODE);
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setDescription(DESCRIPTION.getBytes());
    productDetailResponse.setUrl(StringUtils.EMPTY);
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setShippingWeight(10.0);
    productDetailResponse.setUrl(StringUtils.EMPTY);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE)).thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true", StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE, String.valueOf(5.0),
            StringUtils.EMPTY);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH)).thenReturn(systemParameter);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY)).thenReturn(systemParameter1);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE)).thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE)).thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(new ProductScoreVo());
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class), any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreUtil, times(1)).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.saveAndPublishService).publishProduct(any(Product.class),
        eq(Collections.singletonList(ProductChangeEventType.PRODUCT_NAME_CHANGE)));
  }

  @Test
  public void updateProductScoreOnMasterDataChangeNameTest2() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", false);
    ReflectionTestUtils.setField(productServiceImpl, "publishProductChangeOnBrandOrNameChangeGenerateProductScore",
        true);
    List<Product> productList = new ArrayList<>();
    ProductScore productScore = new ProductScore();
    productScore.setVariantCreatingScore(5.0);
    productScore.setTotalScore(5.0);
    productSync.setProductScore(productScore);
    productSync.setUrl(StringUtils.EMPTY);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setDescription(DESCRIPTION.getBytes());
    productDetailResponse.setUrl(StringUtils.EMPTY);
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setShippingWeight(10.0);
    productDetailResponse.setUrl(StringUtils.EMPTY);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE)).thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true", StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE, String.valueOf(5.0),
            StringUtils.EMPTY);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH)).thenReturn(systemParameter);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY)).thenReturn(systemParameter1);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE)).thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE)).thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(new ProductScoreVo());
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class), any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreUtil, times(1)).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
  }

  @Test
  public void updateProductScoreOnMasterDataChangeBrandTest2() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", false);
    ReflectionTestUtils.setField(productServiceImpl, "publishProductChangeOnBrandOrNameChangeGenerateProductScore",
        true);
    List<Product> productList = new ArrayList<>();
    ProductScore productScore = new ProductScore();
    productScore.setVariantCreatingScore(5.0);
    productScore.setTotalScore(5.0);
    productSync.setProductScore(productScore);
    productSync.setUrl(StringUtils.EMPTY);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productSync.setBrand(BRAND_LOGO_URL);
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setDescription(DESCRIPTION.getBytes());
    productDetailResponse.setUrl(StringUtils.EMPTY);
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setShippingWeight(10.0);
    productDetailResponse.setUrl(StringUtils.EMPTY);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE)).thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true", StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE, String.valueOf(5.0),
            StringUtils.EMPTY);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH)).thenReturn(systemParameter);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY)).thenReturn(systemParameter1);
    Mockito.when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE)).thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE)).thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(new ProductScoreVo());
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class), any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreUtil, times(1)).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.saveAndPublishService).publishProduct(any(Product.class),
        eq(Collections.singletonList(ProductChangeEventType.BRAND_CHANGE)));
  }

  @Test
  public void updateProductScoreOnMasterDataChangeNoChangeDoneTest() throws Exception {
    List<Product> productList = new ArrayList<>();
    ProductScore productScore = new ProductScore();
    productScore.setVariantCreatingScore(5.0);
    productScore.setTotalScore(5.0);
    productSync.setProductScore(productScore);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(StringUtils.EMPTY);
    productDetailResponse.setDescription(DESCRIPTION.getBytes());
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setShippingWeight(10.0);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
      .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
      new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
        StringUtils.EMPTY);
    SystemParameter systemParameter1 =
      new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
        String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
      new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
        String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
      .thenReturn(systemParameter);
    Mockito.when(systemParameterService
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
      .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
      .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
      .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
      .thenReturn(new ProductScoreVo());
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
      .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
      .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
      null, null);
    verify(this.productCategoryBaseClient)
      .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreUtil, times(1))
      .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
      any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
  }

  @Test
  public void updateProductScoreOnMasterDataChangeYouTubeUrlUpdateTest() throws Exception {
    List<Product> productList = new ArrayList<>();
    ProductScore productScore = new ProductScore();
    productScore.setVariantCreatingScore(5.0);
    productScore.setTotalScore(5.0);
    productSync.setProductScore(productScore);
    productSync.setUrl(null);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    productDetailResponse.setDescription(DESCRIPTION.getBytes());
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setShippingWeight(10.0);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
      .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
      new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
        StringUtils.EMPTY);
    SystemParameter systemParameter1 =
      new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
        String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
      new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
        String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
      .thenReturn(systemParameter);
    Mockito.when(systemParameterService
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
      .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
      .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
      .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
      .thenReturn(new ProductScoreVo());
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
      .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false,
      null,
      false, false,
      null, null);
    verify(this.productCategoryBaseClient)
      .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreUtil, times(1))
      .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
      any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
  }

  @Test
  public void updateProductScoreOnMasterDataChangeMissingDimensionTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "instoreNewFlowEnabled", true);
    List<Product> productList = new ArrayList<>();
    ProductScore productScore = new ProductScore();
    productScore.setVariantCreatingScore(5.0);
    productScore.setTotalScore(5.0);
    productSync.setProductScore(productScore);
    productSync.setOff2OnChannelActive(true);
    productSync.setB2cActivated(false);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setDescription(new byte[0]);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(new ProductScoreVo());
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(1))
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
  }

  @Test
  public void updateProductScoreOnMasterDataChangeSyncFalseTest() throws Exception {
    List<Product> productList = new ArrayList<>();
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeWithValidateVideoUrlTrueTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "updateMasterDataDetailsForUnsyncProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", true);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productSync.setMasterDataProduct(masterDataProduct);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(
            this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(), eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, true, null, false, false, null,
        null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(3)).videos();
    Mockito.verify(list).execute();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(2))
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(2)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(2))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    Assertions.assertEquals(productList.get(1).getProductScore().getVariantCreatingScore(), 10.0, 0);
    verify(this.saveOperationService, times(2)).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService, times(2)).findCacheableByStoreIdAndProductSku(any(), any());

  }

  @Test
  public void updateProductScoreOnMasterDataChangeWithProductSkuTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", true);
    List<Product> productList = new ArrayList<>();
    productUnsync.setProductCode(null);
    productUnsync.setProductSku(PRODUCT_SKU);
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    MasterCatalog masterCatalog = new MasterCatalog();
    masterCatalog.setCategory(category);
    masterDataProduct.setMasterCatalog(masterCatalog);
    masterDataProduct.setUrl(YOUTUBE_URL);
    productUnsync.setMasterDataProduct(masterDataProduct);
    productList.add(productUnsync);
    item.setProductSku(PRODUCT_SKU);
    item.setSynchronized(false);
    Image imageFinal = new Image();
    imageFinal.setMarkForDelete(FALSE);
    imageFinal.setMainImages(TRUE);
    imageFinal.setActive(TRUE);
    imageFinal.setLocationPath(LOCATION_PATH);
    imageFinal.setSequence(1);
    imageFinal.setCommonImage(TRUE);
    Image imageResized = new Image();
    imageResized.setMarkForDelete(TRUE);
    imageResized.setMainImages(TRUE);
    imageResized.setActive(FALSE);
    imageResized.setLocationPath(LOCATION_PATH);
    imageResized.setSequence(2);
    imageResized.setCommonImage(TRUE);
    List<Image> images = new ArrayList<>();
    images.add(imageResized);
    images.add(imageFinal);
    productItemResponse.setImages(images);
    MasterDataItem masterDataItem = new MasterDataItem();
    masterDataItem.setUpcCode(StringUtils.EMPTY);
    MasterDataItemImage masterDataItemImage = new MasterDataItemImage();
    masterDataItemImage.setLocationPath(LOCATION_PATH);
    masterDataItem.setMasterDataItemImages(Arrays.asList(masterDataItemImage));
    item.setMasterDataItem(masterDataItem);
    productScoreVo.setTotalScore(80.0);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productSync.setMasterDataProduct(masterDataProduct);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productUnsync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(productUnsync);
    Mockito.when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, null, true, PRODUCT_SKU, false, false, null,
        null);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(3)).videos();
    Mockito.verify(list, times(1)).execute();
    verify(this.productScoreHistoryL3Service, times(1))
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeWithProductSkuSyncTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", false);
    List<Product> productList = new ArrayList<>();
    productUnsync.setProductCode(PRODUCT_CODE);
    productUnsync.setProductSku(PRODUCT_SKU);
    productUnsync.setSynchronized(true);
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    MasterCatalog masterCatalog = new MasterCatalog();
    masterCatalog.setCategory(category);
    masterDataProduct.setMasterCatalog(masterCatalog);
    masterDataProduct.setUrl(YOUTUBE_URL);
    productUnsync.setMasterDataProduct(masterDataProduct);
    productList.add(productUnsync);
    item.setProductSku(PRODUCT_SKU);
    item.setSynchronized(false);
    MasterDataItem masterDataItem = new MasterDataItem();
    masterDataItem.setUpcCode(StringUtils.EMPTY);
    MasterDataItemImage masterDataItemImage = new MasterDataItemImage();
    masterDataItemImage.setLocationPath(LOCATION_PATH);
    masterDataItem.setMasterDataItemImages(Arrays.asList(masterDataItemImage));
    item.setMasterDataItem(masterDataItem);
    productScoreVo.setTotalScore(80.0);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productUnsync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(productUnsync);
    Mockito.when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, null, true, PRODUCT_SKU, false, false, null,
        null);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productScoreHistoryL3Service, times(1))
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(this.cacheItemHelperService, times(2)).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeBakfillingFalseProductScoreNull() throws Exception {
    List<Product> productList = new ArrayList<>();
    productSync.setProductScore(null);
    productSync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(1))));
    productList.add(productSync);
    productList.add(productUnsync);
    productUnsync.setCreatedDate(Date.from(Instant.now().minus(Duration.ofDays(-1))));
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, false, null, false, false,
        null, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(1))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(1))
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(1)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(1))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    Assertions.assertEquals(productList.get(0).getProductScore().getVariantCreatingScore(), 5.0, 0);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
  }

  @Test
  public void updateProductScoreOnMasterDataChangeEmptyProducts() throws Exception {
    List<Product> productList = new ArrayList<>();
    productUnsync.setProductCode(null);
    productUnsync.setProductSku(PRODUCT_SKU);
    MasterDataProduct masterDataProduct = new MasterDataProduct();
    MasterCatalog masterCatalog = new MasterCatalog();
    masterCatalog.setCategory(category);
    masterDataProduct.setMasterCatalog(masterCatalog);
    masterDataProduct.setUrl(YOUTUBE_URL);
    productUnsync.setMasterDataProduct(masterDataProduct);
    productList.add(productUnsync);
    item.setProductSku(PRODUCT_SKU);
    item.setSynchronized(false);
    MasterDataItem masterDataItem = new MasterDataItem();
    masterDataItem.setUpcCode(StringUtils.EMPTY);
    MasterDataItemImage masterDataItemImage = new MasterDataItemImage();
    masterDataItemImage.setLocationPath(LOCATION_PATH);
    masterDataItem.setMasterDataItemImages(Arrays.asList(masterDataItemImage));
    item.setMasterDataItem(masterDataItem);
    productScoreVo.setTotalScore(80.0);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(null);
    Mockito.when(itemService.getItemsByProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, null, true, PRODUCT_SKU, false, false, null,
        null);
    verify(this.productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void updateProductScoreOnMasterDataChangeWithValidateVideoUrlTrueAndInvalidYoutubeUrlTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", true);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_INVALID_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    item.setItemCode(SKU_CODE);
    Image imageFinal = new Image();
    imageFinal.setMarkForDelete(FALSE);
    imageFinal.setMainImages(TRUE);
    imageFinal.setActive(TRUE);
    imageFinal.setLocationPath(LOCATION_PATH);
    imageFinal.setSequence(1);
    imageFinal.setCommonImage(TRUE);
    Image imageResized = new Image();
    imageResized.setMarkForDelete(TRUE);
    imageResized.setMainImages(TRUE);
    imageResized.setActive(FALSE);
    imageResized.setLocationPath(LOCATION_PATH);
    imageResized.setSequence(2);
    imageResized.setCommonImage(TRUE);
    List<Image> images = new ArrayList<>();
    images.add(imageResized);
    images.add(imageFinal);
    productItemResponse.setImages(images);
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setProductItemAttributeValueResponses(new ArrayList<>());
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    this.productServiceImpl.updateProductScoreOnMasterDataChange(STORE_ID, PRODUCT_CODE, true, null, false, false, null,
        null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(2))
        .saveProductScoreHistoryL3(eq(STORE_ID), any(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(2)).saveProductWithoutUpdatingSolr(any(Product.class), any(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(2)).getProductScoreByProductScoreRequest(
        any(ProductScoreRequest.class));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());
  }

  @Test
  public void updateProductSyncTest_productScoreChange_sameSpecialAttributes() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    setProductAttributeResponses(productDetailResponse);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false))
        .thenReturn(this.productSyncTobeUpdated);
    when(this.saveOperationService.saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()))).thenReturn(productAndItemsVO);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productSyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(productSyncTobeUpdated);
    assertNotNull(product);
  }

  @Test
  public void updateProductSyncTest_specialAttributesNotUpdatedButProductScoreUpdatesTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "productScoreUpdateWithoutSpecialAttributesEnabled", true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    setProductAttributeResponses(productDetailResponse);
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false)).thenReturn(this.productSyncTobeUpdated);
    when(this.saveOperationService.saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()))).thenReturn(
        productAndItemsVO);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    Product product =
        this.productServiceImpl.updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            this.productSyncUpdated, false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(productSyncTobeUpdated);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode("request-id", Constants.DEFAULT_USERNAME,
        PRODUCT_CODE);
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_productScoreChange_emptyProductCode() throws Exception {
    oldProductScore.setEanUpcScore(1.0);
    this.productUnSyncTobeUpdated.setProductScore(oldProductScore);
    this.productUnSyncTobeUpdated.setProductCode(null);
    this.productUnsyncUpdated.getMasterDataProduct().setDescription(DESCRIPTION);
    this.productUnSyncTobeUpdated.getMasterDataProduct()
        .setMasterCatalog(new MasterCatalog(CATALOG_CODE, new Category(CATEGORY_CODE, CATEGORY_CODE)));

    setMasterDataAttributes(this.productUnsyncUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE,
        PREDEFINED_ATTRIBUTE_VALUE, ALLOWED_ATTRIBUTE_VALUE);
    setMasterDataAttributes(this.productUnSyncTobeUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE_2,
        PREDEFINED_ATTRIBUTE_VALUE_2, ALLOWED_ATTRIBUTE_VALUE_1);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    when(this.itemService
        .findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, productUnSyncTobeUpdated.getProductSku()))
        .thenReturn(Collections.singletonList(item));
    when(this.productHelperService
        .modifyItemNames(Collections.singletonList(item),
            ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME))
        .thenReturn(Collections.singletonList(item));
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(Collections.singletonList(item),
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, Collections.singletonList(item)));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    assertNotNull(product);
  }

  @Test
  public void generateShippingWeightTest() {
    Mockito.when(productCategoryBaseClient.generateShippingWeight(STORE_ID, CATEGORY_CODE, 10, 10, 10, 10))
        .thenReturn(10.0);
    double weight = productServiceImpl.generateShippingWeight(STORE_ID, CATEGORY_CODE, 10, 10, 10, 10);
    Mockito.verify(productCategoryBaseClient).generateShippingWeight(STORE_ID, CATEGORY_CODE, 10, 10, 10, 10);
    Assertions.assertEquals(10.0, weight, 0);
  }

  @Test
  public void generateProductScoreByProductSkuTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", true);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    item.setItemCode(SKU_CODE);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, Arrays.asList(item)));
    productItemResponse.setSkuCode(SKU_CODE);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    productServiceImpl.generateProductScoreByProductSku(STORE_ID, null, PRODUCT_CODE, REQUEST_ID,
        USERNAME, false, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(3)).videos();
    Mockito.verify(list).execute();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(2))
        .saveProductScoreHistoryL3(eq(STORE_ID), any(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(2)).saveProductWithoutUpdatingSolr(any(), any(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(2))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productAndItemSolrIndexerService, times(2))
        .updateProductAndItemDetailsInSolr(any(), any(), eq(true));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());

  }

  @Test
  public void generateProductScoreByProductSkuTestWithUpdateCategory() throws Exception {
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    productDetailResponse.setBrand(NEW_BRAND);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    item.setItemCode(SKU_CODE);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, Arrays.asList(item)));
    productItemResponse.setSkuCode(SKU_CODE);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(this.productCategoryBaseClient
            .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID,
                Constants.DEFAULT_USERNAME, product.getProductCode(), true))
        .thenReturn(new GdnRestSingleResponse<>(null, null, true, productSalesCategoryMappingResponse, REQUEST_ID));
    Mockito.when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, product.getProductCode()))
        .thenReturn(productDetailResponse);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    productServiceImpl.generateProductScoreByProductSku(STORE_ID, null, PRODUCT_CODE, REQUEST_ID,
        USERNAME, true, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(2))
        .saveProductScoreHistoryL3(eq(STORE_ID), any(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(2)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(2))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productAndItemSolrIndexerService, times(2))
        .updateProductAndItemDetailsInSolr(any(), any(), eq(true));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    Mockito.verify(this.productCategoryBaseClient)
        .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID,
            Constants.DEFAULT_USERNAME, product.getProductCode(), true);
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
  }

  @Test
  public void generateProductScoreByProductSkuTestWithBrandChange() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "publishProductChangeOnBrandOrNameChangeGenerateProductScore", true);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    productDetailResponse.setBrand(NEW_BRAND);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    item.setItemCode(SKU_CODE);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, Arrays.asList(item)));
    productItemResponse.setSkuCode(SKU_CODE);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(this.productCategoryBaseClient
            .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID,
                Constants.DEFAULT_USERNAME, product.getProductCode(), true))
        .thenReturn(new GdnRestSingleResponse<>(null, null, true, productSalesCategoryMappingResponse, REQUEST_ID));
    Mockito.when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, product.getProductCode()))
        .thenReturn(productDetailResponse);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    productServiceImpl.generateProductScoreByProductSku(STORE_ID, null, PRODUCT_CODE, REQUEST_ID,
        USERNAME, true, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(2))
        .saveProductScoreHistoryL3(eq(STORE_ID), any(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(2)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(2))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productAndItemSolrIndexerService, times(2))
        .updateProductAndItemDetailsInSolr(any(), any(), eq(true));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    Mockito.verify(this.productCategoryBaseClient)
        .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID,
            Constants.DEFAULT_USERNAME, product.getProductCode(), true);
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
  }

  @Test
  public void generateProductScoreByProductSkuWithUpdateCategoryAndSyncTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", false);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    item.setItemCode(SKU_CODE);
    productSync.setCurationStatus(CurationStatus.APPROVED);
    productUnsync.setCurationStatus(CurationStatus.APPROVED);
    productDetailResponse.getProductCategoryResponses().get(0).getCategory().setHalalCategory(true);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, Arrays.asList(item)));
    productItemResponse.setSkuCode(SKU_CODE);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(this.productCategoryBaseClient
            .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, product.getProductCode(), false))
        .thenReturn(new GdnRestSingleResponse<>(null, null, true, productSalesCategoryMappingResponse, REQUEST_ID));
    Mockito.when(
            this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
                ProductServiceImplTest.REQUEST_ID, product.getProductCode()))
        .thenReturn(productDetailResponse);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenReturn(productDetailResponse);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
            any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    productServiceImpl.generateProductScoreByProductSku(STORE_ID, null, PRODUCT_CODE, REQUEST_ID,
        USERNAME, true, null);
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    Mockito.verify(systemParameterService, times(2))
        .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    Mockito.verify(youTube, Mockito.times(2)).videos();
    verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    verify(this.productScoreHistoryL3Service, times(2))
        .saveProductScoreHistoryL3(eq(STORE_ID), any(), any(ProductScore.class),
            any(ProductScore.class));
    verify(this.saveOperationService, times(2)).saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productScoreUtil, times(2))
        .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productAndItemSolrIndexerService, times(2))
        .updateProductAndItemDetailsInSolr(any(), any(), eq(true));
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    Mockito.verify(this.productCategoryBaseClient)
        .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, product.getProductCode(), false);
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());

  }

  @Test
  public void generateProductScoreByProductSkuWithUpdateCategoryAndSyncInvalidResponseTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", false);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    item.setItemCode(SKU_CODE);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, Arrays.asList(item)));
    productItemResponse.setSkuCode(SKU_CODE);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(this.productCategoryBaseClient
            .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, product.getProductCode(), true))
        .thenReturn(new GdnRestSingleResponse<>(null, null, false, productSalesCategoryMappingResponse, REQUEST_ID));
    Mockito.when(
            this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
                ProductServiceImplTest.REQUEST_ID, product.getProductCode()))
        .thenReturn(productDetailResponse);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenReturn(productDetailResponse);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(false, false));    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
            any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.generateProductScoreByProductSku(STORE_ID, null, PRODUCT_CODE, REQUEST_ID, USERNAME, true,
          null));
    }
    finally {
      verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
      Mockito.verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
      Mockito.verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
      Mockito.verify(youTube, Mockito.times(2)).videos();
      verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
      verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
      verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
      Mockito.verify(this.productCategoryBaseClient)
          .getSalesCategoryMappingByProductCode(Constants.DEFAULT_STORE_ID, Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, product.getProductCode(), true);
    }
  }

  @Test
  public void generateProductScoreByProductSkuWithException() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "validateYouTubeUrlInXProduct", true);
    List<Product> productList = new ArrayList<>();
    productList.add(productSync);
    productList.add(productUnsync);
    productScoreVo.setTotalScore(80.0);
    productDetailResponse.setUrl(YOUTUBE_URL);
    this.productUnsync.getMasterDataProduct().setDescription(DESCRIPTION);
    item.setItemCode(SKU_CODE);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, Arrays.asList(item)));
    productItemResponse.setSkuCode(SKU_CODE);
    productDetailResponse.setProductItemResponses(Collections.singleton(productItemResponse));
    Mockito.when(this.productCategoryBaseClient
            .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    SystemParameter systemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH, "true",
            StringUtils.EMPTY);
    SystemParameter systemParameter1 =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY,
            String.valueOf(new Date().getTime()), StringUtils.EMPTY);
    SystemParameter scoreSystemParameter =
        new SystemParameter(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE,
            String.valueOf(5.0), StringUtils.EMPTY);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH))
        .thenReturn(systemParameter);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY))
        .thenReturn(systemParameter1);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE))
        .thenReturn(scoreSystemParameter);
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(list.execute()).thenReturn(videoListResponse);
    Mockito.when(this.productRepository.findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(productList);
    Mockito.when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
            eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSync);
    Mockito.when(businessPartnerService.isBusinessPartnerUmkmMerchant(STORE_ID, MERCHANT_CODE)).thenReturn(false);
    Mockito.when(this.productCategoryBaseClient
            .getSalesCategoryMappingByProductCode(STORE_ID, REQUEST_ID, USERNAME, product.getProductCode(), false))
        .thenReturn(new GdnRestSingleResponse<>("error", "error", false,
            null, REQUEST_ID));
    Mockito.when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID, product.getProductCode()))
        .thenReturn(productDetailResponse);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.when(youTube.videos()).thenReturn(videos);
    Mockito.when(youTube.videos().list(Collections.singletonList(VIDEO_LIST))).thenReturn(list);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenReturn(productDetailResponse);
    try {
      Assertions.assertThrows(Exception.class, () -> productServiceImpl.generateProductScoreByProductSku(STORE_ID, null, PRODUCT_CODE, REQUEST_ID,
          USERNAME, true, null));
    }
    finally {
      verify(this.productCategoryBaseClient)
          .getProductDetailByProductCode(Constants.DEFAULT_USERNAME, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
      Mockito.verify(systemParameterService)
          .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.YOUTUBE_URL_VALIDATION_SWITCH);
      Mockito.verify(systemParameterService)
          .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
      Mockito.verify(systemParameterService)
          .findValueByStoreIdAndVariable(STORE_ID, SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
      Mockito.verify(youTube, Mockito.times(3)).videos();
      Mockito.verify(list).execute();
      verify(this.productRepository).findByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
      verify(this.productScoreUtil)
          .getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
      verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
      Mockito.verify(this.productCategoryBaseClient)
          .getSalesCategoryMappingByProductCode(STORE_ID, Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, product.getProductCode(), true);
    }
  }


  @Test
  public void updateProductUnSyncTest_productScoreChange_noChangeToImageAndUPCScore() throws Exception {
    oldProductScore.setImageScore(15.0);
    oldProductScore.setEanUpcScore(2.0);
    productScoreVo.setImageScore(5.0);
    productScoreVo.setEanUpcScore(1.0);
    this.productUnSyncTobeUpdated.setProductScore(oldProductScore);
    this.productUnsyncUpdated.getMasterDataProduct().setDescription(DESCRIPTION);
    this.productUnSyncTobeUpdated.getMasterDataProduct()
        .setMasterCatalog(new MasterCatalog(CATALOG_CODE, new Category(CATEGORY_CODE, CATEGORY_CODE)));
    setMasterDataAttributes(this.productUnsyncUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE,
        PREDEFINED_ATTRIBUTE_VALUE, ALLOWED_ATTRIBUTE_VALUE);
    setMasterDataAttributes(this.productUnSyncTobeUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE_2,
        PREDEFINED_ATTRIBUTE_VALUE_2, ALLOWED_ATTRIBUTE_VALUE_1);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    when(this.itemService
        .findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, productUnSyncTobeUpdated.getProductSku()))
        .thenReturn(Collections.singletonList(item));
    when(this.productHelperService
        .modifyItemNames(Collections.singletonList(item),
            ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME))
        .thenReturn(Collections.singletonList(item));
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(Collections.singletonList(item),
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, Collections.singletonList(item)));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_productScoreChange_emptyProductCode_emptyItems() throws Exception {
    oldProductScore.setEanUpcScore(1.0);
    this.productUnSyncTobeUpdated.getMasterDataProduct().setProductName(NEW_PRODUCT_NAME);
    this.productUnSyncTobeUpdated.setProductScore(oldProductScore);
    this.productUnSyncTobeUpdated.setProductCode(null);
    this.productUnsyncUpdated.getMasterDataProduct().setDescription(DESCRIPTION);
    this.productUnSyncTobeUpdated.getMasterDataProduct()
        .setMasterCatalog(new MasterCatalog(CATALOG_CODE, new Category(CATEGORY_CODE, CATEGORY_CODE)));

    setMasterDataAttributes(this.productUnsyncUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE,
        PREDEFINED_ATTRIBUTE_VALUE, ALLOWED_ATTRIBUTE_VALUE);
    setMasterDataAttributes(this.productUnSyncTobeUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE_2,
        PREDEFINED_ATTRIBUTE_VALUE_2, ALLOWED_ATTRIBUTE_VALUE_1);
    when(this.saveOperationService.saveProduct(any(Product.class))).thenReturn(productUnSyncTobeUpdated);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    when(this.itemService
        .findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, productUnSyncTobeUpdated.getProductSku()))
        .thenReturn(Collections.singletonList(item));
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProduct(this.productUnSyncTobeUpdated);
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncTest_productScoreChange_nonNullProductCode() throws Exception {
    oldProductScore.setEanUpcScore(1.0);
    this.productUnSyncTobeUpdated.setProductCode(PRODUCT_CODE);
    this.productUnSyncTobeUpdated.setProductScore(oldProductScore);
    this.productUnsyncUpdated.getMasterDataProduct().setDescription(DESCRIPTION);
    this.productUnsyncUpdated.setProductCode(PRODUCT_CODE);
    this.productUnSyncTobeUpdated.getMasterDataProduct()
        .setMasterCatalog(new MasterCatalog(CATALOG_CODE, new Category(CATEGORY_CODE, CATEGORY_CODE)));
    setMasterDataAttributes(this.productUnsyncUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE,
        PREDEFINED_ATTRIBUTE_VALUE, ALLOWED_ATTRIBUTE_VALUE);
    setMasterDataAttributes(this.productUnSyncTobeUpdated.getMasterDataProduct(), DESCRIPTIVE_ATTRIBUTE_VALUE_2,
        PREDEFINED_ATTRIBUTE_VALUE_2, ALLOWED_ATTRIBUTE_VALUE_1);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(any(ProductAndItemsVO.class))).thenReturn(productAndItemsVO);
    Mockito.doNothing().when(productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(StringUtils.EMPTY);
    when(this.itemService
        .findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, productUnSyncTobeUpdated.getProductSku()))
        .thenReturn(Collections.singletonList(item));
    when(this.productHelperService
        .modifyItemNames(Collections.singletonList(item),
            ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME))
        .thenReturn(Collections.singletonList(item));
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(Collections.singletonList(item),
        ProductServiceImplTest.OLD_PRODUCT_NAME, ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(new ProductAndItemsVO(this.productUnSyncTobeUpdated, Collections.singletonList(item)));
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    verify(this.productHelperService).generateSpecificationDetail(any(Product.class));
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), eq(PRODUCT_SKU_UNSYNC_TOBE_UPDATED), any(ProductScore.class),
            any(ProductScore.class));
    assertNotNull(product);
  }

  @Test
  public void updateProductUnSyncDuplicateAttributeTest() {
    MasterDataProductAttribute masterDataProductAttribute = new MasterDataProductAttribute();
    MasterDataAttribute masterDataAttribute = new MasterDataAttribute();
    masterDataAttribute.setVariantCreation(true);
    masterDataAttribute.setAttributeType(MasterDataAttributeType.DESCRIPTIVE_ATTRIBUTE);
    MasterDataProductAttributeValue masterDataProductAttributeValue = new MasterDataProductAttributeValue();
    masterDataProductAttributeValue.setDescriptiveAttributeValue("Descriptive-Value");
    masterDataProductAttribute.setMasterDataAttribute(masterDataAttribute);
    masterDataProductAttribute.setMasterDataProductAttributeValues(Arrays.asList(masterDataProductAttributeValue));
    productUnsync.getMasterDataProduct().getMasterDataProductAttributes().add(masterDataProductAttribute);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().add(masterDataProductAttribute);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false)).thenReturn(this.productUnSyncTobeUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(productAndItemsVOArgumentCaptor.capture()))
        .thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList, ProductServiceImplTest.OLD_PRODUCT_NAME,
        ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(productAndItemsVOArgumentCaptor.getValue());
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    assertEquals(1,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getMasterDataProductAttributes()
            .stream().filter(masterAttribute -> masterAttribute.getMasterDataAttribute().isVariantCreation()).count());
  }

  @Test
  public void updateProductUnSyncDuplicateAttributeDefiningAttributeTest() {
    MasterDataProductAttribute masterDataProductAttribute = new MasterDataProductAttribute();
    MasterDataAttribute masterDataAttribute = new MasterDataAttribute();
    masterDataAttribute.setAttributeType(MasterDataAttributeType.DEFINING_ATTRIBUTE);
    MasterDataProductAttributeValue masterDataProductAttributeValue = new MasterDataProductAttributeValue();
    masterDataProductAttributeValue.setDescriptiveAttributeValue("Descriptive-Value");
    masterDataProductAttribute.setMasterDataAttribute(masterDataAttribute);
    masterDataProductAttribute.setMasterDataProductAttributeValues(Arrays.asList(masterDataProductAttributeValue));
    productUnsync.getMasterDataProduct().getMasterDataProductAttributes().add(masterDataProductAttribute);
    productUnSyncTobeUpdated.getMasterDataProduct().getMasterDataProductAttributes().add(masterDataProductAttribute);

    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false)).thenReturn(this.productUnSyncTobeUpdated);
    when(this.saveOperationService.saveProductAndItemsWithoutPublishingItemChange(productAndItemsVOArgumentCaptor.capture()))
        .thenReturn(productAndItemsVO);
    Product product = this.productServiceImpl
        .updateProduct(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, this.productUnsyncUpdated,
            false);
    verify(this.productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED, false);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_UNSYNC_TOBE_UPDATED);
    verify(this.productHelperService).modifyItemNames(this.emptyList, ProductServiceImplTest.OLD_PRODUCT_NAME,
        ProductServiceImplTest.NEW_PRODUCT_NAME);
    verify(this.saveOperationService)
        .saveProductAndItemsWithoutPublishingItemChange(productAndItemsVOArgumentCaptor.getValue());
    verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID, Constants.CATEGORY_CODE_VARIABLE);
    assertNotNull(product);
    assertEquals(1,
        productAndItemsVOArgumentCaptor.getValue().getProduct().getMasterDataProduct().getMasterDataProductAttributes()
            .stream().filter(masterAttribute -> MasterDataAttributeType.DEFINING_ATTRIBUTE
                .equals(masterAttribute.getMasterDataAttribute().getAttributeType())).count());
  }

  @Test
  public void updateMigratedProductCodePublishItemsFalseTest() throws Exception {
    item.setItemCode(ITEM_CODE);
    item.setSourceItemCode(SOURCE_ITEM_CODE);
    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(ITEM_CODE);
    productItemResponse.setSourceItemCode(SOURCE_ITEM_CODE);
    productItemResponse.setContentChanged(true);
    productDetailResponse.getProductItemResponses().add(productItemResponse);

    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    when(masterDataService.getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEvent(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(product, Arrays.asList(item)));

    productServiceImpl.updateMigratedProductCode(USERNAME, REQUEST_ID, STORE_ID, PRODUCT_SKU, PRODUCT_CODE, false);

    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(masterDataService).getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEvent(new ProductAndItemsVO(product, Arrays.asList(item)));
  }

  @Test
  public void updateMigratedProductCodePublishItemsFalseForProductCodeNullTest() throws Exception {
    item.setItemCode(ITEM_CODE);
    item.setSourceItemCode(SOURCE_ITEM_CODE);
    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(ITEM_CODE);
    productItemResponse.setSourceItemCode(SOURCE_ITEM_CODE);
    productItemResponse.setContentChanged(true);
    productDetailResponse.getProductItemResponses().add(productItemResponse);
    product.setProductCode(null);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    when(masterDataService.getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEvent(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(product, Arrays.asList(item)));

    productServiceImpl.updateMigratedProductCode(USERNAME, REQUEST_ID, STORE_ID, PRODUCT_SKU, PRODUCT_CODE, false);

    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(masterDataService).getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEvent(new ProductAndItemsVO(product, Arrays.asList(item)));
  }

  @Test
  public void updateMigratedProductCodePublishItemsTrueTest() throws Exception {
    item.setItemCode(ITEM_CODE);
    item.setSourceItemCode(SOURCE_ITEM_CODE);
    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(ITEM_CODE);
    productItemResponse.setSourceItemCode(SOURCE_ITEM_CODE);
    productItemResponse.setContentChanged(true);
    productDetailResponse.getProductItemResponses().add(productItemResponse);

    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    when(masterDataService.getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    when(saveOperationService
        .saveProductAndItems(new ProductAndItemsVO(product, Arrays.asList(item)), new ArrayList<>()))
        .thenReturn(new ProductAndItemsVO(product, Arrays.asList(item)));

    productServiceImpl.updateMigratedProductCode(USERNAME, REQUEST_ID, STORE_ID, PRODUCT_SKU, PRODUCT_CODE, true);

    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(masterDataService).getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE);
    verify(saveOperationService).saveProductAndItems(new ProductAndItemsVO(product, Arrays.asList(item)),
        new ArrayList<>());
  }

  @Test
  public void getProductCenterSummaryTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    when(productSolrRepository
        .getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)))
        .thenReturn(productSolrPage);
    when(productCategoryBaseClient.getCategoryNames(Arrays.asList("CAT-CODE2"))).thenReturn(categoryNamesResponse);
    Page<ProductCenterSummaryResponse> response = productServiceImpl
        .getProductCenterSummary(STORE_ID, REQUEST_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    assertEquals(PRODUCT_SKU, response.getContent().get(0).getProductSku());
    assertEquals(NEW_PRODUCT_NAME, response.getContent().get(0).getProductName());
    assertEquals("CAT-CODE2", response.getContent().get(0).getMasterCategory().getCategoryCode());
    assertEquals("CAT-CODE2", response.getContent().get(0).getSalesCategories().get(0));
    assertEquals(Constants.ACTIVE, response.getContent().get(0).getStatus());
    verify(productSolrRepository).getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    verify(productCategoryBaseClient).getCategoryNames(Arrays.asList("CAT-CODE2"));
  }

  @Test
  public void getProductCenterSuspendedSummaryTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    productSolrPage.getContent().get(0).setSuspended(true);
    when(productSolrRepository
        .getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)))
        .thenReturn(productSolrPage);
    when(productCategoryBaseClient.getCategoryNames(Arrays.asList("CAT-CODE2"))).thenReturn(categoryNamesResponse);
    Page<ProductCenterSummaryResponse> response = productServiceImpl.getProductCenterSummary(STORE_ID, REQUEST_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    assertEquals(Constants.SUSPENDED, response.getContent().get(0).getStatus());
    verify(productSolrRepository).getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    verify(productCategoryBaseClient).getCategoryNames(Arrays.asList("CAT-CODE2"));
  }

  @Test
  public void getProductCenterNoSalesCategorySummaryTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    productSolrPage.getContent().get(0).setSalesCatalog(null);
    when(productSolrRepository
        .getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)))
        .thenReturn(productSolrPage);
    when(productCategoryBaseClient.getCategoryNames(Arrays.asList("CAT-CODE2"))).thenReturn(categoryNamesResponse);
    Page<ProductCenterSummaryResponse> response = productServiceImpl.getProductCenterSummary(STORE_ID, REQUEST_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    assertEquals(0, response.getContent().get(0).getSalesCategories().size());
    verify(productSolrRepository).getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    verify(productCategoryBaseClient).getCategoryNames(Arrays.asList("CAT-CODE2"));
  }

  @Test
  public void getProductCenterSummaryStoreIdNullTest() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl
        .getProductCenterSummary(null, REQUEST_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)));
  }

  @Test
  public void getProductCenterSummaryResponseNullTest() throws Exception {
    when(productSolrRepository
        .getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)))
        .thenReturn(null);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl
          .getProductCenterSummary(STORE_ID, REQUEST_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)));
    }
    finally {
      verify(productSolrRepository).getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    }
  }

  @Test
  public void getProductCenterSummaryResponseEmptyTest() throws Exception {
    when(productSolrRepository
        .getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)))
        .thenReturn(new PageImpl<>(new ArrayList<>()));
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl
          .getProductCenterSummary(STORE_ID, REQUEST_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)));
    }
    finally {
      verify(productSolrRepository).getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
    }
  }

  @Test
  public void getProductCenterSummaryCatgeoryMappingNullTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    categoryNamesResponse.setCategoryMap(null);
    when(productSolrRepository
        .getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)))
        .thenReturn(productSolrPage);
    when(productCategoryBaseClient
        .getCategoryNames(Arrays.asList("CAT-CODE")))
        .thenReturn(categoryNamesResponse);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl
          .getProductCenterSummary(STORE_ID, REQUEST_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100)));
    } finally {
      verify(productSolrRepository)
          .getProductCenterSummary(STORE_ID, new ProductCenterSummaryRequest(), PageRequest.of(0, 100));
      verify(productCategoryBaseClient)
          .getCategoryNames(Arrays.asList("CAT-CODE2"));
    }
  }

  @Test
  public void getUnmappedProductSkusTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    productSolrPage.getContent().get(0).setMasterCatalog(CATALOG_CODE + "#_#" + CATEGORY_CODE);
    when(productSolrRepository.getUnmappedProductSKusByCategoryCodes(STORE_ID, Arrays.asList(CATEGORY_CODE)))
        .thenReturn(productSolrPage.getContent());
    List<UnmappedSkuResponse> response =
        productServiceImpl.getUnmappedProductSkus(STORE_ID, Arrays.asList(CATEGORY_CODE));
    assertEquals(PRODUCT_SKU, response.get(0).getProductSku());
    assertEquals(CATEGORY_CODE, response.get(0).getMasterCategoryCode());
    verify(productSolrRepository).getUnmappedProductSKusByCategoryCodes(STORE_ID, Arrays.asList(CATEGORY_CODE));
  }

  @Test
  public void getProductDetailsForProductCenterTest() throws Exception {
    BusinessPartner businessPartner =
        BusinessPartner.builder().businessPartnerName(MERCHANT_CODE).businessPartnerCode(MERCHANT_CODE).build();
    when(productAndItemSolrIndexerService.getProductSolrByProductSku(PRODUCT_SKU)).thenReturn(productSolr1);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, MERCHANT_CODE))
        .thenReturn(businessPartner);
    ProductCenterDetailResponse response = productServiceImpl.getProductDetailsForProductCenter(STORE_ID, PRODUCT_SKU,
        true);
    Mockito.verify(productAndItemSolrIndexerService).getProductSolrByProductSku(PRODUCT_SKU);
    Mockito.verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(STORE_ID, MERCHANT_CODE);
    assertEquals("Suspended", response.getStatus());
  }

  @Test
  public void getProductDetailsForProductCenter3Test() throws Exception {
    BusinessPartner businessPartner =
        BusinessPartner.builder().businessPartnerName(MERCHANT_CODE).businessPartnerCode(MERCHANT_CODE).build();
    when(productAndItemSolrIndexerService.getProductSolrByProductSku(PRODUCT_SKU)).thenReturn(productSolr1);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, MERCHANT_CODE))
        .thenReturn(businessPartner);
    ProductCenterDetailResponse response = productServiceImpl.getProductDetailsForProductCenter(STORE_ID, PRODUCT_SKU,
        false);
    Mockito.verify(productAndItemSolrIndexerService).getProductSolrByProductSku(PRODUCT_SKU);
    assertEquals("Suspended", response.getStatus());
  }

  @Test
  public void getProductDetailsForProductCenterTest_2() throws Exception {
    productSolr1.setSuspended(false);
    BusinessPartner businessPartner =
        BusinessPartner.builder().businessPartnerName(MERCHANT_CODE).businessPartnerCode(MERCHANT_CODE).build();
    when(productAndItemSolrIndexerService.getProductSolrByProductSku(PRODUCT_SKU)).thenReturn(productSolr1);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, MERCHANT_CODE))
        .thenReturn(businessPartner);
    ProductCenterDetailResponse response = productServiceImpl.getProductDetailsForProductCenter(STORE_ID, PRODUCT_SKU,
        true);
    Mockito.verify(productAndItemSolrIndexerService).getProductSolrByProductSku(PRODUCT_SKU);
    Mockito.verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(STORE_ID, MERCHANT_CODE);
    assertEquals("Active", response.getStatus());
  }

  @Test
  public void updateMigratedProductCodeForDeletedProductTest() throws Exception {
    product.setMarkForDelete(true);
    product.setSuspended(false);
    item.setItemCode(ITEM_CODE);
    item.setSourceItemCode(SOURCE_ITEM_CODE);
    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(ITEM_CODE);
    productItemResponse.setSourceItemCode(SOURCE_ITEM_CODE);
    productItemResponse.setContentChanged(true);
    productDetailResponse.getProductItemResponses().add(productItemResponse);

    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    when(masterDataService.getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    when(saveOperationService
        .saveProductAndItems(new ProductAndItemsVO(product, Arrays.asList(item)), new ArrayList<>()))
        .thenReturn(new ProductAndItemsVO(product, Arrays.asList(item)));

    productServiceImpl.updateMigratedProductCode(USERNAME, REQUEST_ID, STORE_ID, PRODUCT_SKU, PRODUCT_CODE, true);

    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void updateMigratedProductCodeForDeletedAndSuspendedProductTest() throws Exception {
    product.setMarkForDelete(true);
    product.setSuspended(true);
    item.setItemCode(ITEM_CODE);
    item.setSourceItemCode(SOURCE_ITEM_CODE);
    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(ITEM_CODE);
    productItemResponse.setSourceItemCode(SOURCE_ITEM_CODE);
    productItemResponse.setContentChanged(true);
    productDetailResponse.getProductItemResponses().add(productItemResponse);

    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    when(masterDataService.getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE))
        .thenReturn(productDetailResponse);
    when(saveOperationService
        .saveProductAndItems(new ProductAndItemsVO(product, Arrays.asList(item)), new ArrayList<>()))
        .thenReturn(new ProductAndItemsVO(product, Arrays.asList(item)));

    productServiceImpl.updateMigratedProductCode(USERNAME, REQUEST_ID, STORE_ID, PRODUCT_SKU, PRODUCT_CODE, true);

    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(masterDataService).getProductDetailFromMasterData(USERNAME, REQUEST_ID, PRODUCT_CODE);
    verify(saveOperationService).saveProductAndItems(new ProductAndItemsVO(product, Arrays.asList(item)),
        new ArrayList<>());
  }

  @Test
  public void updateSalesCategorySuccessTest() throws Exception {
    product.setB2bActivated(true);
    product.setB2cActivated(true);
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(ListOfsalesCatalogs);
    product.setDefiningAttributes(Arrays.asList(new ProductAttribute(), new ProductAttribute()));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productRepository.updateSalesCatalog(anyString(), anyString(), anyList(), any(Date.class))).thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    when(this.itemService.findItemsByStoreIdAndProductSku(STORE_ID, product.getProductSku())).thenReturn(this.listOfItems);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.singletonList(salesCategoryUpdateRequest),
            Collections.singletonList(salesCategoryUpdateRequest1), ETD_NOTE), REQUEST_ID);
    verify(this.productCategoryBaseClient, times(2)).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            anyString(), anyString());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.DELETE), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository).updateSalesCatalog(STORE_ID, product.getProductSku(), product.getSalesCatalogs(), product.getProductCenterUpdatedDate());
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(this.kafkaProducer)
        .send(eq(ProductDomainEventName.PRODUCT_CHANGE_EVENT_NAME), anyString(),
            productChangeArgumentCaptor.capture());
    Mockito.verify(gdnMapperMock, times(1)).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
    assertTrue(productChangeArgumentCaptor.getValue().isMultiVariant());
  }

  @Test
  public void updateSalesCategorySuccessTest_2() throws Exception {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(ListOfsalesCatalogs);
    product.setMasterDataProduct(masterDataProductUpdated);
    salesCategoryUpdateRequest1.setCategoryCode(CATEGORY_CODE);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productRepository.updateSalesCatalog(anyString(), anyString(), anyList(), any(Date.class))).thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.singletonList(salesCategoryUpdateRequest),
            Collections.singletonList(salesCategoryUpdateRequest1), ""), REQUEST_ID);
    verify(this.productCategoryBaseClient, times(2)).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            anyString(), anyString());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.DELETE), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository)
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(gdnMapperMock, times(1)).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategorySuccessTest_NoAdded() throws Exception {
    item.setItemSku(ITEM_SKU);
    product.setB2cActivated(false);
    this.product.setSalesCatalogs(Collections.singletonList(new SalesCatalog(SALES_CATALOG_CODE, new ArrayList<>())));
    product.setMasterDataProduct(masterDataProductUpdated);
    salesCategoryUpdateRequest1.setCatalogCode(SALES_CATALOG_CODE);
    salesCategoryUpdateRequest1.setCategoryCode(CATEGORY_CODE);
    product.setProductCenterUpdatedDate(new Date());
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(this.productRepository.updateSalesCatalog(anyString(), anyString(), anyList(), any(Date.class))).thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.emptyList(),
            Collections.singletonList(salesCategoryUpdateRequest1), ""), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.DELETE), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository).updateSalesCatalog(STORE_ID, product.getProductSku(), product.getSalesCatalogs(),
        product.getProductCenterUpdatedDate());
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategorySuccess1Test() throws Exception {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(new ArrayList<>());
    product.setMasterDataProduct(masterDataProductUpdated);
    salesCategoryUpdateRequest1.setCatalogCode(SALES_CATALOG_CODE);
    salesCategoryUpdateRequest1.setCategoryCode(CATEGORY_CODE);
    product.setProductCenterUpdatedDate(new Date());
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(this.productRepository.updateSalesCatalog(anyString(), anyString(), anyList(), any(Date.class))).thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.emptyList(),
            Collections.singletonList(salesCategoryUpdateRequest1), ""), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.DELETE), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository).updateSalesCatalog(STORE_ID, product.getProductSku(), product.getSalesCatalogs(),
        product.getProductCenterUpdatedDate());
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
  }

  @Test
  public void updateSalesCategorySuccessTest_3() throws Exception {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(Collections.singletonList(new SalesCatalog(SALES_CATALOG_CODE, new ArrayList<>())));
    product.setMasterDataProduct(masterDataProductUpdated);
    salesCategoryUpdateRequest1.setCategoryCode(CATEGORY_CODE);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productRepository.updateSalesCatalog(anyString(), anyString(), anyList(), any(Date.class))).thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.emptyList(),
            Collections.singletonList(salesCategoryUpdateRequest1), ""), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.DELETE), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository).updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategory_SameCatalogCodeTest() throws Exception {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(ListOfsalesCatalogs);
    salesCategoryUpdateRequest.setCatalogCode(SALES_CATALOG_CODE);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    when(this.productRepository
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class)))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.singletonList(salesCategoryUpdateRequest),
            Collections.emptyList(), ETD_NOTE), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository)
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategoryHistoryTest() {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(ListOfsalesCatalogs);
    salesCategoryUpdateRequest.setCatalogCode(SALES_CATALOG_CODE);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    when(this.productRepository
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class)))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.singletonList(salesCategoryUpdateRequest),
            Collections.emptyList(), ETD_NOTE), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository)
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategoryHistory1Test() {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(ListOfsalesCatalogs);
    salesCategoryUpdateRequest.setCatalogCode(SALES_CATALOG_CODE);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    when(this.productRepository
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class)))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.singletonList(salesCategoryUpdateRequest),
            Collections.emptyList(), null), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository)
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategoryHistory2Test() {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(ListOfsalesCatalogs);
    salesCategoryUpdateRequest.setCatalogCode(SALES_CATALOG_CODE);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    when(this.productRepository
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class)))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.singletonList(salesCategoryUpdateRequest),
            Collections.emptyList(), null), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository)
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategory_SameCatalogCode_DifferentCategoryTest() throws Exception {
    item.setItemSku(ITEM_SKU);
    this.product.setSalesCatalogs(ListOfsalesCatalogs);
    salesCategoryUpdateRequest.setCatalogCode(SALES_CATALOG_CODE);
    salesCategoryUpdateRequest.setCategoryCode(CATEGORY_CODE_UPDATED);
    product.setTradingProduct(true);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(this.productRepository
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class)))
        .thenReturn(product);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku()))
        .thenReturn(listOfItems);
    when(this.productCategoryBaseClient.getCategoryNames(anyList()))
        .thenReturn(categoryNamesResponse);
    productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
        new SalesCategoryMappingUpdateRequest(Collections.singletonList(salesCategoryUpdateRequest),
            Collections.emptyList(), ETD_NOTE), REQUEST_ID);
    verify(this.productCategoryBaseClient).getCategoryNames(anyList());
    verify(this.productCenterHistoryService)
        .saveProductCenterHistory(eq(PRODUCT_SKU), eq(ProductCenterActivity.COPY), eq(REQUEST_ID),
            anyString(), anyString());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.productRepository)
        .updateSalesCatalog(eq(STORE_ID), eq(product.getProductSku()), eq(product.getSalesCatalogs()), any(Date.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, product.getProductSku());
    verify(saveAndPublishService).publishListOfItems(listOfItems);
    verify(this.cacheEvictHelperService).evictProductData(anyString(), any(Product.class));
    verify(this.productAndItemSolrIndexerService).updateSolrOnSalesCatalogChanges(product, listOfItems);
    Mockito.verify(gdnMapperMock).deepCopy(any(SalesCatalog.class),
        eq(com.gdn.x.product.domain.event.model.SalesCatalog.class));
  }

  @Test
  public void updateSalesCategory_NullProductTest() throws Exception {
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(null);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.updateSalesCategory(STORE_ID, PRODUCT_SKU,
          new SalesCategoryMappingUpdateRequest(Collections.emptyList(), Collections.emptyList(), ETD_NOTE),
          REQUEST_ID));
    } finally {
      verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    }
  }

  @Test
  public void updateMigratedProductCodeWithEmptyProductCodeTest() throws Exception {
    item.setItemCode(ITEM_CODE);
    item.setSourceItemCode(SOURCE_ITEM_CODE);
    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(ITEM_CODE);
    productItemResponse.setSourceItemCode(SOURCE_ITEM_CODE);
    productItemResponse.setContentChanged(true);
    productDetailResponse.getProductItemResponses().add(productItemResponse);

    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(Arrays.asList(item));
    when(saveOperationService
        .saveProductAndItems(new ProductAndItemsVO(product, Arrays.asList(item)), new ArrayList<>()))
        .thenReturn(new ProductAndItemsVO(product, Arrays.asList(item)));

    productServiceImpl.updateMigratedProductCode(USERNAME, REQUEST_ID, STORE_ID, PRODUCT_SKU, null, true);

    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveOperationService).saveProductAndItems(new ProductAndItemsVO(product, Arrays.asList(item)),
        new ArrayList<>());
  }

  @Test
  public void getProductAndItemsByItemSkusForActiveItemsTest() throws Exception {
    when(this.skuValidator.isItemSku(ProductServiceImplTest.ITEM_SKU_2)).thenReturn(true);
    when(this.itemService
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.ITEM_SKU_2, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
            false, false)).thenReturn(this.item);

    Set<String> itemSkus = Stream.of(ProductServiceImplTest.ITEM_SKU).collect(toSet());
    itemSkus.add(ITEM_SKU_2);
    List<ItemCatalogVO> itemCatalogs = new ArrayList<>();
    ItemCatalogVO itemCatalog = new ItemCatalogVO();
    itemCatalogs.add(itemCatalog);

    List<Item> items = Arrays.asList(item);
    when(masterDataConstructorService
        .constructProductAndItemWithMasterData(STORE_ID, USERNAME, REQUEST_ID, productSync, items, false,
            IN_ALL_PRODUCTS)).thenReturn(new ProductAndItemsVO(productSync, items));
    when(catalogService.getItemCatalogsWithCategoryHierarchy(USERNAME, REQUEST_ID, productSync))
        .thenReturn(itemCatalogs);

    this.productServiceImpl
        .getProductAndItemsByItemSkusForActiveItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, itemSkus, true, false, false, true);
    verify(this.productHelperService, times(2))
        .findAndConstructOfflineItemsByPickupPointCode(ProductServiceImplTest.STORE_ID, items, null);
    verify(this.itemService)
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.ITEM_SKU, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
            false, false);
    verify(this.productCacheableService, times(2))
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(catalogService).getItemCatalogsWithCategoryHierarchy(USERNAME, REQUEST_ID, productSync);
    verify(this.itemService)
        .getItem(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.ITEM_SKU_2, ProductServiceImplTest.NEED_MASTER_DATA_DETAIL, true, false, false, null,
            false, false);
  }

  @Test
  public void getProductL3CountByProductCodeTest() {
    when(productSolrRepository.countByProductCode(PRODUCT_CODE)).thenReturn(1L);
    this.productServiceImpl.getProductL3CountByProductCode(PRODUCT_CODE);
    verify(productSolrRepository).countByProductCode(PRODUCT_CODE);
  }

  @Test
  public void getProductL3CountByProductCode_EmptyTest() {
    this.productServiceImpl.getProductL3CountByProductCode(StringUtils.EMPTY);
  }

  @Test
  public void updateSalesCategoryOfProductTest() {
    this.productServiceImpl.updateSalesCategoryOfProduct(new SalesCategoryMappingUpdateRequest(), product);
  }

  @Test
  public void getPickupPointCodesByProductSkuTest() throws Exception {
    product.setPickupPointCodes(ImmutableSet.of(PICKUP_POINT_CODE));
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    ProductPickupPointListResponse response = productServiceImpl.getPickupPointCodesByProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Assertions.assertTrue(response.getPickupPointCodes().contains(PICKUP_POINT_CODE));
  }

  @Test
  public void getPickupPointCodesByProductSkuExceptionTest() throws Exception {
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(null);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () ->
          productServiceImpl.getPickupPointCodesByProductSku(STORE_ID, PRODUCT_SKU));
    } finally {
      Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    }
  }

  @Test
  public void getProductSkuListTest() {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    productSolr1.setMasterCatalog(STORE_ID + "#_#" + MASTER_CATALOG);
    productSolr1.setBrand(BRAND);
    productSolr1.setProductName(PRODUCT_NAME);
    Mockito.when(productSolrRepository
            .getProductSkuSummary(eq(STORE_ID), any(ProductSkuSummaryRequestVo.class),
                eq(MERCHANT_CODE), eq(0), eq(10)))
        .thenReturn(new PageImpl<>(Arrays.asList(productSolr1), PageRequest.of(0, 10), 10));
    Page<ProductSkuSummaryResponse> response = productServiceImpl
        .getProductSkuList(STORE_ID, productSkuSummaryRequest, MERCHANT_CODE, 0, 10);
    Mockito.verify(productSolrRepository)
        .getProductSkuSummary(eq(STORE_ID), any(ProductSkuSummaryRequestVo.class),
            eq(MERCHANT_CODE), eq(0), eq(10));
    Assertions.assertEquals(PRODUCT_NAME, response.getContent().get(0).getProductName());
    Assertions.assertEquals(PRODUCT_SKU, response.getContent().get(0).getProductSku());
    Assertions.assertEquals(MASTER_CATALOG, response.getContent().get(0).getCategoryCode());
  }

  @Test
  public void getProductDetailsByProductSkuTestWithBlankProductSku() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl
        .getProductDetailsByProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, null));
  }

  @Test
  public void getProductDetailsByProductSkuWithProductNotFoundTest() throws Exception {
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(null);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductDetailsByProductSku(STORE_ID, ProductServiceImplTest.REQUEST_ID,
          ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC));
    } finally {
      Mockito.verify(this.productCacheableService)
          .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    }
  }

  @Test
  public void getProductDetailsByProductSkuTestWithBlankRequestId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductDetailsByProductSku(ProductServiceImplTest.STORE_ID, null,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC));
  }

  @Test
  public void getProductDetailsByProductSkuTestWithBlankStoreId() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getProductDetailsByProductSku(null, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_SYNC));
  }

  @Test
  public void getProductDetailsByProductSkuMppTrueTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "autoHealMissingPPCodesAtL3",true);
    this.itemPickupPoint.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.itemPickupPoint.setItemSku(ITEM_SKU);
    this.itemPickupPoint.setPickupPointCode(PICKUP_POINT_CODE);
    List<ItemPickupPoint> listOfItemPickupPoints;
    item.setItemSku(ITEM_SKU);
    item.setPickupPointCode(PICKUP_POINT_CODE);
    itemPickupPoint.setItemSku(ITEM_SKU);
    listOfItemPickupPoints = Arrays.asList(this.itemPickupPoint);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(this.productUnsync);
    when(this.masterDataConstructorService
        .constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.findItemsByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(this.listOfItems);
    when(this.itemPickupPointService.findByStoreIdAndProductSkuAndDelivery(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC,Boolean.TRUE)).thenReturn(listOfItemPickupPoints);
    when(this.itemPickupPointService
        .getItemPickupPointsByProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(listOfItemPickupPoints);
    ProductAndItemsVO result = this.productServiceImpl
        .getProductDetailsByProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).findItemsByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(eq(ProductServiceImplTest.USERNAME),
        eq(ProductServiceImplTest.REQUEST_ID), any(Product.class));
    verify(this.itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(anyString(),anyString());
    verify(this.saveOperationService).saveProduct(any());
  }

  @Test
  public void getProductDetailsByProductSkuMppTrueTestMissingPPCodesSwitchOff() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "autoHealMissingPPCodesAtL3",false);
    this.itemPickupPoint.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.itemPickupPoint.setItemSku(ITEM_SKU);
    this.itemPickupPoint.setPickupPointCode(PICKUP_POINT_CODE);
    List<ItemPickupPoint> listOfItemPickupPoints;
    item.setItemSku(ITEM_SKU);
    item.setPickupPointCode(PICKUP_POINT_CODE);
    itemPickupPoint.setItemSku(ITEM_SKU);
    listOfItemPickupPoints = Arrays.asList(this.itemPickupPoint);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(this.productUnsync);
    when(this.masterDataConstructorService
        .constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.findItemsByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(this.listOfItems);
    when(this.itemPickupPointService.findByStoreIdAndProductSkuAndDelivery(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC,Boolean.TRUE)).thenReturn(listOfItemPickupPoints);
    when(this.itemPickupPointService
        .getItemPickupPointsByProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(listOfItemPickupPoints);
    ProductAndItemsVO result = this.productServiceImpl
        .getProductDetailsByProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).findItemsByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(eq(ProductServiceImplTest.USERNAME),
        eq(ProductServiceImplTest.REQUEST_ID), any(Product.class));
    verify(this.itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(anyString(),anyString());
  }

  @Test
  public void getProductDetailsByProductSkuMppTrueTestMissingPPCodesSwitchOnPickUpPointsEmpty() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "autoHealMissingPPCodesAtL3",true);
    this.itemPickupPoint.setProductSku(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.itemPickupPoint.setItemSku(ITEM_SKU);
    this.itemPickupPoint.setPickupPointCode(PICKUP_POINT_CODE);
    List<ItemPickupPoint> listOfItemPickupPoints;
    item.setItemSku(ITEM_SKU);
    item.setPickupPointCode(PICKUP_POINT_CODE);
    itemPickupPoint.setItemSku(ITEM_SKU);
    this.productUnsync.setPickupPointCodes(Collections.singleton("ppCode"));
    listOfItemPickupPoints = Arrays.asList(this.itemPickupPoint);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(this.productUnsync);
    when(this.masterDataConstructorService
        .constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true))
        .thenReturn(this.productAndItemsVO);
    when(this.itemService.findItemsByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(this.listOfItems);
    when(this.itemPickupPointService.findByStoreIdAndProductSkuAndDelivery(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC,Boolean.TRUE)).thenReturn(listOfItemPickupPoints);
    when(this.itemPickupPointService
        .getItemPickupPointsByProductSkuAndMarkForDeleteFalse(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC)).thenReturn(new ArrayList<>());
    ProductAndItemsVO result = this.productServiceImpl
        .getProductDetailsByProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
            ProductServiceImplTest.USERNAME, ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(this.itemService).findItemsByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_WITH_UNSYNC);
    verify(masterDataConstructorService)
        .constructProductAndItemWithMasterData(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productUnsync, this.listOfItems, true);
    verify(this.catalogService).getItemCatalogsWithCategoryHierarchy(eq(ProductServiceImplTest.USERNAME),
        eq(ProductServiceImplTest.REQUEST_ID), any(Product.class));
    verify(this.itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(anyString(),anyString());
  }

  @Test
  public void updateOff2OnFlagByProductSkusTest() throws Exception{
    List<String> stringList =
        productServiceImpl.updateOff2OnFlagByProductSkus(STORE_ID, stringBooleanMap, Constants.DEFAULT_UPDATED_BY,
            Constants.ACCESS_CHANNEL, Constants.DEFAULT_CLIENT_ID, Constants.DEFAULT_REQUEST_ID, Boolean.FALSE);
    Mockito.verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU, true, Constants.DEFAULT_UPDATED_BY, new ArrayList<>(), Constants.DEFAULT_REQUEST_ID);
    Assertions.assertTrue(CollectionUtils.isEmpty(stringList));
  }

  @Test
  public void updateOff2OnFlagByProductSkusTestupdateOff2OnHistoryTrue() throws Exception{
    List<String> stringList =
        productServiceImpl.updateOff2OnFlagByProductSkus(STORE_ID, stringBooleanMap, Constants.DEFAULT_UPDATED_BY,
            Constants.ACCESS_CHANNEL, Constants.DEFAULT_CLIENT_ID, Constants.DEFAULT_REQUEST_ID, Boolean.TRUE);
    Mockito.verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU, true, Constants.DEFAULT_UPDATED_BY, new ArrayList<>(), Constants.DEFAULT_REQUEST_ID);
    Assertions.assertTrue(CollectionUtils.isEmpty(stringList));
  }

  @Test
  public void updateOff2OnFlagByProductSkusExceptionTest() throws Exception{
    Mockito.doThrow(Exception.class).when(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU, true, Constants.DEFAULT_UPDATED_BY, new ArrayList<>(), Constants.DEFAULT_REQUEST_ID);
    List<String> stringList =
        productServiceImpl.updateOff2OnFlagByProductSkus(STORE_ID, stringBooleanMap, Constants.DEFAULT_UPDATED_BY,
            Constants.ACCESS_CHANNEL, Constants.DEFAULT_CLIENT_ID, Constants.DEFAULT_REQUEST_ID, Boolean.FALSE);
    Mockito.verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU, true, Constants.DEFAULT_UPDATED_BY, new ArrayList<>(), Constants.DEFAULT_REQUEST_ID);
    Assertions.assertTrue(!CollectionUtils.isEmpty(stringList));
    Assertions.assertEquals(PRODUCT_SKU, stringList.get(0));
  }

  @Test
  public void getProductL3SummaryWithoutSolrResponse() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    ReflectionTestUtils.setField(productServiceImpl, "externalSearchReindexEnabled", true);
    Mockito.when(productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(),
            any(ProductSummaryRequestVo.class), any(PageRequest.class)))
        .thenReturn(new PageImpl<>(new ArrayList<>(), PageRequest.of(0, 10), 0));
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(true);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE_1).keyword(PRODUCT_SKU_1).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(kafkaProducer)
        .send(eq(ProductDomainEventName.TRIGGER_REINDEX_WITH_EXTERNAL_SEARCH), eq(PRODUCT_SKU_1),
            any(ExternalSearchReindexToSolrEventModel.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().size());
  }

  @Test
  public void getProductL3SummaryWithoutSolrResponseEmptyKeyword() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    ReflectionTestUtils.setField(productServiceImpl, "externalSearchReindexEnabled", true);
    Mockito.when(productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(),
            any(ProductSummaryRequestVo.class), any(PageRequest.class)))
        .thenReturn(new PageImpl<>(new ArrayList<>(), PageRequest.of(0, 10), 0));
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(true);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE_1).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().size());
  }

  @Test
  public void getProductL3SummaryWithoutSolrResponseSwitchDisabled() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    ReflectionTestUtils.setField(productServiceImpl, "externalSearchReindexEnabled", false);
    Mockito.when(productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(),
            any(ProductSummaryRequestVo.class), any(PageRequest.class)))
        .thenReturn(new PageImpl<>(new ArrayList<>(), PageRequest.of(0, 10), 0));
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(true);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE_1).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().size());
  }

  @Test
  public void getProductL3SummaryWithoutSolrResponseDifferentProductSku() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    ReflectionTestUtils.setField(productServiceImpl, "externalSearchReindexEnabled", true);
    Mockito.when(productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(),
            any(ProductSummaryRequestVo.class), any(PageRequest.class)))
        .thenReturn(new PageImpl<>(new ArrayList<>(), PageRequest.of(0, 10), 0));
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(true);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE_1).keyword(PRODUCT_SKU_2).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().size());
  }

  @Test
  public void getProductL3SummaryWithoutSolrResponseInvalidProductSku() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    ReflectionTestUtils.setField(productServiceImpl, "externalSearchReindexEnabled", true);
    Mockito.when(productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(),
            any(ProductSummaryRequestVo.class), any(PageRequest.class)))
        .thenReturn(new PageImpl<>(new ArrayList<>(), PageRequest.of(0, 10), 0));
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE_1).keyword(PRODUCT_SKU_1).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    productSolrs.get(0).setSynchronized(true);
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setOff2OnChannelActive(null);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals( productL3SummaryResponse.getContent().get(0).getMaxNormalPrice(), 33333333,0);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getMinSellingPrice());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1SuspensionTrue() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setOff2OnChannelActive(null);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList(), any(),
            anyString(), eq(ProductFieldNames.PRODUCT_TYPE), anyString(), anyString(), anyString())).thenReturn(products);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).suspended(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    assertNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals( productL3SummaryResponse.getContent().get(0).getMaxNormalPrice(),33333333, 0);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getMinSellingPrice());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1SuspensionTrueVCNot1() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setOff2OnChannelActive(null);
    productSolrs.get(0).setVariantCount(1);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList(), any(),
            anyString(), eq(ProductFieldNames.PRODUCT_TYPE), anyString(), anyString(), anyString())).thenReturn(products);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).suspended(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    assertNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals( productL3SummaryResponse.getContent().get(0).getMaxNormalPrice(), 33333333,0);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getMinSellingPrice());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1SuspensionTrueWithNullValues() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setOff2OnChannelActive(null);
    productSolrs.get(0).setIsArchived(null);
    productSolrs.get(0).setVariantCount(null);
    productSolrs.get(0).setMaximumListPrice(null);
    productSolrs.get(0).setMaximumSellingPrice(null);
    productSolrs.get(0).setMinimumListPrice(null);
    productSolrs.get(0).setMinimumSellingPrice(null);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList(), any(),
            anyString(), eq(ProductFieldNames.PRODUCT_TYPE), anyString(), anyString(), anyString())).thenReturn(products);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).suspended(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    assertNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals( productL3SummaryResponse.getContent().get(0).getMaxNormalPrice(),0, 0);
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getMinSellingPrice());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getVariantCount());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithMerchantCodeEmpty() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setOff2OnChannelActive(null);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList(), any(),
            anyString(), eq(ProductFieldNames.PRODUCT_TYPE), anyString(), anyString(), anyString())).thenReturn(products);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(null).build(),
            PageRequest.of(0, 10), false));
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1WithPromo() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    products.get(0).setCncActivated(true);
    products.get(1).setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1WithoutVariantCount() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(1).setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(null);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1WithPromoFalse() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setIsPreOrderActive(false);
    productSolrs.get(0).setOff2OnChannelActive(false);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setMasterCatalog(null);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1WithScoreEmpty() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setIsPreOrderActive(false);
    productSolrs.get(0).setOff2OnChannelActive(false);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList())).thenReturn(new ArrayList<>());
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository).findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(),
        anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    assertNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1WithScoreNull() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "categoryCodesLimitInSizeChartListing", 20);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.stream().forEach(product1 -> product1.setProductScore(null));
    productSolrs.get(0).setIsPreOrderActive(false);
    productSolrs.get(0).setOff2OnChannelActive(false);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList(), any(),
            anyString(), anyString(), eq(ProductFieldNames.PRODUCT_TYPE), anyString(),
            anyString(), anyString(), anyString())).thenReturn(products);
    Mockito.when(
            productCacheableService.getCategoryCodesCachedByAttributeCode(STORE_ID, ATTRIBUTE_CODE))
        .thenReturn(Collections.singletonList(CATEGORY_CODE));
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).sizeAttributeCode(SIZE_ATTRIBUTE_CODE).sizeChartCode(SIZE_CHART_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    assertNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Mockito.verify(productCacheableService)
        .getCategoryCodesCachedByAttributeCode(STORE_ID, SIZE_ATTRIBUTE_CODE);
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountNot1WithScore2() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "categoryCodesLimitInSizeChartListing", 0);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.stream().forEach(product1 -> product1.setProductScore(null));
    productSolrs.get(0).setIsPreOrderActive(false);
    productSolrs.get(0).setOff2OnChannelActive(false);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList(), any(),
            anyString(), anyString(), eq(ProductFieldNames.PRODUCT_TYPE), anyString(),
            anyString(), anyString(), anyString())).thenReturn(products);
    Mockito.when(
            productCacheableService.getCategoryCodesCachedByAttributeCode(STORE_ID, ATTRIBUTE_CODE))
        .thenReturn(Collections.singletonList(CATEGORY_CODE));
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).sizeAttributeCode(SIZE_ATTRIBUTE_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    assertNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Mockito.verify(productCacheableService)
        .getCategoryCodesCachedByAttributeCode(STORE_ID, SIZE_ATTRIBUTE_CODE);
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount1_mppSwitchOnCnc1pOff() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "cncForWarehouseFeatureSwitch", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ItemViewConfig cncItemViewConfig = new ItemViewConfig();
    cncItemViewConfig.setBuyable(true);
    cncItemViewConfig.setDiscoverable(false);
    cncItemViewConfig.setChannel("CNC");
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    ItemViewConfig defaultConfig = new ItemViewConfig();
    defaultConfig.setChannel("DEFAULT");
    defaultConfig.setItemDiscoverableSchedules(itemDiscoverableSchedule);
    defaultConfig.setItemBuyableSchedules(itemBuyableSchedule);
    item.setItemViewConfigs(Set.of(defaultConfig,cncItemViewConfig));
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
    Assertions.assertEquals(TEN_DAYS_AGO, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemDiscoverableSchedules().getStartDateTime());
    Assertions.assertEquals(TEN_DAYS_AFTER, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemDiscoverableSchedules().getEndDateTime());
    Assertions.assertTrue(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemBuyableSchedules().isBuyable());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount1_mppSwitchOnCnc1pOff2() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "cncForWarehouseFeatureSwitch", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ItemViewConfig cncItemViewConfig = new ItemViewConfig();
    cncItemViewConfig.setBuyable(false);
    cncItemViewConfig.setDiscoverable(true);
    cncItemViewConfig.setChannel("CNC");
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    ItemViewConfig defaultConfig = new ItemViewConfig();
    defaultConfig.setChannel("DEFAULT");
    defaultConfig.setItemDiscoverableSchedules(itemDiscoverableSchedule);
    defaultConfig.setItemBuyableSchedules(itemBuyableSchedule);
    item.setItemViewConfigs(Set.of(defaultConfig,cncItemViewConfig));
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
    Assertions.assertEquals(TEN_DAYS_AGO, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemDiscoverableSchedules().getStartDateTime());
    Assertions.assertEquals(TEN_DAYS_AFTER, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemDiscoverableSchedules().getEndDateTime());
    Assertions.assertTrue(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemBuyableSchedules().isBuyable());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount1_mppSwitchOnCnc1pOff3() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "cncForWarehouseFeatureSwitch", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ItemViewConfig cncItemViewConfig = new ItemViewConfig();
    cncItemViewConfig.setBuyable(false);
    cncItemViewConfig.setDiscoverable(false);
    cncItemViewConfig.setChannel("CNC");
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    ItemViewConfig defaultConfig = new ItemViewConfig();
    defaultConfig.setChannel("DEFAULT");
    defaultConfig.setItemDiscoverableSchedules(itemDiscoverableSchedule);
    defaultConfig.setItemBuyableSchedules(itemBuyableSchedule);
    item.setItemViewConfigs(Set.of(defaultConfig,cncItemViewConfig));
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
    Assertions.assertEquals(TEN_DAYS_AGO, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemDiscoverableSchedules().getStartDateTime());
    Assertions.assertEquals(TEN_DAYS_AFTER, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemDiscoverableSchedules().getEndDateTime());
    Assertions.assertTrue(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getItemViewConfigs().stream()
        .filter(viewConfigResponse -> viewConfigResponse.getChannel().equals(Constants.DEFAULT)).findFirst().get().getItemBuyableSchedules().isBuyable());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount1_mppSwitchOn() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "cncForWarehouseFeatureSwitch", true);
    ReflectionTestUtils.setField(productServiceImpl, "sizeChartAdditionForProduct", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemBuyableSchedules(itemBuyableSchedule);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemDiscoverableSchedules(itemDiscoverableSchedule);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
    Assertions.assertEquals(TEN_DAYS_AGO, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
        .getItemViewConfigs().get(0).getItemDiscoverableSchedules().getStartDateTime());
    Assertions.assertEquals(TEN_DAYS_AFTER, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
        .getItemViewConfigs().get(0).getItemDiscoverableSchedules().getEndDateTime());
    Assertions.assertTrue(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
        .getItemViewConfigs().get(0).getItemBuyableSchedules().isBuyable());
  }

  @Test
  public void getProductL3SummaryResponseScheduleEndDateNullTest() throws IOException {
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    itemPickupPoint.setWholesalePriceExists(true);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    itemBuyableSchedule.setEndDateTime(null);
    itemDiscoverableSchedule.setEndDateTime(null);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemBuyableSchedules(itemBuyableSchedule);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemDiscoverableSchedules(itemDiscoverableSchedule);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(PICKUP_POINT_CODE)));
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
        .getItemViewConfigs().get(0).getItemDiscoverableSchedules());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
        .getItemViewConfigs().get(0).getItemBuyableSchedules());
  }

  @Test
  public void getProductL3SummaryResponseScheduleEndDateTest() throws IOException {
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    itemPickupPoint.setWholesalePriceExists(true);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    itemBuyableSchedule.setEndDateTime(null);
    itemDiscoverableSchedule.setEndDateTime(null);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemBuyableSchedules(itemBuyableSchedule);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemDiscoverableSchedules(itemDiscoverableSchedule);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(Constants.WHOLESALE_PRICE)));
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).sizeChartCode(SIZE_CHART_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  @Test
  public void getProductL3SummaryResponseScheduleEndDateNull2Test() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "multiGetItemsInL3Listing", false);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    itemPickupPoint.setWholesalePriceExists(true);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    itemBuyableSchedule.setEndDateTime(null);
    itemDiscoverableSchedule.setEndDateTime(null);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemBuyableSchedules(itemBuyableSchedule);
    item.getItemViewConfigs().stream().findFirst().orElse(new ItemViewConfig())
        .setItemDiscoverableSchedules(itemDiscoverableSchedule);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    itemPickupPoint.setWholesalePriceExists(true);
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Mockito.verify(cacheItemHelperService)
        .findCacheableByStoreIdAndProductSku(anyString(), anyString());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
        .getItemViewConfigs().get(0).getItemDiscoverableSchedules());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
        .getItemViewConfigs().get(0).getItemBuyableSchedules());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCountWithNoL5Test() throws IOException {
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(null);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemPickupPointService).findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  @Test
  public void getProductL3SummaryResponsereplaceOfferPriceWithMerchantPromoPriceInSellerSideTrue() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "replaceOfferPriceWithMerchantPromoPriceInSellerSide", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount2_mppSwitchOn() throws IOException {
    Mockito.when(
            productCategoryBaseClient.getCategoryAndEligibleFlagMap(STORE_ID, SIZE_ATTRIBUTE_CODE,
                Collections.singletonList(CATEGORY_CODE)))
        .thenReturn(Map.of(CATEGORY_CODE, Boolean.TRUE));
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    ReflectionTestUtils.setField(productServiceImpl, "sizeChartAdditionForProduct", true);
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(productCacheableService.getCategoryCodesCachedByAttributeCode(STORE_ID,
        SIZE_ATTRIBUTE_CODE)).thenReturn(new ArrayList<>());
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE)
                .sizeAttributeCode(SIZE_ATTRIBUTE_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(productCategoryBaseClient)
        .getCategoryAndEligibleFlagMap(STORE_ID, SIZE_ATTRIBUTE_CODE,
            Collections.singletonList(CATEGORY_CODE));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNull(productL3SummaryResponse.getContent().get(0).getSizeChartCode());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Mockito.verify(productCacheableService)
        .getCategoryCodesCachedByAttributeCode(STORE_ID, SIZE_ATTRIBUTE_CODE);
  }

  @Test
  public void getProductL3SummaryResponseWithL5Count0_mppSwitchOn() throws IOException {
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    products.get(0).setCncActivated(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(0);
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE_1)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID,
        PRODUCT_SKU_JSON)).thenReturn(Arrays.asList(itemPickupPoint));
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE_1));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount1_mppSwitchOn_syncItem() throws IOException {
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setSynchronized(true);
    item.setGeneratedItemName(GENERATED_ITEM_NAME);
    item.setMainImageUrl(LOCATION_PATH);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
    Assertions.assertEquals(LOCATION_PATH,
        productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
            .getMasterDataItemImages().get(0).getLocationPath());
    Assertions.assertEquals(GENERATED_ITEM_NAME,
        productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse()
            .getGeneratedItemName());
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount1_0Items() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    ReflectionTestUtils.setField(productServiceImpl, "addDeleteVariantSwitch", true);
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(
        productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(),
            anyList())).thenReturn(products);
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(new ArrayList());
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(new ArrayList<>());
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl
        .getProductL3SummaryResponse(STORE_ID, ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(cacheItemHelperService)
        .findCacheableByStoreIdAndProductSku(anyString(), anyString());
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  private Item getItem(String itemSku) {
    Item item = new Item();
    item.setItemSku(itemSku);
    item.setProductSku(itemSku.substring(0, itemSku.lastIndexOf("-")));
    DiscountPrice discountPrice = new DiscountPrice();
    discountPrice.setDiscountPrice(5000.0);

    List<DiscountPrice> discountPrices = new ArrayList<>();
    discountPrices.add(discountPrice);

    Price price = new Price();
    price.setChannel(DEFAULT);
    price.setOfferPrice(100000.0);
    price.setListPrice(10000.0);
    price.setListOfDiscountPrices(discountPrices);
    price.setCurrency(CURRENCY);
    price.setMerchantPromoDiscountPrice(discountPrice);

    Price price1 = new Price();
    price1.setChannel(DEFAULT);
    price1.setOfferPrice(90000.0);
    price1.setListPrice(10000.0);
    price1.setCurrency(CURRENCY);
    Set<Price> prices = new HashSet<>();
    prices.add(price);
    prices.add(price1);
    item.setStoreId(STORE_ID);

    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setBuyable(true);
    itemViewConfig.setDiscoverable(true);
    item.setItemViewConfigs(new HashSet<>(Arrays.asList(itemViewConfig)));

    item.setSynchronized(false);
    item.setPrice(prices);
    item.setActivePromoBundlings(Collections.singleton(PromoType.PROMO_BUNDLING.name()));
    return item;
  }

  @Test
  public void toggleArchiveProductTest() throws Exception {
    EditItemResponse editItemResponse = new EditItemResponse();
    editItemResponse.setCncActivated(true);
    Boolean doArchive = Boolean.TRUE;
    product.setStoreId(STORE_ID);
    product.setArchived(false);
    product.setProductSku(PRODUCT_SKU);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        anyString(), anyString())).thenReturn(product);
    Mockito.when(objectConverterService.convertToProductAndItemEventModel(any(ProductAndItemsVO.class)))
        .thenReturn(new ProductAndItemEventModel());
    when(this.itemService.toggleArchiveByProductSku(STORE_ID, USERNAME, PRODUCT_SKU, doArchive, StringUtils.EMPTY)).thenReturn(
        editItemResponse);
    Mockito.doNothing().when(saveAndPublishService)
        .publishSolrUpdateEvent(anyList());
    editItemResponse = productServiceImpl.toggleArchiveProduct(STORE_ID, USERNAME, PRODUCT_SKU, doArchive,StringUtils.EMPTY);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    verify(this.itemService).toggleArchiveByProductSku(ProductServiceImplTest.STORE_ID, USERNAME, ProductServiceImplTest.PRODUCT_SKU, true, StringUtils.EMPTY);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.product, Arrays.asList(ProductChangeEventType.ARCHIVE_FLAG_CHANGE),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    Mockito.verify(saveAndPublishService).publishSolrUpdateEvent(anyList());
    Mockito.verify(objectConverterService).convertToProductAndItemEventModel(any(ProductAndItemsVO.class));
    assertNull(editItemResponse.getApiErrorCode());
  }

  @Test
  public void toggleArchiveProductFalse() throws Exception {
    EditItemResponse editItemResponse = new EditItemResponse();
    editItemResponse.setCncActivated(true);
    Boolean doArchive = Boolean.FALSE;
    product.setStoreId(STORE_ID);
    product.setArchived(false);
    product.setProductSku(PRODUCT_SKU);
    product.setOff2OnChannelActive(true);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        anyString(), anyString())).thenReturn(product);
    when(this.itemService.toggleArchiveByProductSku(STORE_ID, USERNAME, PRODUCT_SKU, doArchive,StringUtils.EMPTY)).thenReturn(
        editItemResponse);
    editItemResponse = productServiceImpl.toggleArchiveProduct(STORE_ID, USERNAME, PRODUCT_SKU, doArchive, StringUtils.EMPTY);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    Assertions.assertEquals(ApiErrorCode.TOGGLE_UNARCHIVE_FAILED_FOR_SAME_FLAG,
        editItemResponse.getApiErrorCode());
  }

  @Test
  public void toggleArchiveProductArchivedProductTest() throws Exception {
    EditItemResponse editItemResponse = new EditItemResponse();
    editItemResponse.setCncActivated(true);
    Boolean doArchive = Boolean.TRUE;
    product.setStoreId(STORE_ID);
    product.setArchived(true);
    product.setProductSku(PRODUCT_SKU);
    product.setOff2OnChannelActive(true);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        anyString(), anyString())).thenReturn(product);
    when(this.itemService.toggleArchiveByProductSku(STORE_ID, USERNAME, PRODUCT_SKU, doArchive, StringUtils.EMPTY)).thenReturn(
        editItemResponse);
    editItemResponse = productServiceImpl.toggleArchiveProduct(STORE_ID, USERNAME, PRODUCT_SKU, doArchive,StringUtils.EMPTY);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU);
    Assertions.assertEquals(ApiErrorCode.TOGGLE_ARCHIVE_FAILED_FOR_SAME_FLAG,
        editItemResponse.getApiErrorCode());
  }

  @Test
  public void toggleArchiveProductArchivedProductUnArchivingTest() throws Exception {
    productSync.setArchived(false);
    productServiceImpl.toggleArchiveProduct(STORE_ID, USERNAME, PRODUCT_SKU_SYNC, false, StringUtils.EMPTY);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
  }

  @Test
  public void getProductNamesByKeywordTest() {
    Mockito.when(productSolrRepository
            .getProductNameByProductSummaryRequest(eq(STORE_ID), any(ProductSummaryRequestVo.class),
                any(PageRequest.class)))
        .thenReturn(new PageImpl<>(Arrays.asList(productSolr1), PageRequest.of(0, 10), 10));
    Page<ProductNameSuggestionResponse> response = productServiceImpl.getProductNamesByKeyword(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).archived(false).keyword(PRODUCT_NAME).build(),
        PageRequest.of(0, 10));
    Mockito.verify(productSolrRepository)
        .getProductNameByProductSummaryRequest(eq(STORE_ID), any(ProductSummaryRequestVo.class),
            any(PageRequest.class));
    Assertions.assertEquals(NEW_PRODUCT_NAME, response.getContent().get(0).getProductName());
    Assertions.assertEquals(PRODUCT_SKU, response.getContent().get(0).getProductSku());
  }

  @Test
  public void getProductNamesByKeywordTest_empty() {
    Mockito.when(productSolrRepository
            .getProductNameByProductSummaryRequest(eq(STORE_ID), any(ProductSummaryRequestVo.class),
                any(PageRequest.class)))
        .thenReturn(new PageImpl<>(Arrays.asList(), PageRequest.of(0, 10), 10));
    Page<ProductNameSuggestionResponse> response = productServiceImpl.getProductNamesByKeyword(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).archived(false).keyword(PRODUCT_NAME).build(),
        PageRequest.of(0, 10));
    Mockito.verify(productSolrRepository)
        .getProductNameByProductSummaryRequest(eq(STORE_ID), any(ProductSummaryRequestVo.class),
            any(PageRequest.class));
    Assertions.assertEquals(response.getContent().size(), 0);
  }

  @Test
  public void getPromoLabelsMppTrue() {
    Mockito.when(itemPickupPointService.
        getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(itemPickupPoint));
    productAndItemsVO.getProduct().setStoreId(STORE_ID);
    productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    productAndItemsVO.getProduct().setOff2OnChannelActive(true);
    productAndItemsVO.getProduct().setPreOrder(null);
    itemPickupPoint.setMerchantPromoDiscount(true);
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(Constants.WHOLESALE_PRICE)));
    List<String> promoLabels = productServiceImpl.getPromoLabels(productAndItemsVO, productL3Response);
    Assertions.assertNotNull(promoLabels);
    Assertions.assertEquals(3, promoLabels.size());
  }

  @Test
  public void getPromoLabelsMppTrueMultiItem() {
    Mockito.when(itemPickupPointService.
        getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(itemPickupPoint));
    productAndItemsVO.getProduct().setStoreId(STORE_ID);
    productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    productAndItemsVO.getProduct().setOff2OnChannelActive(true);
    productAndItemsVO.getProduct().setPreOrder(null);
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setMerchantPromoDiscount(false);
    productAndItemsVO.setItems(Arrays.asList(item, new Item()));
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(Constants.WHOLESALE_PRICE)));
    List<String> promoLabels = productServiceImpl.getPromoLabels(productAndItemsVO, productL3Response);
    Assertions.assertNotNull(promoLabels);
    Assertions.assertEquals(2, promoLabels.size());
  }

  @Test
  public void getPromoLabelsMppTrueMultiItemActivePromoBundlingNotNull() {
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(Constants.WHOLESALE_PRICE)));
    Mockito.when(itemPickupPointService.
        getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(itemPickupPoint));
    productAndItemsVO.getProduct().setStoreId(STORE_ID);
    productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    productAndItemsVO.getProduct().setOff2OnChannelActive(true);
    productAndItemsVO.getProduct().setPreOrder(null);
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setMerchantPromoDiscount(false);
    productAndItemsVO.setItems(Arrays.asList(item, new Item()));
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(Constants.WHOLESALE_PRICE)));
    List<String> promoLabels = productServiceImpl.getPromoLabels(productAndItemsVO, productL3Response);
    Assertions.assertNotNull(promoLabels);
    Assertions.assertEquals(2, promoLabels.size());
  }

  @Test
  public void getPromoLabelsMppTrueMultiItemActivePromoBundlingNull() {
    itemPickupPoint.setActivePromoBundlings(
        new HashSet<>(Collections.singletonList(Constants.COMPLEMENTARY_FREE_SAMPLE_PRODUCT)));
    Mockito.when(itemPickupPointService.
        getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(itemPickupPoint));
    productAndItemsVO.getProduct().setStoreId(STORE_ID);
    productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    productAndItemsVO.getProduct().setOff2OnChannelActive(true);
    productAndItemsVO.getProduct().setPreOrder(null);
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setMerchantPromoDiscount(false);
    productAndItemsVO.setItems(Arrays.asList(item, new Item()));
    List<String> promoLabels = productServiceImpl.getPromoLabels(productAndItemsVO, productL3Response);
    Assertions.assertNotNull(promoLabels);
    Assertions.assertEquals(1, promoLabels.size());
  }

  @Test
  public void getPromoLabelsMppTrueMultiItemFbbActivated() {
    Mockito.when(itemPickupPointService.
            getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(Collections.singletonList(itemPickupPoint));
    productAndItemsVO.getProduct().setStoreId(STORE_ID);
    productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    productAndItemsVO.getProduct().setOff2OnChannelActive(true);
    productAndItemsVO.getProduct().setPreOrder(null);
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setMerchantPromoDiscount(false);
    productAndItemsVO.setItems(Arrays.asList(item, new Item()));
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(Constants.WHOLESALE_PRICE)));
    productL3Response.setFbbActivated(true);
    List<String> promoLabels = productServiceImpl.getPromoLabels(productAndItemsVO, productL3Response);
    Assertions.assertNotNull(promoLabels);
    Assertions.assertEquals(2, promoLabels.size());
  }

  @Test
  public void getPromoLabelsMppTrueMultiItemPickupPointFbbActivated() {
    itemPickupPoint.setWholesalePriceExists(true);
    itemPickupPoint.setFbbActivated(true);
    itemPickupPoint.setMerchantPromoDiscount(false);
    productAndItemsVO.setItems(Arrays.asList(item, new Item()));
    itemPickupPoint.setActivePromoBundlings(new HashSet<>(Collections.singletonList(Constants.WHOLESALE_PRICE)));
    Mockito.when(itemPickupPointService.
            getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(Collections.singletonList(itemPickupPoint));
    productAndItemsVO.getProduct().setStoreId(STORE_ID);
    productAndItemsVO.getProduct().setProductSku(PRODUCT_SKU);
    productAndItemsVO.getProduct().setOff2OnChannelActive(true);
    productAndItemsVO.getProduct().setPreOrder(null);
    productL3Response.setFbbActivated(true);
    List<String> promoLabels = productServiceImpl.getPromoLabels(productAndItemsVO, productL3Response);
    Assertions.assertNotNull(promoLabels);
    Assertions.assertEquals(2, promoLabels.size());
    assertFalse(productL3Response.isOtherFbbPickupPointCodesMapped());
  }

  @Test
  public void getPromoLabelsNullRequest() {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getPromoLabels(null, productL3Response));
  }

  @Test
  public void getProductsCountByCategoryCategoryBrandRequestNullTest() {
    List<List<String>> categoryCodesInBatches = new ArrayList<>();
    categoryCodesInBatches.add(null);
    Long totalProducts = productServiceImpl.getProductsCountByCategory(STORE_ID, null, MERCHANT_CODE);
    Assertions.assertEquals(Constants.LONG_ZERO, totalProducts);
    Mockito.verify(solrRepository)
        .getCountByStoreIdAndCategoryAndBrandAndMarkForDeleteFalse(STORE_ID, categoryCodesInBatches, null,
            MERCHANT_CODE);
  }

  @Test
  public void getProductsCountByCategoryCategoryBrandRequestVariablesNullTest() {
    List<List<String>> categoryCodesInBatches = new ArrayList<>();
    categoryCodesInBatches.add(null);
    Long totalProducts =
        productServiceImpl.getProductsCountByCategory(STORE_ID, new CategoryBrandRequest(), MERCHANT_CODE);
    Assertions.assertEquals(Constants.LONG_ZERO, totalProducts);
    Mockito.verify(solrRepository)
        .getCountByStoreIdAndCategoryAndBrandAndMarkForDeleteFalse(STORE_ID, categoryCodesInBatches, null,
            MERCHANT_CODE);
  }

  @Test
  public void getProductsCountByCategoryCategoryBrandRequestCategoryNullTest() {
    List<List<String>> categoryCodesInBatches = new ArrayList<>();
    categoryCodesInBatches.add(null);
    CategoryBrandRequest categoryBrandRequest = new CategoryBrandRequest();
    categoryBrandRequest.setBrand(Arrays.asList(BRAND));
    Long totalProducts = productServiceImpl.getProductsCountByCategory(STORE_ID, categoryBrandRequest, MERCHANT_CODE);
    Assertions.assertEquals(Constants.LONG_ZERO, totalProducts);
    Mockito.verify(solrRepository)
        .getCountByStoreIdAndCategoryAndBrandAndMarkForDeleteFalse(STORE_ID, categoryCodesInBatches, null,
            MERCHANT_CODE);
  }

  @Test
  public void getProductsCountByCategoryCategoryBrandRequestBrandNullTest(){
    CategoryBrandRequest categoryBrandRequest = new CategoryBrandRequest();
    categoryBrandRequest.setCategory(Arrays.asList(CATEGORY_CODE));
    Long totalProducts = productServiceImpl.getProductsCountByCategory(STORE_ID, categoryBrandRequest, MERCHANT_CODE);
    Mockito.verify(productCategoryBaseClient).getCnCategoryCodes(eq(categoryBrandRequest.getCategory()));
    Assertions.assertEquals(Constants.LONG_ZERO, totalProducts);
  }

  @Test
  public void getProductsCountByCategoryCategoryBrandRequestBrandCnNullTest() {
    CategoryBrandRequest categoryBrandRequest = new CategoryBrandRequest();
    categoryBrandRequest.setCategory(Arrays.asList(CATEGORY_CODE));
    categoryBrandRequest.setBrand(Arrays.asList(BRAND));
    Mockito.when(productCategoryBaseClient.getCnCategoryCodes(categoryBrandRequest.getCategory())).thenReturn(null);
    Long totalProducts = productServiceImpl.getProductsCountByCategory(STORE_ID, categoryBrandRequest, MERCHANT_CODE);
    Mockito.verify(productCategoryBaseClient).getCnCategoryCodes(eq(categoryBrandRequest.getCategory()));
    Assertions.assertEquals(Constants.LONG_ZERO, totalProducts);
  }

  @Test
  public void getProductsCountByCategoryCategoryBrandRequestBrandFewCnTest() {
    CategoryBrandRequest categoryBrandRequest = new CategoryBrandRequest();
    categoryBrandRequest.setCategory(Arrays.asList(CATEGORY_CODE));
    categoryBrandRequest.setBrand(Arrays.asList(BRAND));
    Mockito.when(productCategoryBaseClient.getCnCategoryCodes(categoryBrandRequest.getCategory()))
        .thenReturn(categoryBrandRequest.getCategory());
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(Constants.DEFAULT_STORE_ID, SystemParameterNames.SOLR_CATEGORY_LIST_BATCH_SIZE))
        .thenReturn(new SystemParameter(STORE_ID, SystemParameterNames.SOLR_CATEGORY_LIST_BATCH_SIZE,
            SOLR_CATEGORY_LIST_BATCH_SIZE, ""));
    List<List<String>> categoriesInBatches = new ArrayList<>();
    categoriesInBatches.add(categoryBrandRequest.getCategory());
    Mockito.when(solrRepository
        .getCountByStoreIdAndCategoryAndBrandAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID, categoriesInBatches,
            categoryBrandRequest.getBrand(), MERCHANT_CODE)).thenReturn(PRODUCT_COUNT);
    Long totalProducts =
        productServiceImpl.getProductsCountByCategory(Constants.DEFAULT_STORE_ID, categoryBrandRequest, MERCHANT_CODE);
    Mockito.verify(productCategoryBaseClient).getCnCategoryCodes(eq(categoryBrandRequest.getCategory()));
    Mockito.verify(systemParameterService)
        .findValueByStoreIdAndVariable(Constants.DEFAULT_STORE_ID, SystemParameterNames.SOLR_CATEGORY_LIST_BATCH_SIZE);

    Mockito.verify(solrRepository)
        .getCountByStoreIdAndCategoryAndBrandAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID, categoriesInBatches,
            categoryBrandRequest.getBrand(), MERCHANT_CODE);
    Assertions.assertEquals(PRODUCT_COUNT, totalProducts);
  }

  @Test
  public void getProductsCountByCategoryCategoryBrandRequestBrandManyCnTest() {
    CategoryBrandRequest categoryBrandRequest = new CategoryBrandRequest();
    categoryBrandRequest.setCategory(Arrays.asList(CATEGORY_CODE));
    categoryBrandRequest.setBrand(Arrays.asList(BRAND));
    List<String> category = new ArrayList<>();
    for (int listSize = 0; listSize < Integer.valueOf(SOLR_CATEGORY_LIST_BATCH_SIZE); listSize++) {
      category.add(CATEGORY_CODE);
    }
    Mockito.when(productCategoryBaseClient.getCnCategoryCodes(categoryBrandRequest.getCategory())).thenReturn(category);
    Mockito.when(systemParameterService
            .findValueByStoreIdAndVariable(Constants.DEFAULT_STORE_ID, SystemParameterNames.SOLR_CATEGORY_LIST_BATCH_SIZE))
        .thenReturn(new SystemParameter(STORE_ID, SystemParameterNames.SOLR_CATEGORY_LIST_BATCH_SIZE,
            SOLR_CATEGORY_LIST_BATCH_SIZE, ""));
    List<List<String>> categoriesInBatches = new ArrayList<>();
    categoriesInBatches.add(category);
    Mockito.when(solrRepository
        .getCountByStoreIdAndCategoryAndBrandAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID, categoriesInBatches,
            categoryBrandRequest.getBrand(), MERCHANT_CODE)).thenReturn(PRODUCT_COUNT);
    Long totalProducts =
        productServiceImpl.getProductsCountByCategory(Constants.DEFAULT_STORE_ID, categoryBrandRequest, MERCHANT_CODE);
    Mockito.verify(productCategoryBaseClient).getCnCategoryCodes(eq(categoryBrandRequest.getCategory()));
    Mockito.verify(solrRepository)
        .getCountByStoreIdAndCategoryAndBrandAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID, categoriesInBatches,
            categoryBrandRequest.getBrand(), MERCHANT_CODE);
    Mockito.verify(systemParameterService)
        .findValueByStoreIdAndVariable(Constants.DEFAULT_STORE_ID, SystemParameterNames.SOLR_CATEGORY_LIST_BATCH_SIZE);
    Assertions.assertEquals(PRODUCT_COUNT, totalProducts);
  }

  @Test
  public void getPreOrderStatusByProductSkusEmptyProductSkuListTest() {
    Map<String, PreOrder> result = productServiceImpl.getPreOrderStatusByProductSkus(new ArrayList<>());
    Assertions.assertEquals(0, result.size());
  }

  @Test
  public void getPreOrderStatusByProductSkusTest() {
    List<String> productSkus = Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2);
    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU2);
    PreOrder preOrder = new PreOrder();
    preOrder.setIsPreOrder(true);
    product1.setPreOrder(preOrder);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU2))
        .thenReturn(product1);
    Map<String, PreOrder> result = productServiceImpl.getPreOrderStatusByProductSkus(productSkus);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU2);
    Assertions.assertEquals(2, result.size());
    assertNull(result.get(PRODUCT_SKU));
    Assertions.assertNotNull(result.get(PRODUCT_SKU2));
  }

  @Test
  public void getPreOrderStatusByProductSkusEmptyResponseTest() {
    List<String> productSkus = Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU))
        .thenReturn(null);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU2))
        .thenReturn(null);
    Map<String, PreOrder> result = productServiceImpl.getPreOrderStatusByProductSkus(productSkus);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU2);

    Assertions.assertEquals(0, result.size());
  }

  @Test
  public void updateEditedProductTest_productScoreChange() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.listOfItems.get(0).setOmniChannelSku(OMNI_CHANNEL_SKU);
    this.listOfItems.get(0).setItemCode(ITEM_CODE);
    productEditRequest.setOmniChannelSkuUpdateRequests(
        List.of(new OmniChannelSkuUpdateRequest(ITEM_CODE, OMNI_CHANNEL_SKU_2),
            new OmniChannelSkuUpdateRequest(ITEM_CODE, OMNI_CHANNEL_SKU_2)));
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
    verify(saveAndPublishService).publishHistoryEvent(Mockito.anyList());
  }

  @Test
  public void updateEditedProductTest_withPreOrderChanged() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setSizeChartCode(SIZE_CHART_CODE);
    this.productSyncUpdated.setPreOrder(preOrder);
    PreOrderVO preOrderVO = new PreOrderVO();
    BeanUtils.copyProperties(preOrderVO,preOrder);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(kafkaProducer).send(eq(PRODUCT_PREORDER_STATUS),
        eq(PRODUCT_SKU_SYNC_TOBE_UPDATED), eq(
            ProductPreOrderStatus.builder().preOrder(preOrderVO)
                .productSku(PRODUCT_SKU_SYNC_TOBE_UPDATED)
                .productCode(productSyncUpdated.getProductCode()).build()));
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTest_withSizeChartChangedFalse() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setSizeChartCode(SIZE_CHART_CODE);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
    when(this.productCategoryBaseClient
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
      .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
      .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
      .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
      .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    EditProductDetailDTO editProductDetailDTO1 =
        this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
            this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
            productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
      this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTest_withSizeChartChangedTrue() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    productSyncUpdated.setSizeChartChanged(true);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setSizeChartCode(SIZE_CHART_CODE);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
    when(this.productCategoryBaseClient
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
      .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
      .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
      .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
      .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    EditProductDetailDTO editProductDetailDTO1 =
        this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID, this.productSyncUpdated, null,
            false, false, editProductDetailDTO, productEditRequest);
    productEditRequest.setContentChanged(true);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
      this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
    Assertions.assertEquals(SIZE_CHART_CODE, editProductDetailDTO1.getProduct().getSizeChartCode());
    Assertions.assertEquals(SIZE_CHART_CODE, editProductDetailDTO1.getProduct().getSizeChartCode());

  }


  @Test
  public void updateEditedProductTest_withPreOrderChangedAndNoContentChange() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setPreOrder(preOrder);
    PreOrderVO preOrderVO = new PreOrderVO();
    BeanUtils.copyProperties(preOrderVO,preOrder);
    setProductAttributeResponses(productDetailResponse);
    Video video = new Video();
    video.setVideoId(PRODUCT_ITEM_ID);
    video.setSourceUrl(URL);
    Video video2 = new Video();
    video2.setVideoId(PRODUCT_ITEM_ID);
    video2.setSourceUrl(URL);
    productSyncUpdated.setVideo(video);
    productSyncTobeUpdated.setVideo(video2);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(kafkaProducer).send(eq(PRODUCT_PREORDER_STATUS),
        eq(PRODUCT_SKU_SYNC_TOBE_UPDATED), eq(
            ProductPreOrderStatus.builder().preOrder(preOrderVO)
                .productSku(PRODUCT_SKU_SYNC_TOBE_UPDATED)
                .productCode(productSyncUpdated.getProductCode()).build()));
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTest_withPreOrderChanged_andNullInExisitngEntitiy() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setPreOrder(preOrder);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setPreOrder(null);
    PreOrderVO preOrderVO = new PreOrderVO();
    BeanUtils.copyProperties(preOrderVO,preOrder);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(kafkaProducer).send(eq(PRODUCT_PREORDER_STATUS),
        eq(PRODUCT_SKU_SYNC_TOBE_UPDATED), eq(
            ProductPreOrderStatus.builder().preOrder(null)
                .productSku(PRODUCT_SKU_SYNC_TOBE_UPDATED)
                .productCode(productSyncUpdated.getProductCode()).build()));
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductHistoryExceptionTest() throws Exception {
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doThrow(Exception.class).when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTest_Exception1test() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.doThrow(Exception.class).when(this.productScoreUtil)
        .getRecommendedAttributeScore(anyList(), anyString());
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    Map<String, ItemViewConfig> itemViewConfigMap = new HashMap<>();
    itemViewConfigMap.put(listOfItems.get(0).getItemSku(), new ItemViewConfig());
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, ProductServiceImplTest.USERNAME);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    productEditRequest.setForceReview(true);
    productEditRequest.setLatefulfillment(true);
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenReturn(productDetailResponse);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, itemViewConfigMap, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID),
        eq(Constants.DEFAULT_USERNAME), anyString());
  }

  @Test
  public void updateEditedProductTest_ErrorTest() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productRepository.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED, false)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenThrow(ApplicationRuntimeException.class);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    Mockito.doThrow(Exception.class).when(this.productScoreUtil)
        .getRecommendedAttributeScore(anyList(), anyString());
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    Map<String, ItemViewConfig> itemViewConfigMap = new HashMap<>();
    itemViewConfigMap.put(listOfItems.get(0).getItemSku(), new ItemViewConfig());
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, ProductServiceImplTest.USERNAME);
    ProductEditRequest productEditRequest = new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    productEditRequest.setForceReview(true);
    productEditRequest.setLatefulfillment(true);
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenThrow(ApplicationRuntimeException.class);
    when(mapper.writeValueAsString(any())).thenReturn("");
    when(productRetryEventPublishService.insertToRetryPublish(any(ProductRetryEventPublish.class))).thenReturn(new ProductRetryEventPublish());
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, itemViewConfigMap, false, false, null,
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID),
        eq(Constants.DEFAULT_USERNAME), anyString());
  }

  @Test
  public void updateEditedProductTest_productNull() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setProductScore(null);
    Video video = new Video();
    video.setVideoId(null);
    video.setSourceUrl(URL);
    productSyncUpdated.setVideo(video);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID, null, null,
        false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID),
        eq(Constants.DEFAULT_USERNAME), anyString());
  }

  @Test
  public void updateEditedProductTest_productScoreNull() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression", VIDEO_URL_CLIENT_ID);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU);
    Video video = new Video();
    video.setVideoId(ID);
    video.setSourceUrl(URL);
    productSyncUpdated.setVideo(video);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    listOfItems.get(0).setPristineDataItem(null);
    this.productSyncTobeUpdated.setProductScore(null);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID),
        eq(Constants.DEFAULT_USERNAME), anyString());

  }

  @Test
  public void updateEditedProductTest_WithExceptionOnPublish() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression", VIDEO_URL_CLIENT_ID);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU);
    Video video = new Video();
    video.setVideoId(ID);
    video.setSourceUrl(URL);
    productSyncUpdated.setVideo(video);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    listOfItems.get(0).setPristineDataItem(null);
    this.productSyncTobeUpdated.setProductScore(null);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
    when(this.productCategoryBaseClient
      .getProductDetailByProductCode(Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
      .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
      .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
      .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
      .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID),
      eq(Constants.DEFAULT_USERNAME), anyString());

  }

  @Test
  public void updateEditedProductTestProductNotFound() throws Exception {
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(null);
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class,
          () -> this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID, this.productSyncUpdated,
              null, false, false, null, productEditRequest));
    } finally {
      verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
          Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    }
  }

  @Test
  public void updateEditedProductTest_productScoreChangeCurrentProductScoreNull() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(null);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    doNothing().when(this.saveAndPublishService).publishMerchantVoucherViewConfigChange(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenReturn(productDetailResponse);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID),
        eq(Constants.DEFAULT_USERNAME), anyString());

  }

  @Test
  public void activateProductAndItemsOnNeedCorrection_NullProductTest() throws Exception {
    when(this.productCacheableService
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(null);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), null,
            ProductType.BIG_PRODUCT, true, true, false, false));
    verify(this.productCacheableService)
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(true), any(), any());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionUpdateSpecialAttributeTest() throws Exception {
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productSync);
    when(this.itemService
        .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
            true))
        .thenReturn(editItemResponse);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(getProductDetailResponse());
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
            ProductType.BIG_PRODUCT, true, false, true, false));
    verify(this.productCacheableService)
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.itemService)
        .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
            true);
    verify(this.masterDataService)
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getItems().get(0).isLateFulfillment());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionMakeL5OfflineForArchivedProductsTest_InactiveMerchant()
      throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "skipMfdUpdateForSuspendedProduct", true);
    businessPartner.setMerchantStatus("INACTIVE");
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode())).thenReturn(businessPartner);
    when(
        this.itemService.activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
            Arrays.asList(itemActivationRequest), false)).thenReturn(editItemResponse);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode())).thenReturn(getProductDetailResponse());
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
            ProductType.BIG_PRODUCT, false, false, true, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        needCorrectionProductActivationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService).getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode());
    verify(this.itemService).activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC,
        productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
        false);
    verify(this.masterDataService).getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionMakeL5OfflineForArchivedProductsTest_ActiveMerchant()
      throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "skipMfdUpdateForSuspendedProduct", true);
    businessPartner.setMerchantStatus("ACTIVE");
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(this.productSync);
    productSync.setSuspended(true);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode())).thenReturn(businessPartner);
    when(
        this.itemService.activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
            Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode())).thenReturn(getProductDetailResponse());
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
            ProductType.BIG_PRODUCT, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        needCorrectionProductActivationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService).getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode());
    verify(this.itemService).activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC,
        productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
        true);
    verify(this.masterDataService).getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    Assertions.assertTrue(itemActivationRequest.isBuyable());
    Assertions.assertTrue(itemActivationRequest.isDiscoverable());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionMakeL5OfflineForArchivedProductsTest_ArchivedProduct()
      throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode())).thenReturn(businessPartner);
    when(
        this.itemService.activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
            Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode())).thenReturn(getProductDetailResponse());
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
            ProductType.BIG_PRODUCT, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        needCorrectionProductActivationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService).getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode());
    verify(this.itemService).activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC,
        productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
        true);
    verify(this.masterDataService).getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionFbbTrueL5AndMfdTrue() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    itemPickupPoint2.setMarkForDelete(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode()))
        .thenReturn(businessPartner);
    when(this.itemService
        .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
            Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(this.masterDataService
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode())).thenReturn(getProductDetailResponse());
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
            ProductType.BIG_PRODUCT, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        needCorrectionProductActivationRequest);
    verify(this.productCacheableService)
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService)
        .getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode());
    verify(this.itemService)
        .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
            Arrays.asList(itemActivationRequest), true);
    verify(this.masterDataService)
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
            this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionFbbTrueL5() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryRestrictionEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
      "CM");
    ProductDetailResponse productDetailResponse1 = getProductDetailResponse();
    productCategoryResponses.stream().map(ProductCategoryResponse::getCategory)
      .forEach(categoryResponse1 -> categoryResponse1.setBopisEligible(true));
    productDetailResponse1.setProductCategoryResponses(productCategoryResponses);
    productDetailResponse1.getProductCategoryResponses().stream().forEach(c -> c.getCategory().setBopisEligible(false));
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    itemPickupPoint2.setMarkForDelete(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    profileResponse.setCompany(CompanyDTO.builder().merchantType("CM").build());
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
      .thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode()))
      .thenReturn(businessPartner);
    when(this.itemService
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(xbpOutbound.getBusinessPartnerDetails(STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME, MERCHANT_CODE)).thenReturn(profileResponse);
    when(this.masterDataService
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode())).thenReturn(productDetailResponse1);
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
      new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
        ProductType.BIG_PRODUCT, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
      needCorrectionProductActivationRequest);
    verify(this.productCacheableService)
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService)
      .getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode());
    verify(this.itemService)
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true);
    verify(this.masterDataService)
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
      eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionBopisProductL5() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryRestrictionEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
      "CM");
    ProductDetailResponse productDetailResponse1 = getProductDetailResponse();
    productCategoryResponses.stream().map(ProductCategoryResponse::getCategory)
      .forEach(categoryResponse1 -> categoryResponse1.setBopisEligible(false));
    productDetailResponse1.setProductCategoryResponses(productCategoryResponses);
    productDetailResponse1.getProductCategoryResponses().stream().forEach(c -> c.getCategory().setBopisEligible(false));
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    productSync.setProductType(ProductType.BOPIS);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    itemPickupPoint2.setMarkForDelete(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    profileResponse.setCompany(CompanyDTO.builder().merchantType("CM").build());
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
      .thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode()))
      .thenReturn(businessPartner);
    when(this.itemService
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(xbpOutbound.getBusinessPartnerDetails(STORE_ID, ProductServiceImplTest.REQUEST_ID,
      ProductServiceImplTest.USERNAME, MERCHANT_CODE)).thenReturn(profileResponse);
    when(this.masterDataService
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode())).thenReturn(productDetailResponse1);
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
      new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
        ProductType.BOPIS, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
      needCorrectionProductActivationRequest);
    verify(this.productCacheableService)
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService)
      .getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode());
    verify(this.itemService)
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true);
    verify(this.masterDataService)
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
      eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(xbpOutbound).getBusinessPartnerDetails(STORE_ID, ProductServiceImplTest.REQUEST_ID,
      ProductServiceImplTest.USERNAME, MERCHANT_CODE);
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionBopisProductButCategoryEligible() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryRestrictionEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
      "CM");
    ProductDetailResponse productDetailResponse1 = getProductDetailResponse();
    productCategoryResponses.stream().map(ProductCategoryResponse::getCategory)
      .forEach(categoryResponse1 -> categoryResponse1.setBopisEligible(true));
    productDetailResponse1.setProductCategoryResponses(productCategoryResponses);
    productDetailResponse1.getProductCategoryResponses().stream().forEach(c -> c.getCategory().setBopisEligible(true));
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    productSync.setProductType(ProductType.BOPIS);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    itemPickupPoint2.setMarkForDelete(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    profileResponse.setCompany(CompanyDTO.builder().merchantType("CM").build());
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
      .thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode()))
      .thenReturn(businessPartner);
    when(this.itemService
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(xbpOutbound.getBusinessPartnerDetails(STORE_ID, ProductServiceImplTest.REQUEST_ID,
      ProductServiceImplTest.USERNAME, MERCHANT_CODE)).thenReturn(profileResponse);
    when(this.masterDataService
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode())).thenReturn(productDetailResponse1);
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
      new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
        ProductType.BOPIS, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
      needCorrectionProductActivationRequest);
    verify(this.productCacheableService)
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService)
      .getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode());
    verify(this.itemService)
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true);
    verify(this.masterDataService)
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
      eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }


  @Test
  public void activateProductAndItemsOnNeedCorrectionFbbTrueL5WithBopisCncSwitchOnNoDimensions() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCNCRestrictionEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
      "CM");
    ProductDetailResponse productDetailResponse1 = getProductDetailResponse();
    productCategoryResponses.stream().map(ProductCategoryResponse::getCategory)
      .forEach(categoryResponse1 -> categoryResponse1.setBopisEligible(true));
    productDetailResponse1.setProductCategoryResponses(productCategoryResponses);
    productDetailResponse1.getProductCategoryResponses().stream().forEach(c -> c.getCategory().setBopisEligible(false));
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    listOfItems.forEach(item1 -> {
      item1.setHeight(0.0);
      item1.setWeight(0.0);
      item1.setLength(0.0);
      item1.setWidth(0.0);
    });
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    itemPickupPoint2.setMarkForDelete(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    profileResponse.setCompany(CompanyDTO.builder().merchantType("CM").build());
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
      .thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode()))
      .thenReturn(businessPartner);
    when(this.itemService
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(xbpOutbound.getBusinessPartnerDetails(STORE_ID, ProductServiceImplTest.REQUEST_ID,
      ProductServiceImplTest.USERNAME, MERCHANT_CODE)).thenReturn(profileResponse);
    when(this.masterDataService
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode())).thenReturn(productDetailResponse1);
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
      new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
        ProductType.BIG_PRODUCT, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
      needCorrectionProductActivationRequest);
    verify(this.productCacheableService)
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService)
      .getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode());
    verify(this.itemService)
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true);
    verify(this.masterDataService)
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
      eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionFbbTrueL5WithBopisCncSwitchOn() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCNCRestrictionEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
      "CM");
    ProductDetailResponse productDetailResponse1 = getProductDetailResponse();
    productCategoryResponses.stream().map(ProductCategoryResponse::getCategory)
      .forEach(categoryResponse1 -> categoryResponse1.setBopisEligible(true));
    productDetailResponse1.setProductCategoryResponses(productCategoryResponses);
    productDetailResponse1.getProductCategoryResponses().stream().forEach(c -> c.getCategory().setBopisEligible(false));
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    productSync.setProductType(ProductType.BOPIS);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    itemPickupPoint2.setMarkForDelete(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    profileResponse.setCompany(CompanyDTO.builder().merchantType("CM").build());
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
      .thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode()))
      .thenReturn(businessPartner);
    when(this.itemService
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(xbpOutbound.getBusinessPartnerDetails(STORE_ID, ProductServiceImplTest.REQUEST_ID,
      ProductServiceImplTest.USERNAME, MERCHANT_CODE)).thenReturn(profileResponse);
    when(this.masterDataService
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode())).thenReturn(productDetailResponse1);
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
      new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
        ProductType.BOPIS, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
      needCorrectionProductActivationRequest);
    verify(this.productCacheableService)
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService)
      .getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode());
    verify(this.itemService)
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true);
    verify(this.masterDataService)
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
      eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }


  @Test
  public void activateProductAndItemsOnNeedCorrectionFbbTrueL5WithBopisCncNotEligibleSwitchOn() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCNCRestrictionEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
      "CM");
    ProductDetailResponse productDetailResponse1 = getProductDetailResponse();
    productCategoryResponses.stream().map(ProductCategoryResponse::getCategory)
      .forEach(categoryResponse1 -> categoryResponse1.setBopisEligible(true));
    productDetailResponse1.setProductCategoryResponses(productCategoryResponses);
    productDetailResponse1.getProductCategoryResponses().stream().forEach(c -> c.getCategory().setBopisEligible(false));
    businessPartner.setMerchantStatus("INACTIVE");
    productSync.setArchived(true);
    productSync.setProductType(ProductType.BIG_PRODUCT);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    listOfItems.forEach(item1 -> {
      item1.setHeight(2.0);
      item1.setWeight(3.0);
      item1.setLength(4.0);
      item1.setWidth(5.0);
    });
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    itemPickupPoint2.setMarkForDelete(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    profileResponse.setCompany(CompanyDTO.builder().merchantType("CM").build());
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
      .thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode()))
      .thenReturn(businessPartner);
    when(this.itemService
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(xbpOutbound.getBusinessPartnerDetails(STORE_ID, ProductServiceImplTest.REQUEST_ID,
      ProductServiceImplTest.USERNAME, MERCHANT_CODE)).thenReturn(profileResponse);
    when(this.masterDataService
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode())).thenReturn(productDetailResponse1);
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
      new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
        ProductType.BIG_PRODUCT, false, false, false, true);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
      needCorrectionProductActivationRequest);
    verify(this.productCacheableService)
      .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService)
      .getBusinessPartnerByBusinessPartnerCode(STORE_ID, productSync.getMerchantCode());
    verify(this.itemService)
      .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
        Arrays.asList(itemActivationRequest), true);
    verify(this.masterDataService)
      .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME, ProductServiceImplTest.REQUEST_ID,
        this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
      eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
  }


  @Test
  public void activateProductAndItemsOnNeedCorrectionMakeL5OfflineForArchivedProductsTest_ItemRequestNull()
      throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    businessPartner.setMerchantStatus("INACTIVE");
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode())).thenReturn(businessPartner);
    when(
        this.itemService.activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
            null, true)).thenReturn(editItemResponse);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode())).thenReturn(getProductDetailResponse());
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, null, preOrderDTO,
            ProductType.BIG_PRODUCT, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        needCorrectionProductActivationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService).getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode());
    verify(this.itemService).activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC,
        productSync.getMerchantCode(), null, true);
    verify(this.masterDataService).getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionMakeL5OfflineForArchivedProductsB2BNotNullTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "makeL5OfflineForArchivedProducts", true);
    businessPartner.setMerchantStatus("INACTIVE");
    B2bFieldsVo b2bFieldsVo = new B2bFieldsVo();
    b2bFieldsVo.setB2bItemViewConfigs(itemViewConfigs);
    itemActivationRequest.setB2bFields(b2bFieldsVo);
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC)).thenReturn(this.productSync);
    when(this.businessPartnerService.getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode())).thenReturn(businessPartner);
    when(
        this.itemService.activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(),
            Arrays.asList(itemActivationRequest), true)).thenReturn(editItemResponse);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode())).thenReturn(getProductDetailResponse());
    NeedCorrectionProductActivationRequest needCorrectionProductActivationRequest =
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
            ProductType.BIG_PRODUCT, false, false, false, false);
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        needCorrectionProductActivationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.businessPartnerService).getBusinessPartnerByBusinessPartnerCode(STORE_ID,
        productSync.getMerchantCode());
    verify(this.itemService).activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC,
        productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
        true);
    verify(this.masterDataService).getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(itemActivationRequest.isBuyable());
    assertFalse(itemActivationRequest.isDiscoverable());
    assertFalse(itemActivationRequest.getB2bFields().getB2bItemViewConfigs().iterator().next().isDiscoverable());
    assertFalse(itemActivationRequest.getB2bFields().getB2bItemViewConfigs().iterator().next().isBuyable());
  }

  private ProductDetailResponse getProductDetailResponse() {
    AttributeResponse attributeResponse1 = new AttributeResponse();
    AttributeResponse attributeResponse2 = new AttributeResponse();
    attributeResponse1.setSkuValue(true);
    attributeResponse2.setSkuValue(false);

    ProductAttributeValueResponse productAttributeValueResponse1 = new ProductAttributeValueResponse();
    ProductAttributeValueResponse productAttributeValueResponse2 = new ProductAttributeValueResponse();
    ProductAttributeValueResponse productAttributeValueResponse3 = new ProductAttributeValueResponse();
    ProductAttributeValueResponse productAttributeValueResponse4 = new ProductAttributeValueResponse();
    ProductAttributeValueResponse productAttributeValueResponse5 = new ProductAttributeValueResponse();
    productAttributeValueResponse1
        .setDescriptiveAttributeValueType(com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.SINGLE);
    productAttributeValueResponse2
        .setDescriptiveAttributeValueType(com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.PREDEFINED);
    productAttributeValueResponse2.setPredefinedAllowedAttributeValue(new PredefinedAllowedAttributeValueResponse());
    productAttributeValueResponse3
        .setDescriptiveAttributeValueType(com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.PREDEFINED);
    productAttributeValueResponse4
        .setDescriptiveAttributeValueType(com.gdn.x.productcategorybase.dto.DescriptiveAttributeValueType.NONE);
    productAttributeValueResponse4.setAllowedAttributeValue(new AllowedAttributeValueResponse());


    ProductAttributeResponse productAttributeResponse1 = new ProductAttributeResponse();
    ProductAttributeResponse productAttributeResponse2 = new ProductAttributeResponse();
    ProductAttributeResponse productAttributeResponse3 = new ProductAttributeResponse();
    productAttributeResponse1.setAttribute(attributeResponse1);
    productAttributeResponse1.setProductAttributeValues(Arrays
        .asList(productAttributeValueResponse1, productAttributeValueResponse2, productAttributeValueResponse3,
            productAttributeValueResponse4, productAttributeValueResponse5));
    productAttributeResponse2.setAttribute(attributeResponse1);
    productAttributeResponse3.setAttribute(attributeResponse2);

    ProductItemResponse productItemResponse1 = new ProductItemResponse();
    ProductItemResponse productItemResponse2 = new ProductItemResponse();
    productItemResponse1.setSkuCode(ITEM_CODE);
    productItemResponse2.setSkuCode(SOURCE_ITEM_CODE);

    ProductDetailResponse productDetailResponse = new ProductDetailResponse();
    productDetailResponse.setProductAttributeResponses(Arrays.asList(productAttributeResponse1, productAttributeResponse2, productAttributeResponse3));
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse1, productItemResponse2));

    return productDetailResponse;
  }

  @Test
  public void updateEditedProductTest_FreeSampleOff2OnChannelChange() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(this.itemPickupPointService.findByItemSkuAndDelivery(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPoint);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);

    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTestFreeSampleTest() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(true);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(false);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(true);
    itemViewConfig.setDiscoverable(false);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    when(this.itemPickupPointService.findByStoreIdAndItemSku(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPointList);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);

    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(itemPickupPointService).findByStoreIdAndItemSku(any(), any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTestFreeSampleViewConfigEmptyTest() throws Exception {
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(true);
    itemViewConfig.setDiscoverable(true);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    when(this.itemPickupPointService.findByStoreIdAndItemSku(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPointList);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(eq(REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(any(), any(),
      eq(Collections.EMPTY_MAP));
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(itemPickupPointService).findByStoreIdAndItemSku(any(), any());
    verify(saveAndPublishService).publishViewConfigChange(any());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTestFreeSampleViewConfigEmptyTestDiscoverFalseBuyableTrue() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(true);
    itemViewConfig.setDiscoverable(false);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    when(this.itemPickupPointService.findByStoreIdAndItemSku(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPointList);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);

    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(any(), any(),
      eq(Collections.EMPTY_MAP));
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(itemPickupPointService).findByStoreIdAndItemSku(any(), any());
    verify(saveAndPublishService).publishViewConfigChange(any());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTestFreeSampleTestDiscoverableTrue() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(false);
    itemViewConfig.setDiscoverable(true);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    when(this.itemPickupPointService.findByStoreIdAndItemSku(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPointList);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);

    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(itemPickupPointService).findByStoreIdAndItemSku(any(), any());
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(any(), any(),
      eq(Collections.EMPTY_MAP));
    verify(saveAndPublishService).publishViewConfigChange(any());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductCombinedEditTest() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    product.setProductType(ProductType.BOPIS);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    listOfItems.get(0).setOff2OnChannelActive(true);
    setProductAttributeResponses(productDetailResponse);
    CommonUtil.setUpdatedItemSkuAndItemMap(listOfItems, editProductDetailDTO);
    CommonUtil.setOfflineItemIdToItemPickupPointMap(new ArrayList<>(Collections.singletonList(itemPickupPoint)),
        editProductDetailDTO);
    productSyncTobeUpdated.setFreeSample(false);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(false);
    itemViewConfig.setDiscoverable(true);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    productEditRequest.setContentChanged(true);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID, this.productSyncUpdated, null, false,
        true, editProductDetailDTO, productEditRequest);
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());  }

  @Test
  public void updateEditedProductCombinedEditAndPreorderChangedTest() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(false);
    this.productSyncUpdated.setPreOrder(preOrder);
    this.productSyncUpdated.setOff2OnChannelActive(true);
    PreOrderVO preOrderVO = new PreOrderVO();
    BeanUtils.copyProperties(preOrderVO,preOrder);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    listOfItems.get(0).setOff2OnChannelActive(true);
    CommonUtil.setUpdatedItemSkuAndItemMap(listOfItems, editProductDetailDTO);
    CommonUtil.setOfflineItemIdToItemPickupPointMap(new ArrayList<>(Collections.singletonList(itemPickupPoint)),
        editProductDetailDTO);
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(false);
    itemViewConfig.setDiscoverable(true);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    productEditRequest.setContentChanged(true);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, true, editProductDetailDTO, productEditRequest);
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());  }

  @Test
  public void updateEditedProductCombinedEditAndPreorderChangedChangeTypeContentTest() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER, Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER, Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(false);
    this.productSyncUpdated.setPreOrder(preOrder);
    this.productSyncUpdated.setOff2OnChannelActive(true);
    PreOrderVO preOrderVO = new PreOrderVO();
    BeanUtils.copyProperties(preOrderVO, preOrder);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    listOfItems.get(0).setOff2OnChannelActive(true);
    CommonUtil.setUpdatedItemSkuAndItemMap(listOfItems, editProductDetailDTO);
    CommonUtil.setOfflineItemIdToItemPickupPointMap(new ArrayList<>(Collections.singletonList(itemPickupPoint)),
        editProductDetailDTO);
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient.getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        productSyncTobeUpdated.getProductCode())).thenReturn(productDetailResponse);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class))).thenReturn(
        productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(
        StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    Mockito.when(productHelperService.updateItemViewConfigForExistingChannel(any(Item.class),
        any(ItemViewConfig.class))).thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(false);
    itemViewConfig.setDiscoverable(true);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    editProductDetailDTO.setEditChangeType(EditChangeType.CONTENT);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    productEditRequest.setContentChanged(true);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, true, editProductDetailDTO,
        productEditRequest);
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(productHelperService).updateItemViewConfigForExistingChannel(any(Item.class),
        any(ItemViewConfig.class));
    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());  }

  @Test
  public void updateEditedProductTestFreeSampleTestDiscoverableFalseBuyableFalse() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    when(this.itemPickupPointService.findByItemSkuAndDelivery(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPoint);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(false);
    itemViewConfig.setDiscoverable(false);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    when(this.itemPickupPointService.findByStoreIdAndItemSku(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPointList);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);

    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(anyList(), anyList(),
      eq(Collections.EMPTY_MAP));
    verify(saveAndPublishService).publishViewConfigChange(any());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTestFreeSampleTestDiscoverableFalseBuyableFalse2() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(false);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    when(this.itemPickupPointService.findByItemSkuAndDelivery(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPoint);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    productSyncUpdated.setFreeSample(true);
    productSyncUpdated.setOff2OnChannelActive(true);
    ItemViewConfig itemViewConfig = new ItemViewConfig();
    itemViewConfig.setChannel(Constants.DEFAULT_CHANNEL);
    itemViewConfig.setBuyable(false);
    itemViewConfig.setDiscoverable(false);
    itemViewConfigs.add(itemViewConfig);
    itemViewConfigList.add(itemViewConfig);
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    when(this.itemPickupPointService.findByStoreIdAndItemSku(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPointList);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID, this.productSyncUpdated, null, false,
        false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, true,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);

    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(anyList(), anyList(),
      eq(Collections.EMPTY_MAP));
    verify(saveAndPublishService).publishViewConfigChange(any());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTestFreeSampleTestCheckItemViewConfigEmpty() throws Exception {
    MDC.put(GdnMandatoryRequestParameterUtil.USERNAME_KEY_PARAMETER, Constants.DEFAULT_USERNAME);
    MDC.put(GdnMandatoryRequestParameterUtil.CHANNEL_ID_KEY_PARAMETER,  Constants.DEFAULT_CHANNEL_ID);
    MDC.put(GdnMandatoryRequestParameterUtil.CLIENT_ID_KEY_PARAMETER,  Constants.DEFAULT_CLIENT_ID);
    this.productSyncUpdated.setFreeSample(true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncTobeUpdated.setFreeSample(false);
    this.productSyncTobeUpdated.setOff2OnChannelActive(true);
    this.item.setItemViewConfigs(itemViewConfigList);
    listOfItems.get(0).setPristineDataItem(new PristineDataItem());
    setProductAttributeResponses(productDetailResponse);
    productSyncTobeUpdated.setFreeSample(false);
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
        .thenReturn(StringUtils.EMPTY);
    when(channelService.getDefaultChannel()).thenReturn(PRODUCT_CODE);
    itemPickupPoint.getItemViewConfig().iterator().next().setChannel(StringUtils.EMPTY);
    when(this.itemPickupPointService.findByItemSkuAndDelivery(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPoint);
    Mockito.when(productHelperService
            .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class)))
        .thenReturn(listOfItems.get(0));
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    productSyncUpdated.setFreeSample(true);
    List<ItemPickupPoint> itemPickupPointList = new ArrayList<>();
    itemPickupPointList.add(itemPickupPoint);
    when(this.itemPickupPointService.findByStoreIdAndItemSku(Constants.DEFAULT_STORE_ID,
        ITEM_SKU)).thenReturn(itemPickupPointList);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());
    verify(saveOperationService)
        .changeOff2OnChannelActiveByProductSkus(STORE_ID, PRODUCT_SKU_SYNC_TOBE_UPDATED, false,
            Constants.DEFAULT_USERNAME, new ArrayList<>(), ProductServiceImplTest.REQUEST_ID);

    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(productHelperService)
        .updateItemViewConfigForExistingChannel(any(Item.class), any(ItemViewConfig.class));
    verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(anyList(), anyList(),
      eq(Collections.EMPTY_MAP));
    verify(saveAndPublishService).publishViewConfigChange(any());
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void getProductTypeByProductCodeStoreIdBlankTest() {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getProductTypeByProductCode(null, REQUEST_ID, USERNAME, PRODUCT_CODE));
  }

  @Test
  public void getProductTypeByProductCodeRequestIdBlankTest() {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getProductTypeByProductCode(STORE_ID, null, USERNAME, PRODUCT_CODE));
  }

  @Test
  public void getProductTypeByProductCodeProductCodeIdBlankTest() {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.getProductTypeByProductCode(STORE_ID, REQUEST_ID, USERNAME, null));
  }

  @Test
  public void getProductTypeByProductCodeTest() {
    product.setProductType(ProductType.BOPIS);
    Mockito.when(productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(STORE_ID, PRODUCT_CODE)).thenReturn(Arrays.asList(product));
    ProductTypeResponse productTypeByProductCode =
        productServiceImpl.getProductTypeByProductCode(STORE_ID, REQUEST_ID, USERNAME, PRODUCT_CODE);
    Mockito.verify(productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(STORE_ID, PRODUCT_CODE);
    Assertions.assertEquals(ProductType.BOPIS, productTypeByProductCode.getProductType());
  }

  @Test
  public void getProductTypeByProductCodeEmptyResponseTest() {
    product.setProductType(ProductType.BOPIS);
    Mockito.when(productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(STORE_ID, PRODUCT_CODE)).thenReturn(Collections.emptyList());
    ProductTypeResponse productTypeByProductCode =
        productServiceImpl.getProductTypeByProductCode(STORE_ID, REQUEST_ID, USERNAME, PRODUCT_CODE);
    Mockito.verify(productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(STORE_ID, PRODUCT_CODE);
    assertNull(productTypeByProductCode);
  }

  @Test
  public void getProductTypeByProductCodeTwoResponseTest() {
    product.setProductType(ProductType.BOPIS);
    Mockito.when(productRepository.findByStoreIdAndProductCodeAndMarkForDeleteFalse(STORE_ID, PRODUCT_CODE))
        .thenReturn(Arrays.asList(product, productSync));
    try {
      ProductTypeResponse productTypeByProductCode = productServiceImpl.getProductTypeByProductCode(STORE_ID, REQUEST_ID, USERNAME, PRODUCT_CODE);
    } catch (Exception e) {
      Assertions.assertEquals(ApplicationRuntimeException.class, e.getClass());
    } finally {
      Mockito.verify(productRepository).findByStoreIdAndProductCodeAndMarkForDeleteFalse(STORE_ID, PRODUCT_CODE);
    }
  }

  @Test
  public void setPriceAndItemViewConfigFromItemPickupPointTest() {
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(item.getPickupPointCode()).build();
    when(itemPickupPointService.findByItemSkuInAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true)).thenReturn(
        Arrays.asList(itemPickupPoint));
    Mockito.doNothing().when(itemPriceService).validateAndSetDiscountPrice(Arrays.asList(item));
    productServiceImpl.setPriceAndItemViewConfigFromItemPickupPoint(STORE_ID,
        new ProductAndItemsVO(product, Arrays.asList(item)));
    verify(itemPriceService).validateAndSetDiscountPrice(Arrays.asList(item));
    verify(itemPickupPointService).findByItemSkuInAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true);
  }

  @Test
  public void setPriceAndItemViewConfigFromItemPickupPointEmptyTest() {
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(item.getPickupPointCode()).build();
    when(itemPickupPointService.findByItemSkuInAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true)).thenReturn(
        null);
    productServiceImpl.setPriceAndItemViewConfigFromItemPickupPoint(STORE_ID,
        new ProductAndItemsVO(product, Arrays.asList(item)));
    verify(itemPickupPointService).findByItemSkuInAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true);
  }

  @Test
  public void setPriceAndItemViewConfigFromItemPickupPointForItemSummaryTest() {
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(item.getPickupPointCode()).build();
    when(itemPickupPointService.findByItemSkusAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true)).thenReturn(
        Arrays.asList(itemPickupPoint));
    productServiceImpl.setPriceAndItemViewConfigFromItemPickupPointForItemSummary(STORE_ID,
        new ProductAndItemsVO(product, Arrays.asList(item)));
    verify(itemPickupPointService).findByItemSkusAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true);
  }

  @Test
  public void setPriceAndItemViewConfigFromItemPickupPointForItemSummaryEmptyTest() {
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(item.getPickupPointCode()).build();
    when(itemPickupPointService.findByItemSkusAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true)).thenReturn(
        null);
    productServiceImpl.setPriceAndItemViewConfigFromItemPickupPointForItemSummary(STORE_ID,
        new ProductAndItemsVO(product, Arrays.asList(item)));
    verify(itemPickupPointService).findByItemSkusAndDelivery(STORE_ID, Arrays.asList(item.getItemSku()), true);
  }

  @Test
  public void setSellerPromoBundlingsTest() {
    systemParameter.setValue(Boolean.TRUE.toString());
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    this.productServiceImpl.setSellerPromoBundlings(STORE_ID,
        Collections.singletonList(productItemsVo));
    Mockito.verify(this.businessPartnerPromoService).findByStoreIdAndBusinessPartnerList(STORE_ID,
        Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    Assertions.assertEquals(CATALOG_CODE,
        productItemsVo.getItemVoList().get(0).getSellerActivePromoBundlings().stream().findFirst()
            .get());
  }

  @Test
  public void setSellerPromoBundlings_switchOffTest() {
    systemParameter.setValue(Boolean.FALSE.toString());
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    this.productServiceImpl.setSellerPromoBundlings(STORE_ID,
        Collections.singletonList(productItemsVo));
    Mockito.verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    Assertions.assertTrue(CollectionUtils.isEmpty(
        productAndItemInfoResponse.getItem().getSellerActivePromoBundlings()));
  }

  @Test
  public void setSellerPromoBundlings_nullBPPromoTest() {
    businessPartnerPromo.setBusinessPartnerCode(MERCHANT_SKU);
    systemParameter.setValue(Boolean.TRUE.toString());
    Mockito.when(this.businessPartnerPromoService.findByStoreIdAndBusinessPartnerList(STORE_ID,
            Collections.singletonList(MERCHANT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPromo));
    Mockito.when(this.systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH)).thenReturn(systemParameter);
    this.productServiceImpl.setSellerPromoBundlings(STORE_ID,
        Collections.singletonList(productItemsVo));
    Mockito.verify(this.businessPartnerPromoService).findByStoreIdAndBusinessPartnerList(STORE_ID,
        Collections.singletonList(MERCHANT_CODE));
    Mockito.verify(this.systemParameterService).findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.SELLER_PROMO_BUNDLINGS_SWITCH);
    Assertions.assertTrue(CollectionUtils.isEmpty(
        productAndItemInfoResponse.getItem().getSellerActivePromoBundlings()));
  }

  @Test
  public void updateProductAndItemDetailsTest() {
    List<ProductCategoryDomainEventModel> productCategoryDomainEventModels = new ArrayList<>();
    productCategoryDomainEventModels.add(null);
    message.setProductCategories(productCategoryDomainEventModels);
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList());
    productServiceImpl.updateProductAndItemDetails(message, false);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        new ProductAndItemsVO(productUnsync, Arrays.asList()));
  }

  @Test
  public void updateProductAndItemDetailsCategoryModelNullTest() {
    message.setProductCategories(Arrays.asList(new ProductCategoryDomainEventModel()));
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        new ProductAndItemsVO(product, Arrays.asList(item)))).thenReturn(
        new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList());
    productServiceImpl.updateProductAndItemDetails(message, false);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        new ProductAndItemsVO(productUnsync, Arrays.asList()));
  }

  @Test
  public void updateProductAndItemDetailsItemsDetailsTest() {
    item.setItemCode(null);
    item.setGeneratedItemName(null);
    item.setItemSku(null);
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    message.setLength(10.0);
    message.setWeight(10.0);
    message.setWidth(10.0);
    message.setHeight(10.0);
    message.setShippingWeight(10.0);
    ImageDomainEventModel imageDomainEventModel = new ImageDomainEventModel();
    message.setImages(Arrays.asList(imageDomainEventModel));
    ProductItemDomainEventModel productItemDomainEventModel = new ProductItemDomainEventModel();
    productItemDomainEventModel.setGeneratedItemName(NAME);
    productItemDomainEventModel.setImages(Arrays.asList(imageDomainEventModel));
    message.setProductItems(Arrays.asList(productItemDomainEventModel));
    ProductCategoryDomainEventModel productCategoryDomainEventModel = new ProductCategoryDomainEventModel();
    CategoryDomainEventModel categoryDomainEventModel = new CategoryDomainEventModel();
    categoryDomainEventModel.setCategoryCode(CATEGORY_CODE);
    productCategoryDomainEventModel.setCategory(categoryDomainEventModel);
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    ProductAttributeDomainEventModel productAttributeDomainEventModel = new ProductAttributeDomainEventModel();
    productAttributeDomainEventModel.setAttribute(new AttributeDomainEventModel());
    message.setProductAttributes(Arrays.asList(productAttributeDomainEventModel));
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    productServiceImpl.updateProductAndItemDetails(message, true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    verify(productAndItemSolrIndexerService).updatePickUpPointAndVariantCountAndCncActivation(
        any(ProductAndItemsVO.class), anyList());
  }

  @Test
  public void updateProductAndItemDetailsItemsDetailsDEFINING_ATTRIBUTETest() {
    item.setItemCode(null);
    item.setGeneratedItemName(null);
    item.setItemSku(null);
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    message.setLength(10.0);
    message.setWeight(10.0);
    message.setWidth(10.0);
    message.setHeight(10.0);
    message.setShippingWeight(10.0);
    ImageDomainEventModel imageDomainEventModel = new ImageDomainEventModel();
    message.setImages(Arrays.asList(imageDomainEventModel));
    ProductItemDomainEventModel productItemDomainEventModel = new ProductItemDomainEventModel();
    productItemDomainEventModel.setGeneratedItemName(NAME);
    productItemDomainEventModel.setImages(Arrays.asList(imageDomainEventModel));
    message.setProductItems(Arrays.asList(productItemDomainEventModel));
    ProductCategoryDomainEventModel productCategoryDomainEventModel = new ProductCategoryDomainEventModel();
    CategoryDomainEventModel categoryDomainEventModel = new CategoryDomainEventModel();
    categoryDomainEventModel.setCategoryCode(CATEGORY_CODE);
    productCategoryDomainEventModel.setCategory(categoryDomainEventModel);
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    ProductAttributeDomainEventModel productAttributeDomainEventModel = new ProductAttributeDomainEventModel();
    AttributeDomainEventModel attribute = new AttributeDomainEventModel();
    attribute.setAttributeType(AttributeType.DEFINING_ATTRIBUTE.name());
    productAttributeDomainEventModel.setAttribute(attribute);
    ProductAttributeValueDomainEventModel productAttributeValueDomainEventModel = new ProductAttributeValueDomainEventModel();
    productAttributeValueDomainEventModel.setAllowedAttributeValue(new AllowedAttributeValueDomainEventModel());
    productAttributeDomainEventModel.setProductAttributeValues(Arrays.asList(productAttributeValueDomainEventModel));
    message.setProductAttributes(Arrays.asList(productAttributeDomainEventModel));
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    when(objectConverterService.toProductAttributeDetail(productAttributeDomainEventModel)).thenReturn(
        ProductAttributeDetail.builder().build());
    productServiceImpl.updateProductAndItemDetails(message, true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    verify(productAndItemSolrIndexerService).updatePickUpPointAndVariantCountAndCncActivation(
        any(ProductAndItemsVO.class), anyList());
    verify(objectConverterService).toProductAttributeDetail(productAttributeDomainEventModel);
  }

  @Test
  public void updateProductAndItemDetailsItemsDetailsDEFINING_ATTRIBUTETItemNullCheckTest() {
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    message.setLength(10.0);
    message.setWeight(10.0);
    message.setWidth(10.0);
    message.setHeight(10.0);
    message.setShippingWeight(10.0);
    ImageDomainEventModel imageDomainEventModel = new ImageDomainEventModel();
    message.setImages(Arrays.asList(imageDomainEventModel));
    ProductItemDomainEventModel productItemDomainEventModel = new ProductItemDomainEventModel();
    productItemDomainEventModel.setGeneratedItemName(NAME);
    productItemDomainEventModel.setImages(Arrays.asList(imageDomainEventModel));
    message.setProductItems(Arrays.asList(productItemDomainEventModel));
    ProductCategoryDomainEventModel productCategoryDomainEventModel = new ProductCategoryDomainEventModel();
    CategoryDomainEventModel categoryDomainEventModel = new CategoryDomainEventModel();
    categoryDomainEventModel.setCategoryCode(CATEGORY_CODE);
    productCategoryDomainEventModel.setCategory(categoryDomainEventModel);
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    ProductAttributeDomainEventModel productAttributeDomainEventModel = new ProductAttributeDomainEventModel();
    AttributeDomainEventModel attribute = new AttributeDomainEventModel();
    attribute.setAttributeType(AttributeType.DEFINING_ATTRIBUTE.name());
    productAttributeDomainEventModel.setAttribute(attribute);
    ProductAttributeValueDomainEventModel productAttributeValueDomainEventModel = new ProductAttributeValueDomainEventModel();
    productAttributeValueDomainEventModel.setAllowedAttributeValue(new AllowedAttributeValueDomainEventModel());
    productAttributeDomainEventModel.setProductAttributeValues(Arrays.asList(productAttributeValueDomainEventModel));
    message.setProductAttributes(Arrays.asList(productAttributeDomainEventModel));
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);
    Item item1 = null;
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item1));
    when(objectConverterService.toProductAttributeDetail(productAttributeDomainEventModel)).thenReturn(
        ProductAttributeDetail.builder().build());
    productServiceImpl.updateProductAndItemDetails(message, true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any());
    verify(productAndItemSolrIndexerService).updatePickUpPointAndVariantCountAndCncActivation(
        any(ProductAndItemsVO.class), anyList());
  }

  @Test
  public void updateProductAndItemDetailsItemsDetailsVariantCreatingTest() {
    item.setItemCode(null);
    item.setGeneratedItemName(null);
    item.setItemSku(null);
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    message.setLength(10.0);
    message.setWeight(10.0);
    message.setWidth(10.0);
    message.setHeight(10.0);
    message.setShippingWeight(10.0);
    ImageDomainEventModel imageDomainEventModel = new ImageDomainEventModel();
    message.setImages(Arrays.asList(imageDomainEventModel));
    ProductItemDomainEventModel productItemDomainEventModel = new ProductItemDomainEventModel();
    productItemDomainEventModel.setGeneratedItemName(NAME);
    productItemDomainEventModel.setImages(Arrays.asList(imageDomainEventModel));
    message.setProductItems(Arrays.asList(productItemDomainEventModel));
    ProductCategoryDomainEventModel productCategoryDomainEventModel = new ProductCategoryDomainEventModel();
    CategoryDomainEventModel categoryDomainEventModel = new CategoryDomainEventModel();
    categoryDomainEventModel.setCategoryCode(CATEGORY_CODE);
    productCategoryDomainEventModel.setCategory(categoryDomainEventModel);
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    ProductAttributeDomainEventModel productAttributeDomainEventModel = new ProductAttributeDomainEventModel();
    AttributeDomainEventModel attribute = new AttributeDomainEventModel();
    attribute.setAttributeType(AttributeType.DESCRIPTIVE_ATTRIBUTE.name());
    attribute.setVariantCreation(true);
    productAttributeDomainEventModel.setAttribute(attribute);
    ProductAttributeValueDomainEventModel productAttributeValueDomainEventModel = new ProductAttributeValueDomainEventModel();
    productAttributeValueDomainEventModel.setAllowedAttributeValue(new AllowedAttributeValueDomainEventModel());
    productAttributeValueDomainEventModel.setDescriptiveAttributeValue(DESCRIPTIVE_ATTRIBUTE_VALUE);
    productAttributeDomainEventModel.setProductAttributeValues(Arrays.asList(productAttributeValueDomainEventModel));
    message.setProductAttributes(Arrays.asList(productAttributeDomainEventModel));
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(saveOperationService
        .saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(new ProductAndItemsVO(product, Arrays.asList(item))))
        .thenReturn(new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    when(objectConverterService.toProductAttributeDetail(productAttributeDomainEventModel)).thenReturn(
        ProductAttributeDetail.builder().build());
    productServiceImpl.updateProductAndItemDetails(message, true);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE);
    verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        new ProductAndItemsVO(productUnsync, Arrays.asList(item)));
    verify(productAndItemSolrIndexerService).updatePickUpPointAndVariantCountAndCncActivation(
        any(ProductAndItemsVO.class), anyList());
    verify(objectConverterService).toProductAttributeDetail(productAttributeDomainEventModel);
  }

  @Test
  public void updateProductAndItemDetailsItemsDetailsExceptionTest() {
    item.setItemCode(null);
    item.setGeneratedItemName(null);
    item.setItemSku(null);
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    ImageDomainEventModel imageDomainEventModel = new ImageDomainEventModel();
    message.setImages(Arrays.asList(imageDomainEventModel));
    ProductItemDomainEventModel productItemDomainEventModel = new ProductItemDomainEventModel();
    productItemDomainEventModel.setGeneratedItemName(NAME);
    productItemDomainEventModel.setImages(Arrays.asList(imageDomainEventModel));
    message.setProductItems(Arrays.asList(productItemDomainEventModel));
    ProductCategoryDomainEventModel productCategoryDomainEventModel = new ProductCategoryDomainEventModel();
    CategoryDomainEventModel categoryDomainEventModel = new CategoryDomainEventModel();
    categoryDomainEventModel.setCategoryCode(CATEGORY_CODE);
    productCategoryDomainEventModel.setCategory(categoryDomainEventModel);
    message.setProductCategories(Arrays.asList(productCategoryDomainEventModel));
    ProductAttributeDomainEventModel productAttributeDomainEventModel = new ProductAttributeDomainEventModel();
    productAttributeDomainEventModel.setAttribute(new AttributeDomainEventModel());
    message.setProductAttributes(Arrays.asList(productAttributeDomainEventModel));
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);
    when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(Arrays.asList(item));
    try {
      productServiceImpl.updateProductAndItemDetails(message, false);
    } finally {
      verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
          ProductServiceImplTest.PRODUCT_CODE);
      verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    }
  }

  private ProductItemsVo generateProductItemVo(Product product, Item item, ItemPickupPoint itemPickupPoint) {
    ProductItemsVo productItemsVo = new ProductItemsVo();
    productItemsVo.setProductVo(Objects.nonNull(product) ? gdnMapper.deepCopy(product, ProductVo.class) : null);
    productItemsVo.setItemVoList(Objects.nonNull(item) ? Arrays.asList(gdnMapper.deepCopy(item, ItemVo.class)) : null);
    if (!CollectionUtils.isEmpty(productItemsVo.getItemVoList())) {
      productItemsVo.getItemVoList().get(0).setItemPickupPointVoList(new ArrayList<>());
      productItemsVo.getItemVoList().get(0).setItemPickupPointVoList(Objects.nonNull(itemPickupPoint) ?
          Arrays.asList(gdnMapper.deepCopy(itemPickupPoint, ItemPickupPointVo.class)) :
          null);
    }
    return productItemsVo;
  }

  @Test
  public void updateMasterDataFieldsInProductTest() throws Exception {
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(true);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());

  }

  @Test
  public void updateMasterDataFieldsInProductNoMainImageTest() throws Exception {
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(false);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());
  }

  @Test
  public void updateMasterDataFieldsInProductProductScoreFilterReizeImageEnabledTrueTest() throws Exception {
    ReflectionTestUtils.setField(this.productServiceImpl, "generateProductScoreFilterResizeImageEnabled", true);
    ReflectionTestUtils.setField(this.productServiceImpl, "generateProductScoreFilterResizePath", "");
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(false);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setDimensionsMissing(Boolean.TRUE);
    product.setProductCode(PRODUCT_CODE);
    product.setProductType(ProductType.BIG_PRODUCT);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);
    item.setHeight(3.9);
    item.setWeight(4.0);
    item.setWidth(4.0);
    item.setShippingWeight(4.0);
    item.setLength(4.0);
    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());
  }

  @Test
  public void updateMasterDataFieldsInProductProductScoreFilterResizePathTest() throws Exception {
    ReflectionTestUtils.setField(this.productServiceImpl, "generateProductScoreFilterResizeImageEnabled", true);
    ReflectionTestUtils.setField(this.productServiceImpl, "generateProductScoreFilterResizePath", NAME);
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(false);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));
    productDetailResponse.setHeight(3.9);
    productDetailResponse.setWeight(4.0);
    productDetailResponse.setWidth(4.0);
    productDetailResponse.setShippingWeight(4.0);
    productDetailResponse.setLength(4.0);
    product.setProductType(ProductType.BOPIS);
    product.setProductCode(PRODUCT_CODE);
    product.setDimensionsMissing(true);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());
  }

  @Test
  public void updateMasterDataFieldsInProductNoMainImageTest2() throws Exception {
    ReflectionTestUtils.setField(this.productServiceImpl, "setMainImageInProductScoreApiForEmptyCase", true);
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(false);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());
  }

  @Test
  public void updateMasterDataFieldsInProductNoMainImageTest3() throws Exception {
    ReflectionTestUtils.setField(this.productServiceImpl, "setMainImageInProductScoreApiForEmptyCase", true);
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(false);
    image1.setMarkForDelete(true);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();
    image2.setMainImages(false);
    image2.setMarkForDelete(false);
    image2.setLocationPath(UPDATED_USP);
    Image image3 = new Image();
    image3.setEdited(true);
    image3.setActive(false);
    image3.setMarkForDelete(false);
    image3.setLocationPath(UPDATED_USP);

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2, image3));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());
  }

  @Test
  public void updateMasterDataFieldsInProductNoMainImageTest4() throws Exception {
    ReflectionTestUtils.setField(this.productServiceImpl, "setMainImageInProductScoreApiForEmptyCase", true);
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image3 = new Image();
    image3.setEdited(true);
    image3.setActive(false);
    image3.setMarkForDelete(false);
    image3.setLocationPath(UPDATED_USP);

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(List.of(image3));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());
  }

  @Test
  public void updateMasterDataFieldsInProductNoL3DataChangeTest() throws Exception {
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(true);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
    verify(saveAndPublishService).publishListOfItems(itemListArgumentCaptor.capture());

  }

  @Test
  public void updateMasterDataFieldsInProductNoMasterDataChangeTest() throws Exception {
    AttributeResponse attributeResponse1 = new AttributeResponse();
    attributeResponse1.setVariantCreation(true);
    AttributeResponse attributeResponse2 = new AttributeResponse();

    ProductItemAttributeValueResponse productItemAttributeValueResponse1 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse1.setAttributeResponse(attributeResponse1);
    ProductItemAttributeValueResponse productItemAttributeValueResponse2 = new ProductItemAttributeValueResponse();
    productItemAttributeValueResponse2.setAttributeResponse(attributeResponse2);

    Image image1 = new Image();
    image1.setMainImages(true);
    image1.setLocationPath(LOCATION_PATH);
    Image image2 = new Image();

    ProductItemResponse productItemResponse = new ProductItemResponse();
    productItemResponse.setSkuCode(SKU_CODE);
    productItemResponse.setImages(Arrays.asList(image1, image2));
    productItemResponse.setProductItemAttributeValueResponses(
        Arrays.asList(productItemAttributeValueResponse1, productItemAttributeValueResponse2));

    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(ImmutableSet.of(productItemResponse));
    listOfItems.get(0).setItemCode(SKU_CODE);

    product.setBrand(productDetailResponse.getBrand());
    product.setProductName(productDetailResponse.getName());
    product.setCategoryCode(productDetailResponse.getProductCategoryResponses().get(0).getCategory().getCategoryCode());
    listOfItems.get(0).setLength(productDetailResponse.getLength());
    listOfItems.get(0).setHeight(productDetailResponse.getHeight());
    listOfItems.get(0).setWidth(productDetailResponse.getWidth());
    listOfItems.get(0).setWeight(productDetailResponse.getWeight());
    listOfItems.get(0).setShippingWeight(productDetailResponse.getShippingWeight());
    listOfItems.get(0).setGeneratedItemName(productDetailResponse.getProductItemResponses().iterator().next().getGeneratedItemName());
    listOfItems.get(0).setDangerousLevel(productDetailResponse.getProductItemResponses().iterator().next().getDangerousGoodsLevel());
    listOfItems.get(0).setMainImageUrl(productDetailResponse.getProductItemResponses().iterator().next().getImages().get(0).getLocationPath());

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(objectConverterService).toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class));
  }

  @Test
  public void updateMasterDataFieldsInProductNullTest() throws Exception {
    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(null);
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void updateMasterDataFieldsInProductUnsyncTest() throws Exception {
    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(false);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void updateMasterDataFieldsInProductEMptyItemTest() throws Exception {
    product.setProductCode(PRODUCT_CODE);
    product.setSynchronized(true);
    productDetailResponse.setProductItemResponses(null);
    listOfItems.get(0).setItemCode(SKU_CODE);

    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString())).thenReturn(listOfItems);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(any()))
        .thenReturn(new ProductAndItemsVO(productSync, null));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(eq(Constants.DEFAULT_REQUEST_ID), eq(Constants.DEFAULT_USERNAME), anyString()))
        .thenReturn(productDetailResponse);
    when(this.productCategoryBaseClient.getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(this.productDetailResponse);
    when(objectConverterService.toProductAttributeDetail(
        any(ProductItemAttributeValueResponse.class))).thenReturn(new ProductAttributeDetail());
    productServiceImpl.updateMasterDataFieldsInProduct(STORE_ID, PRODUCT_SKU);
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        any(ProductAndItemsVO.class));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(anyString(), anyString());
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(Constants.DEFAULT_USERNAME,
        Constants.DEFAULT_USERNAME, PRODUCT_CODE);
  }



  @Test
  public void updateEditedProductTest_MppTrueTest() throws Exception {
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setPreOrder(null);
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
        .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
            any(ProductScore.class));
    when(this.productCategoryBaseClient
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
        .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
        .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
        .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class))).thenReturn(
        StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
        Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
        .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
        .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
  }

  @Test
  public void updateEditedProductTest_PureInstoreTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "instoreNewFlowEnabled", true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setPreOrder(null);
    this.productSyncUpdated.setMissingFields(Set.of(Constants.DIMENSIONS_MISSING, Constants.DESCRIPTION_MISSING));
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
    when(this.productCategoryBaseClient
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
      .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
      .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
      .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
      .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, null, productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
      Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
      this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
    Assertions.assertEquals(productSyncUpdated.getMissingFields(), productSyncTobeUpdated.getMissingFields());
  }


  @Test
  public void updateEditedProductTest_PureInstoreWithNoChangeInMissingFeildTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "instoreNewFlowEnabled", true);
    this.productSyncUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productSyncUpdated.setMasterDataProduct(null);
    this.productSyncUpdated.setProductCode(PRODUCT_CODE);
    this.productSyncUpdated.setPreOrder(null);
    this.productSyncUpdated.setMissingFields(Set.of(Constants.DIMENSIONS_MISSING, Constants.DESCRIPTION_MISSING));
    this.productSyncUpdated.setProductSpecialAttributes(Collections.singletonList(productSpecialAttribute));
    this.productSyncTobeUpdated.setProductScore(oldProductScore);
    this.productSyncTobeUpdated.setMissingFields(Set.of(Constants.DIMENSIONS_MISSING, Constants.DESCRIPTION_MISSING));
    this.productSyncTobeUpdated.setProductType(ProductType.REGULAR);
    this.productSyncTobeUpdated.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    setProductAttributeResponses(productDetailResponse);
    Mockito.doNothing().when(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    when(this.productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.productSyncTobeUpdated);
    when(this.itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED)).thenReturn(this.listOfItems);
    Mockito.doNothing().when(this.productScoreHistoryL3Service)
      .saveProductScoreHistoryL3(eq(STORE_ID), anyString(), any(ProductScore.class),
        any(ProductScore.class));
    when(this.productCategoryBaseClient
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, productSyncTobeUpdated.getProductCode()))
      .thenReturn(productDetailResponse);
    when(this.saveOperationService.saveProductWithoutUpdatingSolr(any(Product.class), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP)))
      .thenReturn(productSyncTobeUpdated);
    when(this.productScoreUtil.getProductScoreByProductScoreRequest(any(ProductScoreRequest.class)))
      .thenReturn(productScoreVo);
    when(this.productHelperService.generateSpecificationDetail(any(Product.class)))
      .thenReturn(StringUtils.EMPTY);
    ProductEditRequest productEditRequest= new ProductEditRequest();
    productEditRequest.setProductSku(PRODUCT_SKU_SYNC_TOBE_UPDATED);
    this.productServiceImpl.updateEditedProduct(ProductServiceImplTest.REQUEST_ID,
        this.productSyncUpdated, null, false, false, new EditProductDetailDTO(),
        productEditRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(
      Constants.DEFAULT_STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(this.productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
      this.productSyncUpdated.getProductCode());

    Mockito.verify(objectConverterService)
      .overrideL4DetailsFromL5(anyList(), anyList());
    verify(this.saveOperationService).saveProductAndItems(any(ProductAndItemsVO.class), eq(new ArrayList<>()));
    verify(this.productScoreUtil).getRecommendedAttributeScore(anyList(), eq(CATEGORY_CODE));
    verify(this.productCategoryBaseClient)
      .getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME, PRODUCT_CODE);
    verify(this.itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
      ProductServiceImplTest.PRODUCT_SKU_SYNC_TOBE_UPDATED);
    verify(objectConverterService).overrideL4DetailsFromL5(Mockito.any(),Mockito.any());
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
    Assertions.assertEquals(productSyncUpdated.getMissingFields(), productSyncTobeUpdated.getMissingFields());
  }


  @Test
  public void getProductsByStoreIdAndMerchantCodeAndIsSuspendedTest() throws Exception {
    when(productRepository.findProductsByStoreIdAndMerchantCodeAndIsSuspended(STORE_ID, PRODUCT_SKU, true)).thenReturn(null);
    productServiceImpl.getProductsByStoreIdAndMerchantCodeAndIsSuspended(STORE_ID, PRODUCT_SKU, true);
    verify(productRepository).findProductsByStoreIdAndMerchantCodeAndIsSuspended(STORE_ID, PRODUCT_SKU, true);
  }

  @Test
  public void updateDistinctPickupPointCodesAndL5CountTest() {
    ItemPickupPoint itemPickupPoint1 =
        ItemPickupPoint.builder().itemSku(ITEM_SKU).pickupPointCode(PICKUP_POINT_CODE).fbbActivated(true).build();
    ItemPickupPoint itemPickupPoint2 =
        ItemPickupPoint.builder().itemSku(ITEM_SKU).cncActive(true).price(ImmutableSet.of(new Price()))
            .pickupPointCode(PICKUP_POINT_CODE).build();

    Mockito.when(
            productRepository.updatePickupPointCodes(STORE_ID, USERNAME, PRODUCT_SKU, ImmutableSet.of(PICKUP_POINT_CODE),
                true))
        .thenReturn(product);
    Mockito.doNothing().when(productAndItemSolrIndexerService)
        .updateProductDetailsInSolr(any());
    Mockito.doNothing().when(productAndItemSolrIndexerService)
        .offlineItemPriceAtomicUpdate(eq(ITEM_SKU), offlineItemListArgumentCaptor.capture());

    productServiceImpl.updateDistinctPickupPointCodesAndL5Count(STORE_ID, USERNAME, PRODUCT_SKU,
        ImmutableSet.of(itemPickupPoint1, itemPickupPoint2), L5_COUNT);

    Mockito.verify(productRepository)
        .updatePickupPointCodes(STORE_ID, USERNAME, PRODUCT_SKU, ImmutableSet.of(PICKUP_POINT_CODE),
            true);
    Mockito.verify(productAndItemSolrIndexerService)
        .updateProductDetailsInSolr(any());
    Mockito.verify(productAndItemSolrIndexerService)
        .offlineItemPriceAtomicUpdate(eq(ITEM_SKU), anyList());
    Mockito.verify(cacheEvictHelperService).evictProductData(eq(STORE_ID), productArgumentCaptor.capture());

    Assertions.assertEquals(1, offlineItemListArgumentCaptor.getValue().size());
  }

  @Test
  public void updateDistinctPickupPointCodesAndL5CountSolrUpdateViaEventTest() {
    ReflectionTestUtils.setField(productServiceImpl, "eventBasedSolrUpdateEnable", true);
    ItemPickupPoint itemPickupPoint1 =
        ItemPickupPoint.builder().itemSku(ITEM_SKU).pickupPointCode(PICKUP_POINT_CODE).build();
    ItemPickupPoint itemPickupPoint2 =
        ItemPickupPoint.builder().itemSku(ITEM_SKU).cncActive(true).price(ImmutableSet.of(new Price()))
            .pickupPointCode(PICKUP_POINT_CODE).build();

    Mockito.when(
            productRepository.updatePickupPointCodes(STORE_ID, USERNAME, PRODUCT_SKU, ImmutableSet.of(PICKUP_POINT_CODE),
                false))
        .thenReturn(product);
    Mockito.doNothing().when(productAndItemSolrIndexerService)
        .updateProductDetailsInSolr(any());
    Mockito.doNothing().when(productAndItemSolrIndexerService)
        .offlineItemPriceAtomicUpdate(eq(ITEM_SKU), offlineItemListArgumentCaptor.capture());

    productServiceImpl.updateDistinctPickupPointCodesAndL5Count(STORE_ID, USERNAME, PRODUCT_SKU,
        ImmutableSet.of(itemPickupPoint1, itemPickupPoint2), L5_COUNT);

    Mockito.verify(productRepository)
        .updatePickupPointCodes(STORE_ID, USERNAME, PRODUCT_SKU, ImmutableSet.of(PICKUP_POINT_CODE),
            false);
    Mockito.verify(productAndItemSolrIndexerService)
        .updateDistinctPickupPointCodesAndL5Count(eq(PRODUCT_SKU), any(), eq(L5_COUNT), eq(false),
            eq(MERCHANT_CODE));
    Mockito.verify(productAndItemSolrIndexerService)
        .offlineItemPriceAtomicUpdate(eq(ITEM_SKU), anyList());
    Mockito.verify(cacheEvictHelperService).evictProductData(eq(STORE_ID), productArgumentCaptor.capture());

    Assertions.assertEquals(1, offlineItemListArgumentCaptor.getValue().size());
  }


  @Test
  public void findByStoreIdAndProductSkuInAndMarkForDeleteFalseTest() {
    when(productRepository.findProductByStoreIdAndProductSkuInAndMarkForDeleteFalse(STORE_ID,
        ImmutableSet.of(PRODUCT_SKU))).thenReturn(Arrays.asList(product));
    productServiceImpl.findByStoreIdAndProductSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(PRODUCT_SKU));
    verify(productRepository).findProductByStoreIdAndProductSkuInAndMarkForDeleteFalse(STORE_ID,
        ImmutableSet.of(PRODUCT_SKU));
  }

  @Test
  public void findByStoreIdAndProductSkuInAndMarkForDeleteFalseEmptyTest() {
    Assertions.assertTrue(
        productServiceImpl.findByStoreIdAndProductSkuInAndMarkForDeleteFalse(STORE_ID, new ArrayList<>()).isEmpty());
  }

  @Test
  public void getProductL3SummaryResponse_Test() throws IOException {
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    productSolrs.get(0).setProductName(null);
    productSolrs.get(0).setMerchantCode(null);
    productSolrs.forEach(p->p.setMerchantCode(null));
    productSolrs.forEach(p->p.setMasterCatalog(null));
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE).price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(
        productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(),
        anyList())).thenReturn(products);
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  @Test
  public void getProductL3SummaryResponseEmptyProductMainImageTest() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    productSolrs.get(0).setProductName(null);
    productSolrs.get(0).setMerchantCode(null);
    productSolrs.get(0).setProductMainImage(null);
    productSolrs.forEach(p->p.setMerchantCode(null));
    productSolrs.forEach(p->p.setMasterCatalog(null));
    item.setProductSku(productSolrs.get(0).getProductSku());
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE).price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(
        productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(),
        anyList())).thenReturn(products);
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    when(itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>())).thenReturn(Arrays.asList(item));
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    verify(itemService).getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  @Test
  public void getProductL3SummaryResponseEmptyProductMainImageNonEmptyItemImageTest() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem().setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    item.setMainImageUrl(LOCATION_PATH);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    productSolrs.get(0).setProductName(null);
    productSolrs.get(0).setMerchantCode(null);
    productSolrs.get(0).setProductMainImage(null);
    productSolrs.forEach(p -> p.setMerchantCode(null));
    productSolrs.forEach(p -> p.setMasterCatalog(null));
    item.setProductSku(productSolrs.get(0).getProductSku());
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE).price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
        any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList())).thenReturn(products);
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    when(itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>())).thenReturn(Arrays.asList(item));
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    verify(itemService).getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>());
    verify(productAndItemSolrIndexerService).updateProductDetailsInSolr(anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseEmptyProductMainImageNonEmptyItemImageSingleVariantTest() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem().setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    item.setMainImageUrl(LOCATION_PATH);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    productSolrs.get(0).setProductName(null);
    productSolrs.get(0).setMerchantCode(null);
    productSolrs.get(0).setProductMainImage(null);
    productSolrs.forEach(p -> p.setMerchantCode(null));
    productSolrs.forEach(p -> p.setMasterCatalog(null));
    item.setProductSku(productSolrs.get(0).getProductSku());
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE).price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
        any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList())).thenReturn(products);
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    when(itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>())).thenReturn(Arrays.asList(item));
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    verify(itemService).getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>());
    verify(productAndItemSolrIndexerService).updateProductDetailsInSolr(anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
  }

  @Test
  public void getProductL3SummaryResponseEmptyProductMainImageImageNotBlankTest() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    productSolrs.get(0).setProductName(null);
    productSolrs.get(0).setMerchantCode(null);
    productSolrs.get(0).setProductMainImage(null);
    productSolrs.forEach(p->p.setMerchantCode(null));
    productSolrs.forEach(p->p.setMasterCatalog(null));
    item.setMainImageUrl(LOCATION_PATH);
    item.setProductSku(productSolrs.get(0).getProductSku());
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE).price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(
        productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(),
        anyList())).thenReturn(products);
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    when(itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>())).thenReturn(Arrays.asList(item));
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    verify(itemService).getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>());
    verify(productAndItemSolrIndexerService).updateProductDetailsInSolr(anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  @Test
  public void getProductL3SummaryResponseEmptyProductMainImageEmptyItemTest() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    productSolrs.get(0).setProductName(null);
    productSolrs.get(0).setMerchantCode(null);
    productSolrs.get(0).setProductMainImage(null);
    productSolrs.forEach(p->p.setMerchantCode(null));
    productSolrs.forEach(p->p.setMasterCatalog(null));
    item.setMainImageUrl(LOCATION_PATH);
    item.setProductSku(productSolrs.get(0).getProductSku());
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE).price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(
        productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(),
        anyList())).thenReturn(products);
    when(itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>())).thenReturn(new ArrayList<>());
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    verify(itemService).getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }

  @Test
  public void getProductL3SummaryResponseEmptyProductMainImageEmptyItemSwitchOffTest() throws IOException {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", false);
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(2);
    productSolrs.get(0).setL5Count(2);
    productSolrs.get(0).setProductName(null);
    productSolrs.get(0).setMerchantCode(null);
    productSolrs.get(0).setProductMainImage(null);
    productSolrs.forEach(p->p.setMerchantCode(null));
    productSolrs.forEach(p->p.setMasterCatalog(null));
    item.setMainImageUrl(LOCATION_PATH);
    item.setProductSku(productSolrs.get(0).getProductSku());
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE).price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(
        productSolrRepository.getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    Mockito.when(
            productRepository.findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    when(itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(productSolrs.get(0).getProductSku()),
        new ArrayList<>())).thenReturn(new ArrayList<>());
    Page<ProductL3SummaryResponse> productL3SummaryResponse = this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
        ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).build(), PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(4, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    assertNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
  }


  @Test
  public void getProductSkuListWithReIndexTest() {
    productSolr2.setProductName(null);
    productSolr1.setMasterCatalog(STORE_ID + "#_#" + MASTER_CATALOG);
    productSolr1.setBrand(BRAND);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    Mockito.when(productSolrRepository
            .getProductSkuSummary(eq(STORE_ID), any(ProductSkuSummaryRequestVo.class),
                eq(MERCHANT_CODE), eq(0), eq(10)))
        .thenReturn(new PageImpl<>(Arrays.asList(productSolr1,productSolr2), PageRequest.of(0, 10), 10));
    Page<ProductSkuSummaryResponse> response = productServiceImpl
        .getProductSkuList(STORE_ID, productSkuSummaryRequest, MERCHANT_CODE, 0, 10);
    Mockito.verify(productSolrRepository)
        .getProductSkuSummary(eq(STORE_ID), any(ProductSkuSummaryRequestVo.class),
            eq(MERCHANT_CODE), eq(0), eq(10));
    Assertions.assertEquals(NEW_PRODUCT_NAME, response.getContent().get(0).getProductName());
    Assertions.assertEquals(PRODUCT_SKU, response.getContent().get(0).getProductSku());
    Assertions.assertEquals(MASTER_CATALOG, response.getContent().get(0).getCategoryCode());
  }

  @Test
  public void doArchivalActionOnProductTest() {
    AuditTrailDto auditTrailDto =
        new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.PRODUCT_ARCHIVE, Boolean.toString(!product.isArchived()),
            Boolean.toString(product.isArchived()), null, product.getProductSku(), product.getProductName(),
            Constants.HYPHEN, false);
    AuditTrailListResponse auditTrailListResponse = new AuditTrailListResponse();
    auditTrailListResponse.setAccessChannel(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setChangedBy(Constants.DEFAULT_USERNAME);
    auditTrailListResponse.setClientId(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setRequestId(Constants.DEFAULT_REQUEST_ID);
    auditTrailListResponse.setUpdateDirectly(true);
    auditTrailListResponse.setAuditTrailResponseList(Collections.singletonList(auditTrailDto));
    productServiceImpl.doArchivalActionOnProduct(STORE_ID, product, listOfItems);
    product.setArchived(true);
    product.setCncActivated(false);
    product.setOnline(false);
    verify(saveOperationService).saveProductWithoutUpdatingSolr(product, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(objectConverterService).convertToProductAndItemEventModel(new ProductAndItemsVO(product, listOfItems));
    verify(saveAndPublishService).publishSolrUpdateEvent(anyList());
    auditTrailDto.setOldValue(String.valueOf(Boolean.FALSE));
    auditTrailDto.setNewValue(String.valueOf(Boolean.TRUE));
    verify(kafkaProducer).send(ProductDomainEventName.PRODUCT_SKU_UPDATE_HISTORY,
        auditTrailListResponse);
  }

  @Test
  public void doArchivalActionOnProductTest1() {
    product.setSuspended(true);
    product.setOff2OnChannelActive(true);
    AuditTrailDto auditTrailDto =
        new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.PRODUCT_ARCHIVE,
            Boolean.toString(!product.isArchived()), Boolean.toString(product.isArchived()), null,
            product.getProductSku(), product.getProductName(), Constants.HYPHEN, false);
    AuditTrailListResponse auditTrailListResponse = new AuditTrailListResponse();
    auditTrailListResponse.setAccessChannel(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setChangedBy(Constants.DEFAULT_USERNAME);
    auditTrailListResponse.setClientId(Constants.DEFAULT_CLIENT_ID_X_PRODUCT);
    auditTrailListResponse.setRequestId(Constants.DEFAULT_REQUEST_ID);
    auditTrailListResponse.setUpdateDirectly(true);
    auditTrailListResponse.setAuditTrailResponseList(Collections.singletonList(auditTrailDto));
    productServiceImpl.doArchivalActionOnProduct(STORE_ID, product, listOfItems);
    product.setArchived(true);
    product.setCncActivated(false);
    product.setArchivedBeforeSuspension(true);
    product.setOff2OnChannelActive(false);
    product.setOnline(false);
    auditTrailDto.setOldValue(String.valueOf(Boolean.FALSE));
    auditTrailDto.setNewValue(String.valueOf(Boolean.TRUE));
    verify(saveOperationService).saveProductWithoutUpdatingSolr(product, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(objectConverterService).convertToProductAndItemEventModel(new ProductAndItemsVO(product, listOfItems));
    verify(saveAndPublishService).publishSolrUpdateEvent(anyList());
    verify(kafkaProducer).send(ProductDomainEventName.PRODUCT_SKU_UPDATE_HISTORY,
        auditTrailListResponse);
  }

  @Test
  public void doArchivalActionOnProductArchivedTest() {
    product.setArchived(true);
    productServiceImpl.doArchivalActionOnProduct(STORE_ID, product, listOfItems);
    verify(objectConverterService).convertToProductAndItemEventModel(any(ProductAndItemsVO.class));
    verify(saveOperationService).saveProductWithoutUpdatingSolr(product, new ArrayList<>(),
        StringUtils.EMPTY, Collections.EMPTY_MAP);
    verify(saveAndPublishService).publishSolrUpdateEvent(anyList());


  }

  @Test
  public void updateUpcMigrationProductTest() {
    ItemCacheClearModel itemCacheClearModel = new ItemCacheClearModel();
    itemCacheClearModel.setItemSku(ITEM_SKU);
    itemCacheClearModel.setProductSku(PRODUCT_SKU_SYNC);
    ImageDomainEventModel imageDomainEventModel = new ImageDomainEventModel();
    message.setImages(Collections.singletonList(imageDomainEventModel));
    ProductItemDomainEventModel productItemDomainEventModel = new ProductItemDomainEventModel();
    productItemDomainEventModel.setGeneratedItemName(NAME);
    productItemDomainEventModel.setUpcCode(UPC_CODE);
    productItemDomainEventModel.setSkuCode(SKU_CODE);
    productItemDomainEventModel.setImages(Collections.singletonList(imageDomainEventModel));
    message.setProductCode(PRODUCT_CODE);
    message.setStoreId(STORE_ID);
    message.setMigrationType(Constants.UPC_MIGRATION);
    message.setProductItems(Collections.singletonList(productItemDomainEventModel));
    List<Product> products = new ArrayList<>();
    productUnsync.setProductSku(PRODUCT_SKU);
    products.add(this.productUnsync);
    when(itemService.findItemsByStoreIdAndItemCodeInAndMarkForDeleteFalse(STORE_ID, Collections.singleton(SKU_CODE))).thenReturn(listOfItems);
    when(saveOperationService.saveProductAndItemsWithoutPublishingEventAndWithoutReindexing(
        new ProductAndItemsVO(product, Collections.singletonList(item)))).thenReturn(
        new ProductAndItemsVO(productUnsync, Collections.singletonList(item)));
    when(itemRepository.saveAll(anyList())).thenReturn(listOfItems);
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE)).thenReturn(products);

    productServiceImpl.updateProductAndItemDetails(message, false);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_CODE);

    verify(itemService).findItemsByStoreIdAndItemCodeInAndMarkForDeleteFalse(STORE_ID, Collections.singleton(SKU_CODE));
    verify(itemRepository).saveAll(anyList());
    verify(kafkaProducer).send(eq(ProductDomainEventName.ITEM_CACHE_CLEAR_EVENT), eq(itemCacheClearModel));
  }

  @Test
  public void getProductL3SummaryResponseWithVariantCount1AndImageEmptyTest() throws IOException {
    itemPickupPoint.setItemSku(TOQ_15120_06641_00001);
    ReflectionTestUtils.setField(productServiceImpl, "solrStringDelimiter", "#_#");
    filePath = classLoader.getResource(FILE_PATH).getPath();
    File file = new File(filePath + File.separator + PRODUCT_SOLR_LIST);
    List<ProductSolr> productSolrs = objectMapper.readValue(file, new TypeReference<List<ProductSolr>>() {
    });
    File scoreFile = new File(filePath + File.separator + PRODUCT_AND_ITEM_SOLR);
    List<ProductAndItemSolr> productAndItemSolrs = objectMapper.readValue(scoreFile, new TypeReference<List<ProductAndItemSolr>>() {
    });
    File productScore = new File(filePath + File.separator + PRODUCT_SCORE);
    List<Product> products = objectMapper.readValue(productScore, new TypeReference<List<Product>>() {
    });
    products.get(0).setOff2OnChannelActive(true);
    Item item = getItem(TOQ_15120_06641_00001);
    item.setMasterDataItem(new MasterDataItem());
    item.getMasterDataItem()
        .setMasterDataItemImages(Collections.singletonList(masterDataItemImage));
    item.setOff2OnChannelActive(true);
    productSolrs.get(0).setIsPreOrderActive(true);
    productSolrs.get(0).setOff2OnChannelActive(true);
    productSolrs.get(0).setFreeSample(true);
    productSolrs.get(0).setPromoItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setWholesaleItemSkus(Arrays.asList(ITEM_SKU));
    productSolrs.get(0).setVariantCount(1);
    productSolrs.get(0).setL5Count(1);
    productSolrs.get(0).setProductMainImage(null);
    B2bFields b2bFields = B2bFields.builder().managed(true).build();
    ItemPickupPoint itemPickupPoint =
        ItemPickupPoint.builder().itemSku(item.getItemSku()).pickupPointCode(PICKUP_POINT_CODE)
            .price(item.getPrice()).itemViewConfig(item.getItemViewConfigs()).b2bFields(b2bFields).build();
    when(itemPickupPointService.findByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Arrays.asList(item.getItemSku()))).thenReturn(Arrays.asList(itemPickupPoint));
    Mockito.when(productSolrRepository
        .getL3ProductSummaryByProductSummaryRequest(anyString(), any(ProductSummaryRequestVo.class),
            any(PageRequest.class))).thenReturn(new PageImpl<>(productSolrs, PageRequest.of(0, 10), 1));
    products.get(0).setCncActivated(true);
    Mockito.when(productRepository
            .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList()))
        .thenReturn(products);
    Mockito.when(
            this.businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(
                STORE_ID, Collections.singletonList(PICKUP_POINT_CODE)))
        .thenReturn(Collections.singletonList(businessPartnerPickupPoint));
    Mockito.when(
            cacheItemHelperService.getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet()))
        .thenReturn(Arrays.asList(item));
    Mockito.when(
            cacheItemHelperService.findCacheableByStoreIdAndProductSku(anyString(), anyString()))
        .thenReturn(Arrays.asList(item));
    when(itemService.isPriceEditDisabled(any(ItemPickupPoint.class))).thenReturn(false);
    Page<ProductL3SummaryResponse> productL3SummaryResponse =
        this.productServiceImpl.getProductL3SummaryResponse(STORE_ID,
            ProductSummaryRequest.builder().merchantCode(MERCHANT_CODE).b2bActivated(true).b2cActivated(true).build(),
            PageRequest.of(0, 10), false);
    Mockito.verify(productSolrRepository).getL3ProductSummaryByProductSummaryRequest(anyString(),
        productSummaryRequestVoArgumentCaptor.capture(), any(PageRequest.class));
    Mockito.verify(productRepository)
        .findByStoreIdAndProductSkusAndMarkForDeleteFalse(anyString(), anyList());
    Mockito.verify(this.businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
            Collections.singletonList(PICKUP_POINT_CODE));
    Mockito.verify(cacheItemHelperService)
        .getCacheableItemsByProductSkusForSuspensionList(anyString(), Mockito.anySet());
    verify(itemService).isPriceEditDisabled(any(ItemPickupPoint.class));
    Assertions.assertNotNull(productL3SummaryResponse);
    Assertions.assertEquals(1, productL3SummaryResponse.getContent().size());
    Assertions.assertEquals("NIKE", productL3SummaryResponse.getContent().get(0).getBrand());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getProductScore());
    Assertions.assertEquals(0, productL3SummaryResponse.getContent().get(0).getPromoLabels().size());
    Assertions.assertNotNull(productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse());
    Assertions.assertEquals(2, productL3SummaryResponse.getContent().get(0).getItemL4SummaryResponse().getPromoLabels().size());
  }

  @Test
  public void setMainImageUrlTest() {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    Item item1 = new Item();
    item1.setProductSku(PRODUCT_SKU);
    item1.setMainImageUrl(LOCATION_PATH);
    Item item2 = new Item();
    item2.setProductSku(PRODUCT_SKU2);
    item2.setMainImageUrl(LOCATION_PATH);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU);
    Product product2 = new Product();
    product2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr1 = new ProductSolr();
    productSolr1.setProductSku(PRODUCT_SKU);
    ProductSolr productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr3 = new ProductSolr();
    productSolr3.setProductSku(PRODUCT_SKU3);
    productSolr3.setProductMainImage(LOCATION_PATH);
    Mockito.when(
        itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU2),
            new ArrayList<>())).thenReturn(Arrays.asList(item2));
    productServiceImpl.setMainImageUrl(STORE_ID,
        ImmutableMap.of(PRODUCT_SKU, Arrays.asList(item1)),
        Arrays.asList(product1, product2), Arrays.asList(productSolr1, productSolr2, productSolr3));
    Mockito.verify(itemService)
        .getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU2),
            new ArrayList<>());
    Mockito.verify(productAndItemSolrIndexerService).updateProductDetailsInSolr(anyList());
  }

  @Test
  public void setMainImageUrlItemNotFoundTest() {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    Item item1 = new Item();
    item1.setProductSku(PRODUCT_SKU);
    item1.setMainImageUrl(LOCATION_PATH);
    Item item2 = new Item();
    item2.setProductSku(PRODUCT_SKU3);
    item2.setMainImageUrl(LOCATION_PATH);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU);
    Product product2 = new Product();
    product2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr1 = new ProductSolr();
    productSolr1.setProductSku(PRODUCT_SKU);
    ProductSolr productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr3 = new ProductSolr();
    productSolr3.setProductSku(PRODUCT_SKU3);
    productSolr3.setProductMainImage(LOCATION_PATH);
    Mockito.when(
        itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>())).thenReturn(Arrays.asList(item2));
    productServiceImpl.setMainImageUrl(STORE_ID,
        new HashMap<>(),
        Arrays.asList(product1, product2), Arrays.asList(productSolr1, productSolr2, productSolr3));
    Mockito.verify(itemService)
        .getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>());
    Mockito.verify(productAndItemSolrIndexerService).updateProductDetailsInSolr(anyList());
  }

  @Test
  public void setMainImageUrlItemNotFoundSuspenedCaseTest() {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    Item item1 = new Item();
    item1.setProductSku(PRODUCT_SKU);
    item1.setMainImageUrl(LOCATION_PATH);
    Item item2 = new Item();
    item2.setProductSku(PRODUCT_SKU3);
    item2.setMainImageUrl(LOCATION_PATH);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU);
    Product product2 = new Product();
    product2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr1 = new ProductSolr();
    productSolr1.setProductSku(PRODUCT_SKU);
    ProductSolr productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr3 = new ProductSolr();
    productSolr3.setProductSku(PRODUCT_SKU3);
    productSolr3.setProductMainImage(LOCATION_PATH);
    Mockito.when(
        itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>())).thenReturn(Arrays.asList(item2));
    productServiceImpl.setMainImageUrl(STORE_ID,
        new HashMap<>(),
        Arrays.asList(), Arrays.asList(productSolr1, productSolr2, productSolr3));
    Mockito.verify(itemService)
        .getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>());
    Mockito.verify(productAndItemSolrIndexerService).updateProductDetailsInSolr(anyList());
  }

  @Test
  public void setMainImageUrlItemNotFoundSuspenedCaseExceptionTest() {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    Item item1 = new Item();
    item1.setProductSku(PRODUCT_SKU);
    item1.setMainImageUrl(LOCATION_PATH);
    Item item2 = new Item();
    item2.setProductSku(PRODUCT_SKU3);
    item2.setMainImageUrl(LOCATION_PATH);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU);
    Product product2 = new Product();
    product2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr1 = new ProductSolr();
    productSolr1.setProductSku(PRODUCT_SKU);
    ProductSolr productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr3 = new ProductSolr();
    productSolr3.setProductSku(PRODUCT_SKU3);
    productSolr3.setProductMainImage(LOCATION_PATH);
    Mockito.when(
        itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>())).thenThrow(RuntimeException.class);
    productServiceImpl.setMainImageUrl(STORE_ID,
        new HashMap<>(),
        Arrays.asList(), Arrays.asList(productSolr1, productSolr2, productSolr3));
    Mockito.verify(itemService)
        .getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>());
  }

  @Test
  public void setMainImageUrlItemNotFound2_Test() {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    Item item1 = new Item();
    item1.setProductSku(PRODUCT_SKU);
    item1.setMainImageUrl(LOCATION_PATH);
    Item item2 = new Item();
    item2.setProductSku(PRODUCT_SKU3);
    item2.setMainImageUrl(LOCATION_PATH);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU);
    Product product2 = new Product();
    product2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr1 = new ProductSolr();
    productSolr1.setProductSku(PRODUCT_SKU);
    ProductSolr productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr3 = new ProductSolr();
    productSolr3.setProductSku(PRODUCT_SKU3);
    productSolr3.setProductMainImage(LOCATION_PATH);
    Mockito.when(
        itemService.getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>())).thenReturn(new ArrayList<>());
    productServiceImpl.setMainImageUrl(STORE_ID,
        new HashMap<>(),
        Arrays.asList(product1, product2), Arrays.asList(productSolr1, productSolr2, productSolr3));
    Mockito.verify(itemService)
        .getItemsByStoreIdAndProductSkusOrItemSkusIn(STORE_ID, Arrays.asList(PRODUCT_SKU, PRODUCT_SKU2),
            new ArrayList<>());
  }

  @Test
  public void setMainImageUrlSingleVariantTest() {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    Item item1 = new Item();
    item1.setProductSku(PRODUCT_SKU);
    item1.setMainImageUrl(LOCATION_PATH);
    Item item2 = new Item();
    item2.setProductSku(PRODUCT_SKU3);
    item2.setMainImageUrl(LOCATION_PATH);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU);
    Product product2 = new Product();
    product2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr1 = new ProductSolr();
    productSolr1.setProductSku(PRODUCT_SKU);
    ProductSolr productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr3 = new ProductSolr();
    productSolr3.setProductSku(PRODUCT_SKU3);
    productSolr3.setProductMainImage(LOCATION_PATH);
    productServiceImpl.setMainImageUrl(STORE_ID,
        ImmutableMap.of(PRODUCT_SKU, Arrays.asList(item1)),
        Arrays.asList(product1, product2), Arrays.asList(productSolr1));
    Mockito.verify(productAndItemSolrIndexerService).updateProductDetailsInSolr(anyList());
  }

  @Test
  public void setMainImageUrlSingleVariantWithMainImageTest() {
    ReflectionTestUtils.setField(productServiceImpl, "populateProductMainImageInListing", true);
    Item item1 = new Item();
    item1.setProductSku(PRODUCT_SKU);
    item1.setMainImageUrl(LOCATION_PATH);
    Item item2 = new Item();
    item2.setProductSku(PRODUCT_SKU3);
    item2.setMainImageUrl(LOCATION_PATH);
    Product product1 = new Product();
    product1.setProductSku(PRODUCT_SKU);
    Product product2 = new Product();
    product2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr1 = new ProductSolr();
    productSolr1.setProductSku(PRODUCT_SKU);
    ProductSolr productSolr2 = new ProductSolr();
    productSolr2.setProductSku(PRODUCT_SKU2);
    ProductSolr productSolr3 = new ProductSolr();
    productSolr3.setProductSku(PRODUCT_SKU3);
    productSolr3.setProductMainImage(LOCATION_PATH);
    productServiceImpl.setMainImageUrl(STORE_ID,
        ImmutableMap.of(PRODUCT_SKU, Arrays.asList(item1)),
        Arrays.asList(product1, product2), Arrays.asList(productSolr3));
  }

  @Test
  public void generateEditProductDetailDTOTest() throws Exception {
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        productSyncTobeUpdated.getProductSku())).thenReturn(productSyncTobeUpdated);
    listOfItems.get(0).setCncActivated(true);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSkuAndMarkForDeleteFalse(
        productSyncTobeUpdated.getStoreId(), productSyncTobeUpdated.getProductSku())).thenReturn(listOfItems);
    when(
        itemPickupPointService.getItemPickupPointsByProductSkuAndMarkForDeleteFalse(productSyncTobeUpdated.getStoreId(),
            productSyncTobeUpdated.getProductSku())).thenReturn(Arrays.asList(itemPickupPoint));
    when(productCategoryBaseClient.getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        productSyncTobeUpdated.getProductCode())).thenReturn(productDetailResponse);
    EditProductDetailDTO editProductDetailDTO =
        productServiceImpl.generateEditProductDetailDTO(true, productSyncTobeUpdated.getProductSku(), REQUEST_ID,
            EditChangeType.CONTENT);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(Constants.DEFAULT_STORE_ID,
        productSyncTobeUpdated.getProductSku());
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSkuAndMarkForDeleteFalse(
        productSyncTobeUpdated.getStoreId(), productSyncTobeUpdated.getProductSku());
    verify(itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(
        productSyncTobeUpdated.getStoreId(), productSyncTobeUpdated.getProductSku());
    verify(productCategoryBaseClient).getProductDetailByProductCode(REQUEST_ID, Constants.DEFAULT_USERNAME,
        productSyncTobeUpdated.getProductCode());
    Assertions.assertEquals(editProductDetailDTO.getCncItemCount(), 1L);
  }

  @Test
  public void processFinalSaveAndPublishEventForContentEditOnlyTest() throws Exception {
    editProductDetailDTO.setProductUpdated(true);
    editProductDetailDTO.setFreeSampleToggledOn(true);
    editProductDetailDTO.setExistingProductScore(new ProductScoreVo());
    editProductDetailDTO.setPreOrderVO(new PreOrderVO());
    CommonUtil.setOfflineItemIdToItemPickupPointMap(new ArrayList<>(Collections.singletonList(itemPickupPoint)),
        editProductDetailDTO);
    CommonUtil.setUpdatedItemSkuAndItemMap(new ArrayList<>(Collections.singletonList(item)), editProductDetailDTO);
    when(saveOperationService.saveProductAndItemsWithoutPublishingEvent(any())).thenReturn(
        new ProductAndItemsVO(productSyncTobeUpdated, Arrays.asList(item)));
    when(objectConverterService.toProductScore(any())).thenReturn(new ProductScore());
    this.productServiceImpl.processFinalSaveAndPublishEventForContentEditOnly(editProductDetailDTO);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEvent(any());
    verify(saveAndPublishService).publishListOfItems(Arrays.asList(item));
    verify(itemPickupPointService).saveItemPickupPoint(anyList());
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(anyList(), anyList(),
      eq(Collections.EMPTY_MAP));
    verify(saveAndPublishService).publishViewConfigChange(any());
    verify(objectConverterService).toProductScore(any());
    verify(productScoreHistoryL3Service).saveProductScoreHistoryL3(anyString(), anyString(), any(), any());
    verify(kafkaProducer).send(eq(ProductDomainEventName.PRODUCT_PREORDER_STATUS),
        eq(editProductDetailDTO.getProduct().getProductSku()), any());
  }

  @Test
  public void processFinalSaveAndPublishEventForContentEditOnlyFalseTest() throws Exception {
    editProductDetailDTO.setProductUpdated(true);
    editProductDetailDTO.setFreeSampleToggledOn(true);
    when(saveOperationService.saveProductAndItemsWithoutPublishingEvent(any())).thenReturn(
        new ProductAndItemsVO(productSyncTobeUpdated, new ArrayList<>()));
    this.productServiceImpl.processFinalSaveAndPublishEventForContentEditOnly(editProductDetailDTO);
    verify(saveOperationService).saveProductAndItemsWithoutPublishingEvent(any());
  }

  @Test
  public void processFinalSaveAndPublishEventForContentEditOnlyProductNotUpdatedTest() throws Exception {
    editProductDetailDTO.setProductUpdated(false);
    editProductDetailDTO.setFreeSampleToggledOn(false);
    this.productServiceImpl.processFinalSaveAndPublishEventForContentEditOnly(editProductDetailDTO);
  }

  @Test
  public void findProductBasicDetailsByProductSkuTest() {
    productServiceImpl.findProductBasicDetailsByProductSku(STORE_ID,
        new SimpleListStringRequest(Collections.singletonList(PRODUCT_SKU)), false);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void findProductBasicDetailsByProductSkuNeedSalesCategoryDataTest() {
    Set<String> salesCategorySet = new HashSet<>();
    salesCategorySet.add(SALES_CATEGORY_CODE);
    Map<String, List<CategoryResponse>> parentCategoriesFromDbAndCache = new HashMap<>();
    categoryResponse.setCategoryCode(CATEGORY_CODE);
    parentCategoriesFromDbAndCache.put(CATEGORY_CODE, Collections.singletonList(categoryResponse));
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(objectConverterService.getSalesCategoryCodesFromSalesCatalogs(product.getSalesCatalogs()))
        .thenReturn(salesCategoryList);
    Mockito.when(
        cachedService.getParentCategoriesFromDbAndCache(Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME,
            salesCategorySet)).thenReturn(parentCategoriesFromDbAndCache);
    List<ProductBasicResponse> productBasicDetailsByProductSku =
        productServiceImpl.findProductBasicDetailsByProductSku(STORE_ID,
            new SimpleListStringRequest(Collections.singletonList(PRODUCT_SKU)), true);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(cachedService)
        .getParentCategoriesFromDbAndCache(Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, salesCategorySet);
    Mockito.verify(objectConverterService)
        .toSalesCategoryHierarchy(Mockito.anyList(), eq(parentCategoriesFromDbAndCache));
    Mockito.verify(objectConverterService).getSalesCategoryCodesFromSalesCatalogs(product.getSalesCatalogs());
    Assertions.assertEquals(SALES_CATEGORY_CODE, productBasicDetailsByProductSku.get(0).getSalesCategoryCodes().get(0));
  }

  @Test
  public void findProductBasicDetailsByProductSku_preOrder() {
    Set<String> salesCategorySet = new HashSet<>();
    salesCategorySet.add(SALES_CATEGORY_CODE);
    Map<String, List<CategoryResponse>> parentCategoriesFromDbAndCache = new HashMap<>();
    categoryResponse.setCategoryCode(CATEGORY_CODE);
    parentCategoriesFromDbAndCache.put(CATEGORY_CODE, Collections.singletonList(categoryResponse));
    PreOrder preOrder = new PreOrder();
    preOrder.setPreOrderDate(new Date());
    product.setPreOrder(preOrder);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(objectConverterService.getSalesCategoryCodesFromSalesCatalogs(product.getSalesCatalogs()))
        .thenReturn(salesCategoryList);
    Mockito.when(
        cachedService.getParentCategoriesFromDbAndCache(Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME,
            salesCategorySet)).thenReturn(parentCategoriesFromDbAndCache);
    List<ProductBasicResponse> productBasicDetailsByProductSku =
        productServiceImpl.findProductBasicDetailsByProductSku(STORE_ID,
            new SimpleListStringRequest(Collections.singletonList(PRODUCT_SKU)), true);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(cachedService)
        .getParentCategoriesFromDbAndCache(Constants.DEFAULT_REQUEST_ID, Constants.DEFAULT_USERNAME, salesCategorySet);
    Mockito.verify(objectConverterService)
        .toSalesCategoryHierarchy(Mockito.anyList(), eq(parentCategoriesFromDbAndCache));
    Mockito.verify(objectConverterService).getSalesCategoryCodesFromSalesCatalogs(product.getSalesCatalogs());
    Assertions.assertEquals(SALES_CATEGORY_CODE, productBasicDetailsByProductSku.get(0).getSalesCategoryCodes().get(0));
  }

  @Test
  public void findProductBasicDetailsByProductSkuNotEmptyTest() {
    product.setProductName(PRODUCT_NAME);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(product);
    List<ProductBasicResponse> productBasicResponses =
        productServiceImpl.findProductBasicDetailsByProductSku(STORE_ID,
            new SimpleListStringRequest(Collections.singletonList(PRODUCT_SKU)), false);
    Mockito.verify(productCacheableService)
        .findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Assertions.assertEquals(PRODUCT_NAME, productBasicResponses.get(0).getProductName());
  }

  @Test
  public void findProductBasicDetailsByItemSkusEmptyTest() {
    productServiceImpl.findProductBasicDetailsByItemSkus(STORE_ID,
        new SimpleListStringRequest(Collections.singletonList(PRODUCT_SKU)));
    Mockito.verify(itemService)
        .getItemsByStoreIdAndItemSkus(STORE_ID, new HashSet<>(Collections.singleton(PRODUCT_SKU)));
  }

  @Test
  public void findProductBasicDetailsByItemSkusTest() {
    item.setProductSku(PRODUCT_SKU);
    Mockito.when(itemService.getItemsByStoreIdAndItemSkus(STORE_ID, new HashSet<>(Collections.singleton(PRODUCT_SKU))))
        .thenReturn(Collections.singletonList(item));
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    List<ProductBasicResponse> productBasicResponses =
        productServiceImpl.findProductBasicDetailsByItemSkus(STORE_ID,
            new SimpleListStringRequest(Collections.singletonList(PRODUCT_SKU)));
    Mockito.verify(itemService)
        .getItemsByStoreIdAndItemSkus(STORE_ID, new HashSet<>(Collections.singleton(PRODUCT_SKU)));
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void activateProductAndItemsOnNeedCorrectionUpdateRegularProductTest() throws Exception {
    EditItemResponse editItemResponse = new EditItemResponse();
    itemWithMasterDataItem.setPermanentDelete(true);
    listOfItems.add(itemWithMasterDataItem);
    editItemResponse.setUpdatedItems(this.listOfItems);
    ItemPickupPoint itemPickupPoint1 = new ItemPickupPoint();
    itemPickupPoint1.setItemSku(ITEM_SKU);
    itemPickupPoint1.setFbbActivated(false);
    ItemPickupPoint itemPickupPoint2 = new ItemPickupPoint();
    itemPickupPoint2.setItemSku(ITEM_SKU);
    itemPickupPoint2.setFbbActivated(true);
    List<ItemPickupPoint> allUpdatedItemPickupPoints = new ArrayList<>();
    allUpdatedItemPickupPoints.add(itemPickupPoint1);
    allUpdatedItemPickupPoints.add(itemPickupPoint2);
    editItemResponse.setAllUpdatedItemPickupPoints(allUpdatedItemPickupPoints);
    listOfItems.get(0).setItemCode(ITEM_CODE);
    when(this.productCacheableService
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC))
        .thenReturn(this.productSync);
    when(this.itemService
        .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
            true))
        .thenReturn(editItemResponse);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(getProductDetailResponse());
    productServiceImpl.activateProductAndItemsOnNeedCorrection(STORE_ID, USERNAME, REQUEST_ID,
        new NeedCorrectionProductActivationRequest(PRODUCT_SKU_SYNC, Arrays.asList(itemActivationRequest), preOrderDTO,
            ProductType.REGULAR, false, false, false, false));
    verify(this.productCacheableService)
        .findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.PRODUCT_SKU_SYNC);
    verify(this.itemService)
        .activateItemsOnNeedCorrectionWithMpp(STORE_ID, PRODUCT_SKU_SYNC, productSync.getMerchantCode(), Arrays.asList(itemActivationRequest),
            true);
    verify(this.masterDataService)
        .getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
            ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode());
    verify(this.saveOperationService).saveProductAndItems(productAndItemsVOArgumentCaptor.capture(),
        eq(Collections.singletonList(ProductChangeEventType.FORCE_REVIEW_FLAG_CHANGE)));
    verify(this.objectConverterService).convertActivateNeedRevisionResponseList(eq(false), any(), any());
    verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(Mockito.anyCollection());
    Assertions.assertTrue(productAndItemsVOArgumentCaptor.getValue().getProduct().isFbbActivated());
    assertFalse(productAndItemsVOArgumentCaptor.getValue().getItems().get(0).isLateFulfillment());
  }

  @Test
  public void findProductBasicDetailsByProductSku_bundleProductTest() {
    product.setMarkForDelete(true);
    product.setBundleProduct(true);
    product.setProductSku(PRODUCT_SKU);
    List<String> productSkus = new ArrayList<>();
    productSkus.add(PRODUCT_SKU);
    Mockito.when(productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    List<ProductBasicResponse> productBasicResponses =
        productServiceImpl.findProductBasicDetailsByProductSku(STORE_ID, new SimpleListStringRequest(productSkus),
            false);
    Mockito.verify(productCacheableService).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    ProductBasicResponse productBasicResponse =
        ProductBasicResponse.builder().bundleProduct(productBasicResponses.get(0).isBundleProduct())
            .productSku(productBasicResponses.get(0).getProductSku()).build();
    Assertions.assertTrue(productBasicResponse.isBundleProduct());
    Assertions.assertEquals(PRODUCT_SKU, productBasicResponse.getProductSku());
  }

  @Test
  public void testMakeProductBundleFromBundleRecipe() throws Exception {
    ProductBundleCreationRequest productBundleCreationRequest = new ProductBundleCreationRequest();
    List<CreateUpdateBOMRecipeResponse.Recipe> recipe = new ArrayList<>();
    CreateUpdateBOMRecipeResponse.Recipe recipe1 = new CreateUpdateBOMRecipeResponse.Recipe();
    recipe1.setItemCode(ITEM_CODE);
    recipe.add(recipe1);
    List<BundleRecipeVo> bundleRecipeList = new ArrayList<>();
    BundleRecipeVo bundleRecipe = new BundleRecipeVo();
    bundleRecipe.setItemSku(ITEM_SKU);
    bundleRecipe.setQuantity(10);
    bundleRecipeList.add(bundleRecipe);
    productBundleCreationRequest.setBundleRecipeList(bundleRecipeList);
    item.setItemSku(ITEM_SKU);
    item.setItemCode(ITEM_CODE);
    CreateUpdateBOMRecipeResponse response = new CreateUpdateBOMRecipeResponse();
    response.setActive(true);
    response.setRecipe(recipe);
    when(cacheItemHelperService.findCacheableByStoreIdAndItemSku(STORE_ID,ITEM_SKU)).thenReturn(item);
    when(itemRepository.findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,Collections.singleton(ITEM_SKU))).thenReturn(Collections.singletonList(item));
    when(warehouseItemMasterOutbound.createAndUpdateProductBundle(any(
      CreateUpdateBillOfMaterialRecipeCommandRequest.class))).thenReturn(response);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, item.getProductSku())).thenReturn(new Product());
    productServiceImpl.makeProductBundleFromBundleRecipe(STORE_ID,ITEM_SKU,productBundleCreationRequest);
    Mockito.verify(itemRepository).findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(any(), any());
    Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndItemSku(any(), any());
    Mockito.verify(itemService).publishUpdateToSolrEvent(any(), any());
    Mockito.verify(productRepository).findByStoreIdAndProductSku(any(), any());
    Mockito.verify(saveAndPublishService).saveItems(any());
    Mockito.verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(any());
    Mockito.verify(saveAndPublishService).saveProducts(any());
    Mockito.verify(cacheEvictHelperService).evictProductData(any(), any());
    Mockito.verify(cacheEvictHelperService).evictItemCache(any(), any());
    Mockito.verify(itemService).updateRecipeForSharedProducts(any(), any());
  }


  @Test
  public void testMakeProductBundleFromBundleRecipeSharedProduct() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "sharedProductBundleRecipeEditEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "warehouseBomActivated", true);
    ProductBundleCreationRequest productBundleCreationRequest = new ProductBundleCreationRequest();
    List<CreateUpdateBOMRecipeResponse.Recipe> recipe = new ArrayList<>();
    CreateUpdateBOMRecipeResponse.Recipe recipe1 = new CreateUpdateBOMRecipeResponse.Recipe();
    recipe1.setItemCode(ITEM_CODE);
    recipe.add(recipe1);
    List<BundleRecipeVo> bundleRecipeList = new ArrayList<>();
    BundleRecipeVo bundleRecipe = new BundleRecipeVo();
    bundleRecipe.setItemSku(ITEM_SKU);
    bundleRecipe.setQuantity(10);
    bundleRecipeList.add(bundleRecipe);
    productBundleCreationRequest.setBundleRecipeList(bundleRecipeList);
    item.setItemSku(ITEM_SKU);
    item.setItemCode(ITEM_CODE);
    CreateUpdateBOMRecipeResponse response = new CreateUpdateBOMRecipeResponse();
    response.setActive(true);
    response.setRecipe(recipe);
    when(cacheItemHelperService.findCacheableByStoreIdAndItemSku(STORE_ID, ITEM_SKU)).thenReturn(item);
    when(itemRepository.findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Collections.singleton(ITEM_SKU))).thenReturn(Collections.singletonList(item));
    when(warehouseItemMasterOutbound.createAndUpdateProductBundle(
        any(CreateUpdateBillOfMaterialRecipeCommandRequest.class))).thenReturn(response);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, item.getProductSku())).thenReturn(new Product());
    when(itemService.getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE))).thenReturn(Arrays.asList(
        SharedProductBundleRecipeResponse.builder().itemCode(ITEM_CODE).sharedProduct(true)
            .bundleRecipe(Set.of(new SkuCodeBundleRecipeResponse(ITEM_CODE, 10))).build()));
    productServiceImpl.makeProductBundleFromBundleRecipe(STORE_ID, ITEM_SKU, productBundleCreationRequest);
    Mockito.verify(itemRepository).findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(any(), any());
    Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndItemSku(any(), any());
    Mockito.verify(itemService).publishUpdateToSolrEvent(any(), any());
    Mockito.verify(productRepository).findByStoreIdAndProductSku(any(), any());
    Mockito.verify(saveAndPublishService).saveItems(any());
    Mockito.verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(any());
    Mockito.verify(saveAndPublishService).saveProducts(any());
    Mockito.verify(cacheEvictHelperService).evictProductData(any(), any());
    Mockito.verify(cacheEvictHelperService).evictItemCache(any(), any());
    Mockito.verify(itemService).updateRecipeForSharedProducts(any(), any());
    Mockito.verify(itemService).getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE));
  }

  @Test
  public void testMakeProductBundleFromBundleRecipeSharedDifferentRecipeProduct() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "sharedProductBundleRecipeEditEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "warehouseBomActivated", true);
    ProductBundleCreationRequest productBundleCreationRequest = new ProductBundleCreationRequest();
    List<CreateUpdateBOMRecipeResponse.Recipe> recipe = new ArrayList<>();
    CreateUpdateBOMRecipeResponse.Recipe recipe1 = new CreateUpdateBOMRecipeResponse.Recipe();
    recipe1.setItemCode(ITEM_CODE);
    recipe.add(recipe1);
    List<BundleRecipeVo> bundleRecipeList = new ArrayList<>();
    BundleRecipeVo bundleRecipe = new BundleRecipeVo();
    bundleRecipe.setItemSku(ITEM_SKU_2);
    bundleRecipe.setQuantity(10);
    bundleRecipeList.add(bundleRecipe);
    productBundleCreationRequest.setBundleRecipeList(bundleRecipeList);
    item.setItemSku(ITEM_SKU);
    item.setItemCode(ITEM_CODE);
    CreateUpdateBOMRecipeResponse response = new CreateUpdateBOMRecipeResponse();
    response.setActive(true);
    response.setRecipe(recipe);
    when(cacheItemHelperService.findCacheableByStoreIdAndItemSku(STORE_ID, ITEM_SKU)).thenReturn(item);
    when(itemRepository.findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID, Set.of(ITEM_SKU, ITEM_SKU_2))).thenReturn(Arrays.asList(item, getItems().get(1)));
    when(warehouseItemMasterOutbound.createAndUpdateProductBundle(
        any(CreateUpdateBillOfMaterialRecipeCommandRequest.class))).thenReturn(response);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, item.getProductSku())).thenReturn(new Product());
    when(itemService.getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE))).thenReturn(Arrays.asList(
        SharedProductBundleRecipeResponse.builder().itemCode(ITEM_CODE).sharedProduct(true)
            .bundleRecipe(Set.of(new SkuCodeBundleRecipeResponse(ITEM_CODE, 10))).build()));
    try {
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> productServiceImpl.makeProductBundleFromBundleRecipe(STORE_ID, ITEM_SKU, productBundleCreationRequest));
    }
    finally {
      Mockito.verify(itemRepository).findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(any(), any());
      Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndItemSku(any(), any());
      Mockito.verify(itemService).getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE));
    }
  }

  @Test
  public void testMakeProductBundleFromBundleRecipeSharedProductNoRecipe() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "sharedProductBundleRecipeEditEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "warehouseBomActivated", true);
    ProductBundleCreationRequest productBundleCreationRequest = new ProductBundleCreationRequest();
    List<CreateUpdateBOMRecipeResponse.Recipe> recipe = new ArrayList<>();
    CreateUpdateBOMRecipeResponse.Recipe recipe1 = new CreateUpdateBOMRecipeResponse.Recipe();
    recipe1.setItemCode(ITEM_CODE);
    recipe.add(recipe1);
    List<BundleRecipeVo> bundleRecipeList = new ArrayList<>();
    BundleRecipeVo bundleRecipe = new BundleRecipeVo();
    bundleRecipe.setItemSku(ITEM_SKU);
    bundleRecipe.setQuantity(10);
    bundleRecipeList.add(bundleRecipe);
    productBundleCreationRequest.setBundleRecipeList(bundleRecipeList);
    item.setItemSku(ITEM_SKU);
    item.setItemCode(ITEM_CODE);
    CreateUpdateBOMRecipeResponse response = new CreateUpdateBOMRecipeResponse();
    response.setActive(true);
    response.setRecipe(recipe);
    when(cacheItemHelperService.findCacheableByStoreIdAndItemSku(STORE_ID, ITEM_SKU)).thenReturn(item);
    when(itemRepository.findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Collections.singleton(ITEM_SKU))).thenReturn(Collections.singletonList(item));
    when(warehouseItemMasterOutbound.createAndUpdateProductBundle(
        any(CreateUpdateBillOfMaterialRecipeCommandRequest.class))).thenReturn(response);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, item.getProductSku())).thenReturn(new Product());
    when(itemService.getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE))).thenReturn(Arrays.asList(
        SharedProductBundleRecipeResponse.builder().itemCode(ITEM_CODE).sharedProduct(true).build()));
    try {
      productServiceImpl.makeProductBundleFromBundleRecipe(STORE_ID, ITEM_SKU, productBundleCreationRequest);
    }
    finally {
      Mockito.verify(itemRepository).findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(any(), any());
      Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndItemSku(any(), any());
      Mockito.verify(itemService).publishUpdateToSolrEvent(any(), any());
      Mockito.verify(productRepository).findByStoreIdAndProductSku(any(), any());
      Mockito.verify(saveAndPublishService).saveItems(any());
      Mockito.verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(any());
      Mockito.verify(saveAndPublishService).saveProducts(any());
      Mockito.verify(cacheEvictHelperService).evictProductData(any(), any());
      Mockito.verify(cacheEvictHelperService).evictItemCache(any(), any());
      Mockito.verify(itemService).updateRecipeForSharedProducts(any(), any());
      Mockito.verify(itemService).getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE));
    }
  }

  @Test
  public void testMakeProductBundleFromBundleRecipeUnSharedProduct() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "sharedProductBundleRecipeEditEnabled", true);
    ReflectionTestUtils.setField(productServiceImpl, "warehouseBomActivated", true);
    ProductBundleCreationRequest productBundleCreationRequest = new ProductBundleCreationRequest();
    List<CreateUpdateBOMRecipeResponse.Recipe> recipe = new ArrayList<>();
    CreateUpdateBOMRecipeResponse.Recipe recipe1 = new CreateUpdateBOMRecipeResponse.Recipe();
    recipe1.setItemCode(ITEM_CODE);
    recipe.add(recipe1);
    List<BundleRecipeVo> bundleRecipeList = new ArrayList<>();
    BundleRecipeVo bundleRecipe = new BundleRecipeVo();
    bundleRecipe.setItemSku(ITEM_SKU);
    bundleRecipe.setQuantity(10);
    bundleRecipeList.add(bundleRecipe);
    productBundleCreationRequest.setBundleRecipeList(bundleRecipeList);
    item.setItemSku(ITEM_SKU);
    item.setItemCode(ITEM_CODE);
    CreateUpdateBOMRecipeResponse response = new CreateUpdateBOMRecipeResponse();
    response.setActive(true);
    response.setRecipe(recipe);
    when(cacheItemHelperService.findCacheableByStoreIdAndItemSku(STORE_ID, ITEM_SKU)).thenReturn(item);
    when(itemRepository.findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(STORE_ID,
        Collections.singleton(ITEM_SKU))).thenReturn(Collections.singletonList(item));
    when(warehouseItemMasterOutbound.createAndUpdateProductBundle(
        any(CreateUpdateBillOfMaterialRecipeCommandRequest.class))).thenReturn(response);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, item.getProductSku())).thenReturn(new Product());
    when(itemService.getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE))).thenReturn(new ArrayList<>());
    productServiceImpl.makeProductBundleFromBundleRecipe(STORE_ID, ITEM_SKU, productBundleCreationRequest);
    Mockito.verify(itemRepository).findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(any(), any());
    Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndItemSku(any(), any());
    Mockito.verify(itemService).publishUpdateToSolrEvent(any(), any());
    Mockito.verify(productRepository).findByStoreIdAndProductSku(any(), any());
    Mockito.verify(saveAndPublishService).saveItems(any());
    Mockito.verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(any());
    Mockito.verify(saveAndPublishService).saveProducts(any());
    Mockito.verify(cacheEvictHelperService).evictProductData(any(), any());
    Mockito.verify(cacheEvictHelperService).evictItemCache(any(), any());
    Mockito.verify(itemService).updateRecipeForSharedProducts(any(), any());
    Mockito.verify(itemService).getBundleRecipeForSharedItems(STORE_ID, Set.of(ITEM_CODE));
  }

  @Test
  public void testMakeProductBundleFromBundleRecipeWarehouseBomActivatedTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl,"warehouseBomActivated",true);
    ProductBundleCreationRequest productBundleCreationRequest = new ProductBundleCreationRequest();
    List<CreateUpdateBOMRecipeResponse.Recipe> recipe = new ArrayList<>();
    CreateUpdateBOMRecipeResponse.Recipe recipe1 = new CreateUpdateBOMRecipeResponse.Recipe();
    recipe1.setItemCode(ITEM_CODE);
    recipe.add(recipe1);
    List<BundleRecipeVo> bundleRecipeList = new ArrayList<>();
    BundleRecipeVo bundleRecipe = new BundleRecipeVo();
    bundleRecipe.setItemSku(ITEM_SKU);
    bundleRecipe.setQuantity(10);
    bundleRecipeList.add(bundleRecipe);
    productBundleCreationRequest.setBundleRecipeList(bundleRecipeList);
    item.setItemSku(ITEM_SKU);
    item.setItemCode(ITEM_CODE);
    CreateUpdateBOMRecipeResponse response = new CreateUpdateBOMRecipeResponse();
    response.setActive(true);
    response.setRecipe(recipe);
    when(cacheItemHelperService.findCacheableByStoreIdAndItemSku(STORE_ID,ITEM_SKU)).thenReturn(item);
    when(itemRepository.findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(any(), any())).thenReturn(Collections.singletonList(item));
    when(warehouseItemMasterOutbound.createAndUpdateProductBundle(any(CreateUpdateBillOfMaterialRecipeCommandRequest.class))).thenReturn(response);
    when(productRepository.findByStoreIdAndProductSku(STORE_ID, item.getProductSku())).thenReturn(null);
    productServiceImpl.makeProductBundleFromBundleRecipe(STORE_ID,ITEM_SKU,productBundleCreationRequest);
    Mockito.verify(itemRepository).findItemsByStoreIdAndItemSkuInAndMarkForDeleteFalse(any(), any());
    Mockito.verify(cacheItemHelperService).findCacheableByStoreIdAndItemSku(any(), any());
    Mockito.verify(itemService).publishUpdateToSolrEvent(any(), any());
    Mockito.verify(productRepository).findByStoreIdAndProductSku(any(), any());
    Mockito.verify(saveAndPublishService).saveItems(any());
    Mockito.verify(saveAndPublishService).publishProductBundleOneToOneMappingEvent(any());
    Mockito.verify(cacheEvictHelperService).evictItemCache(any(), any());
    Mockito.verify(itemService).updateRecipeForSharedProducts(any(), any());
  }

  @Test
  public void getAllProductsSuccess() throws Exception {
    Set<String> productSkus = new HashSet<>();
    productSkus.add(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    this.productServiceImpl.getAllProducts(ProductServiceImplTest.STORE_ID, productSkus, false);
    verify(this.productRepository).findProductByStoreIdAndProductSkuIn(ProductServiceImplTest.STORE_ID,
        new ArrayList<>(productSkus), false);
  }

  @Test
  public void getAllProductsWithBlankStoreId() throws Exception {
    Set<String> productSkus = new HashSet<>();
    productSkus.add(ProductServiceImplTest.PRODUCT_SKU_SYNC);
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getAllProducts("", productSkus, false));
  }

  @Test
  public void getAllProductsWithInvalidSku() throws Exception {
    Set<String> productSkus = new HashSet<>();
    productSkus.add("PRODUCT_SKU_SYNC");
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getAllProducts(STORE_ID, productSkus, false));
  }

  @Test
  public void getAllProductsWithEmptyList() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getAllProducts(ProductServiceImplTest.STORE_ID, new HashSet<String>(), false));
  }

  @Test
  public void getAllProductsWithNullList() throws Exception {
    Assertions.assertThrows(ApplicationRuntimeException.class, () -> this.productServiceImpl.getAllProducts(ProductServiceImplTest.STORE_ID, null, false));
  }

  @Test
  public void findProductByStoreIdAndProductSkuAndMarkForDeleteFalseReadFromPrimaryTest() {
    productServiceImpl.findProductByStoreIdAndProductSkuAndMarkForDeleteFalseReadFromPrimary(STORE_ID, PRODUCT_SKU);
    Mockito.verify(productRepository)
        .findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU, true);
  }

  @Test
  public void getProductReadFromPrimaryNullTest() {
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(true);
    productServiceImpl.getProductReadFromPrimary(STORE_ID, PRODUCT_SKU_1);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_1, true);
    Mockito.verify(skuValidator).isProductSku(PRODUCT_SKU_1);
  }

  @Test
  public void getProductReadFromPrimaryMFDTrueTest() {
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(true);
    product.setMarkForDelete(true);
    Mockito.when(productRepository.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_1, true)).thenReturn(product);
    productServiceImpl.getProductReadFromPrimary(STORE_ID, PRODUCT_SKU_1);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_1, true);
    Mockito.verify(skuValidator).isProductSku(PRODUCT_SKU_1);
  }

  @Test
  public void getProductReadFromPrimaryTest() {
    Mockito.when(skuValidator.isProductSku(PRODUCT_SKU_1)).thenReturn(true);
    Mockito.when(productRepository.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_1, true)).thenReturn(product);
    productServiceImpl.getProductReadFromPrimary(STORE_ID, PRODUCT_SKU_1);
    Mockito.verify(productRepository).findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_1, true);
    Mockito.verify(skuValidator).isProductSku(PRODUCT_SKU_1);
  }

  @Test
  public void findByProductCodeAndSellerCodeTest() {
    Mockito.when(productRepository.findByProductCodeAndMerchantCode(PRODUCT_CODE, MERCHANT_CODE)).thenReturn(product);
    Product result = productServiceImpl.findByProductCodeAndSellerCode(PRODUCT_CODE, MERCHANT_CODE);
    Mockito.verify(productRepository).findByProductCodeAndMerchantCode(PRODUCT_CODE, MERCHANT_CODE);
    Assertions.assertEquals(product, result);
  }

  @Test
  public void isSharedProductFalseTest(){
    Mockito.when(productRepository
            .findFirst2ByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(Collections.singletonList(product));
    SimpleBooleanResponse simpleBooleanResponse =
        productServiceImpl.isSharedProduct(STORE_ID, PRODUCT_CODE, false, MERCHANT_CODE);
    Mockito.verify(productRepository).findFirst2ByStoreIdAndProductCode(STORE_ID,PRODUCT_CODE);
    assertFalse(simpleBooleanResponse.getResult());
  }

  @Test
  public void isSharedProductProductCodeEmptyTest() {
    product.setProductCode(StringUtils.EMPTY);
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE)).thenReturn(product);
    SimpleBooleanResponse simpleBooleanResponse = productServiceImpl.isSharedProduct(STORE_ID, PRODUCT_CODE, true,
      MERCHANT_CODE);
    Mockito.verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_CODE);
    assertFalse(simpleBooleanResponse.getResult());
  }

  @Test
  public void isSharedProductTrueTest(){
    Mockito.when(productRepository
            .findFirst2ByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(Arrays.asList(product, new Product()));
    SimpleBooleanResponse simpleBooleanResponse =
        productServiceImpl.isSharedProduct(STORE_ID, PRODUCT_CODE, false, MERCHANT_CODE);
    Mockito.verify(productRepository).findFirst2ByStoreIdAndProductCode(STORE_ID,PRODUCT_CODE);
    Assertions.assertTrue(simpleBooleanResponse.getResult());
  }

  @Test
  public void isSharedProductTrueFindByProductSkuTest() {
    Mockito.when(productRepository.findFirst2ByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE))
        .thenReturn(Arrays.asList(product, new Product()));
    product.setProductCode(PRODUCT_CODE);
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    SimpleBooleanResponse simpleBooleanResponse = productServiceImpl.isSharedProduct(STORE_ID, PRODUCT_SKU, true,
      MERCHANT_CODE);
    Mockito.verify(productRepository).findFirst2ByStoreIdAndProductCode(STORE_ID, PRODUCT_CODE);
    Mockito.verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Assertions.assertTrue(simpleBooleanResponse.getResult());
  }

  @Test
  public void reconcileProductVariantsTest() throws Exception {
    AddDeleteVariantRetryRequest addDeleteVariantRetryRequest = getAddDeleteVariantRetryRequest();
    ProductDetailResponse productDetailResponse = getProductDetailResponseForVariantReconcilitaion();

    Mockito.when(
        pcbMasterDataService.getProductDetailByProductCodeForAllProductsWithoutCache(REQUEST_ID, USERNAME, PRODUCT_CODE,
            true)).thenReturn(new MasterDataCacheVo(productDetailResponse, null));
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(getItems());
    Mockito.when(itemPickupPointService.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(getItemPickupPoints());
    Mockito.when(objectConverterService.convertToMasterDataItems(productDetailResponse.getProductItemResponses(),
        productDetailResponse.getProductCode())).thenReturn(ImmutableMap.of(SKU_CODE_2, masterDataItem));
    Mockito.when(productHelperService.addItemAttributeToProductAttribute(product, ITEM_SKU_2,
        masterDataItem.getMasterDataItemAttributeValues())).thenReturn(product);
    Mockito.when(businessPartnerPickupPointService.getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID,
        Arrays.asList(PICKUP_POINT_CODE_1))).thenReturn(new ArrayList<>());
    Mockito.when(productRepository.saveAll(productListArgumentCaptor.capture())).thenReturn(Arrays.asList(product));
    Mockito.doNothing().when(itemService).saveItems(itemListArgumentCaptor.capture());
    Mockito.when(itemPickupPointService.saveItemPickupPoint(itemPickupPointListArgumentCaptor.capture()))
        .thenReturn(new ArrayList<>());
    Mockito.doNothing().when(cacheEvictHelperService)
        .evictItemPickupPointCache(eq(STORE_ID), itemListArgumentCaptor.capture(),
            itemPickupPointListArgumentCaptor.capture());
    Mockito.doNothing().when(cacheEvictHelperService)
        .evictItemData(eq(STORE_ID), itemArgumentCaptor.capture());
    Mockito.doNothing().when(cacheEvictHelperService).evictProductData(eq(STORE_ID), productArgumentCaptor.capture());
    Mockito.doNothing().when(saveAndPublishService).publishItemDataChangeEvent(itemListArgumentCaptor.capture());
    Mockito.doNothing().when(saveAndPublishService)
        .publishItemPickupPointDataChangeEvent(itemPickupPointListArgumentCaptor.capture(),
            eq(new ArrayList<>()), eq(Collections.EMPTY_MAP));
    Mockito.doNothing().when(productAndItemSolrIndexerService)
        .updateProductAndItemDetailsInSolr(productArgumentCaptor.capture(), itemListArgumentCaptor.capture(),
            eq(false));

    productServiceImpl.reconcileProductVariants(STORE_ID, REQUEST_ID, USERNAME, addDeleteVariantRetryRequest);

    Mockito.verify(pcbMasterDataService)
        .getProductDetailByProductCodeForAllProductsWithoutCache(REQUEST_ID, USERNAME, PRODUCT_CODE, true);
    Mockito.verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(itemPickupPointService).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(objectConverterService).convertToMasterDataItems(productDetailResponse.getProductItemResponses(),
        productDetailResponse.getProductCode());
    Mockito.verify(productHelperService)
        .addItemAttributeToProductAttribute(product, ITEM_SKU_2, masterDataItem.getMasterDataItemAttributeValues());
    Mockito.verify(businessPartnerPickupPointService)
        .getBusinessPartnerPickupPointByPickupPointCodes(STORE_ID, Arrays.asList(PICKUP_POINT_CODE_1));
    Mockito.verify(productRepository).saveAll(productListArgumentCaptor.capture());
    Mockito.verify(itemService).saveItems(itemListArgumentCaptor.capture());
    Mockito.verify(itemPickupPointService).saveItemPickupPoint(itemPickupPointListArgumentCaptor.capture());
    Mockito.verify(cacheEvictHelperService).evictItemPickupPointCache(eq(STORE_ID), itemListArgumentCaptor.capture(),
        itemPickupPointListArgumentCaptor.capture());
    Mockito.verify(cacheEvictHelperService, times(3))
        .evictItemData(eq(STORE_ID), itemArgumentCaptor.capture());
    Mockito.verify(cacheEvictHelperService).evictProductData(eq(STORE_ID), productArgumentCaptor.capture());
    Mockito.verify(saveAndPublishService).publishItemDataChangeEvent(itemListArgumentCaptor.capture());
    Mockito.verify(saveAndPublishService)
        .publishItemPickupPointDataChangeEvent(itemPickupPointListArgumentCaptor.capture(), eq(new ArrayList<>()),
          eq(Collections.EMPTY_MAP));
    Mockito.verify(productAndItemSolrIndexerService)
        .updateProductAndItemDetailsInSolr(productArgumentCaptor.capture(), itemListArgumentCaptor.capture(), eq(false));
  }

  @Test
  public void reconcileProductVariantsNonCncPPCodeTest() throws Exception {
    AddDeleteVariantRetryRequest addDeleteVariantRetryRequest = getAddDeleteVariantRetryRequest();
    ProductDetailResponse productDetailResponse = getProductDetailResponseForVariantReconcilitaion();
    List<ItemPickupPoint> itemPickupPointList = getItemPickupPoints();
    itemPickupPointList.forEach(ipp -> ipp.setCncActive(false));

    Mockito.when(
        pcbMasterDataService.getProductDetailByProductCodeForAllProductsWithoutCache(REQUEST_ID, USERNAME, PRODUCT_CODE,
            true)).thenReturn(new MasterDataCacheVo(productDetailResponse, null));
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    Mockito.when(itemService.findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(getItems());
    Mockito.when(itemPickupPointService.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
        .thenReturn(itemPickupPointList);
    Mockito.when(objectConverterService.convertToMasterDataItems(productDetailResponse.getProductItemResponses(),
        productDetailResponse.getProductCode())).thenReturn(ImmutableMap.of(SKU_CODE_2, masterDataItem));
    Mockito.when(productHelperService.addItemAttributeToProductAttribute(product, ITEM_SKU_2,
        masterDataItem.getMasterDataItemAttributeValues())).thenReturn(product);
    Mockito.when(productRepository.saveAll(productListArgumentCaptor.capture())).thenReturn(Arrays.asList(product));
    Mockito.doNothing().when(itemService).saveItems(itemListArgumentCaptor.capture());
    Mockito.when(itemPickupPointService.saveItemPickupPoint(itemPickupPointListArgumentCaptor.capture()))
        .thenReturn(new ArrayList<>());
    Mockito.doNothing().when(cacheEvictHelperService)
        .evictItemPickupPointCache(eq(STORE_ID), itemListArgumentCaptor.capture(),
            itemPickupPointListArgumentCaptor.capture());
    Mockito.doNothing().when(cacheEvictHelperService)
        .evictItemData(eq(STORE_ID), itemArgumentCaptor.capture());
    Mockito.doNothing().when(cacheEvictHelperService).evictProductData(eq(STORE_ID), productArgumentCaptor.capture());
    Mockito.doNothing().when(saveAndPublishService).publishItemDataChangeEvent(itemListArgumentCaptor.capture());
    Mockito.doNothing().when(saveAndPublishService)
        .publishItemPickupPointDataChangeEvent(itemPickupPointListArgumentCaptor.capture(),
            eq(new ArrayList<>()), eq(Collections.EMPTY_MAP));
    Mockito.doNothing().when(productAndItemSolrIndexerService)
        .updateProductAndItemDetailsInSolr(productArgumentCaptor.capture(), itemListArgumentCaptor.capture(),
            eq(false));

    productServiceImpl.reconcileProductVariants(STORE_ID, REQUEST_ID, USERNAME, addDeleteVariantRetryRequest);

    Mockito.verify(pcbMasterDataService)
        .getProductDetailByProductCodeForAllProductsWithoutCache(REQUEST_ID, USERNAME, PRODUCT_CODE, true);
    Mockito.verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(itemService).findItemsByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(itemPickupPointService).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(objectConverterService).convertToMasterDataItems(productDetailResponse.getProductItemResponses(),
        productDetailResponse.getProductCode());
    Mockito.verify(productHelperService)
        .addItemAttributeToProductAttribute(product, ITEM_SKU_2, masterDataItem.getMasterDataItemAttributeValues());
    Mockito.verify(productRepository).saveAll(productListArgumentCaptor.capture());
    Mockito.verify(itemService).saveItems(itemListArgumentCaptor.capture());
    Mockito.verify(itemPickupPointService).saveItemPickupPoint(itemPickupPointListArgumentCaptor.capture());
    Mockito.verify(cacheEvictHelperService).evictItemPickupPointCache(eq(STORE_ID), itemListArgumentCaptor.capture(),
        itemPickupPointListArgumentCaptor.capture());
    Mockito.verify(cacheEvictHelperService, times(3))
        .evictItemData(eq(STORE_ID), itemArgumentCaptor.capture());
    Mockito.verify(cacheEvictHelperService).evictProductData(eq(STORE_ID), productArgumentCaptor.capture());
    Mockito.verify(saveAndPublishService).publishItemDataChangeEvent(itemListArgumentCaptor.capture());
    Mockito.verify(saveAndPublishService)
        .publishItemPickupPointDataChangeEvent(itemPickupPointListArgumentCaptor.capture(), eq(new ArrayList<>()),
          eq(Collections.EMPTY_MAP));
    Mockito.verify(productAndItemSolrIndexerService)
        .updateProductAndItemDetailsInSolr(productArgumentCaptor.capture(), itemListArgumentCaptor.capture(), eq(false));
  }

  private AddDeleteVariantRetryRequest getAddDeleteVariantRetryRequest() {
    ItemActivationRequest itemActivationRequest1 =
        ItemActivationRequest.builder().merchantCode(MERCHANT_CODE).itemCode(SKU_CODE_1).itemSku(ITEM_SKU_1)
            .markForDelete(true).build();
    ItemActivationRequest itemActivationRequest2 =
        ItemActivationRequest.builder().merchantCode(MERCHANT_CODE).itemCode(SKU_CODE_2).itemSku(ITEM_SKU_2).build();
    ItemActivationRequest itemActivationRequest3 =
        ItemActivationRequest.builder().merchantCode(MERCHANT_CODE).itemCode(SKU_CODE_3).itemSku(ITEM_SKU_3).build();

    return AddDeleteVariantRetryRequest.builder().productCode(PRODUCT_CODE).productSku(PRODUCT_SKU)
        .itemActivationRequestList(
            Arrays.asList(itemActivationRequest1, itemActivationRequest2, itemActivationRequest3)).build();
  }

  private ProductDetailResponse getProductDetailResponseForVariantReconcilitaion() {
    ProductItemResponse productItemResponse1 = new ProductItemResponse();
    productItemResponse1.setSkuCode(SKU_CODE_1);
    productItemResponse1.setMarkForDelete(true);

    ProductItemResponse productItemResponse2 = new ProductItemResponse();
    productItemResponse2.setSkuCode(SKU_CODE_2);

    CategoryResponse categoryResponse = new CategoryResponse();
    ProductCategoryResponse productCategoryResponse  = new ProductCategoryResponse();
    productCategoryResponse.setCategory(categoryResponse);

    ProductDetailResponse productDetailResponse = new ProductDetailResponse();
    productDetailResponse.setProductItemResponses(Set.of(productItemResponse1, productItemResponse2));
    productDetailResponse.setProductCategoryResponses(Arrays.asList(productCategoryResponse));
    productDetailResponse.setLength(10.0);
    productDetailResponse.setWidth(10.0);
    productDetailResponse.setHeight(10.0);
    productDetailResponse.setWeight(10.0);
    productDetailResponse.setShippingWeight(10.0);

    return productDetailResponse;
  }

  private List<Item> getItems() {
    Item item1 = new Item();
    item1.setItemCode(SKU_CODE_1);
    item1.setItemSku(ITEM_SKU_1);

    Item item2 = new Item();
    item2.setItemCode(SKU_CODE_2);
    item2.setItemSku(ITEM_SKU_2);

    Item item3 = new Item();
    item3.setItemCode(SKU_CODE_3);
    item3.setItemSku(ITEM_SKU_3);

    return Arrays.asList(item1, item2, item3);
  }

  private List<ItemPickupPoint> getItemPickupPoints() {


    ItemViewConfig itemViewConfig1 = new ItemViewConfig();
    itemViewConfig1.setBuyable(true);
    itemViewConfig1.setChannel(Constants.DEFAULT_CHANNEL);

    ItemViewConfig itemViewConfig2 = new ItemViewConfig();
    itemViewConfig2.setDiscoverable(true);
    itemViewConfig2.setChannel(Constants.DEFAULT_CHANNEL);

    ItemViewConfig itemViewConfig3 = new ItemViewConfig();
    itemViewConfig3.setChannel(Constants.DEFAULT_CHANNEL);

    ItemViewConfig itemViewConfig4 = new ItemViewConfig();
    itemViewConfig4.setChannel(Constants.B2B);
    itemViewConfig4.setBuyable(true);

    ItemViewConfig itemViewConfig5 = new ItemViewConfig();
    itemViewConfig5.setChannel(Constants.B2B);
    itemViewConfig5.setDiscoverable(true);

    ItemPickupPoint itemPickupPoint1 =
        ItemPickupPoint.builder().itemSku(ITEM_SKU_1).pickupPointCode(PICKUP_POINT_CODE_1).cncActive(true)
            .itemViewConfig(Set.of(itemViewConfig1)).price(new HashSet<>()).build();
    ItemPickupPoint itemPickupPoint2 =
        ItemPickupPoint.builder().itemSku(ITEM_SKU_2).pickupPointCode(PICKUP_POINT_CODE_1)
            .itemViewConfig(Set.of(itemViewConfig2, itemViewConfig5)).price(new HashSet<>()).build();
    ItemPickupPoint itemPickupPoint3 =
        ItemPickupPoint.builder().itemSku(ITEM_SKU_2).pickupPointCode(PICKUP_POINT_CODE_1)
            .itemViewConfig(Set.of(itemViewConfig3, itemViewConfig4)).price(new HashSet<>()).cncActive(true).build();


    return Arrays.asList(itemPickupPoint1, itemPickupPoint2, itemPickupPoint3);
  }

  @Test
  public void updateUmkmProductCatalogRecatMakingL5OfflineTest() {
    ReflectionTestUtils.setField(productServiceImpl,"bopisCategoryActionOnInternalCategoryChangeSwitch",true);
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
        "CM");
    productSync.setProductType(ProductType.BOPIS);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    listOfItems.get(0).setCategoryCode(CATEGORY_CODE_UPDATED);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    profileResponse1 = new ProfileResponse();
    CompanyDTO companyDTO = new CompanyDTO();
    List<String> salesChannel = new ArrayList<>();
    companyDTO.setMerchantType("CM");
    companyDTO.setSalesChannel(salesChannel);
    profileResponse1.setCompany(companyDTO);
    when(mandatoryParameterHelper.getUsername()).thenReturn("usename");
    when(mandatoryParameterHelper.getRequestId()).thenReturn("requestId");
    when(xbpOutbound.getBusinessPartnerDetails(any(),any(),
        any(),any())).thenReturn(profileResponse1);
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping,
            Collections.singletonList(productCategoryDomainEventModel), false);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    verify(itemService).updateCategoryCodeByItemSkuList(any(), any(), any());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(any(),
            Mockito.any(),Mockito.anyBoolean());
    assertEquals(CATALOG_CODE, productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCatalogCode());
    verify(xbpOutbound).getBusinessPartnerDetails(any(),any(),
        any(),any());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductCatalogRecatMakingL5OfflineSwitchOffTest() {
    ReflectionTestUtils.setField(productServiceImpl, "bopisCategoryValidationMerchantTypes",
        "CM");
    ReflectionTestUtils.setField(productServiceImpl,"bopisCategoryActionOnInternalCategoryChangeSwitch",true);
    productSync.setProductType(ProductType.BOPIS);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    listOfItems.get(0).setCategoryCode(CATEGORY_CODE_UPDATED);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(xbpOutbound.getBusinessPartnerDetails(any(),any(),
        any(),any())).thenReturn(profileResponse1);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping,
            Collections.singletonList(productCategoryDomainEventModel), false);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    verify(itemService).updateCategoryCodeByItemSkuList(any(), any(), any());
    verify(xbpOutbound).getBusinessPartnerDetails(any(),any(),
        any(),any());
    assertEquals(CATALOG_CODE, productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCatalogCode());
    assertNotNull(result);
  }

  @Test
  public void updateUmkmProductCatalogRecatMakingL5OfflineProductNotBopisTest() {
    ReflectionTestUtils.setField(productServiceImpl,"bopisCategoryActionOnInternalCategoryChangeSwitch",true);
    productSync.setProductType(ProductType.REGULAR);
    productSalesCategoryMapping.setNewSalesCategoryCodes(new ArrayList<>());
    productSync.getSalesCatalogs().get(0).getListOfCategories().add(new Category(OLD_CAT_1, OLD_CAT_1));
    when(this.productRepository.findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED)).thenReturn(Collections.singletonList(productSync));
    listOfItems.get(0).setCategoryCode(CATEGORY_CODE_UPDATED);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku()))
        .thenReturn(listOfItems);
    when(businessPartnerService.isBusinessPartnerUmkmAndB2b(anyString(), anyString())).thenReturn(Pair.of(true, false));
    Boolean result = this.productServiceImpl
        .updateProductCatalogByProductCodeOnCategoryChange(ProductServiceImplTest.STORE_ID,
            ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED, productSalesCategoryMapping,
            Collections.singletonList(productCategoryDomainEventModel), false);
    verify(this.productRepository).findByStoreIdAndProductCode(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_CODE_TOBE_UPDATED);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        eq(StringUtils.EMPTY), eq(Collections.EMPTY_MAP));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(productSync, listOfItems, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, productSync.getProductSku());
    verify(businessPartnerService).isBusinessPartnerUmkmAndB2b(anyString(), anyString());
    verify(itemService).updateCategoryCodeByItemSkuList(any(), any(), any());
    assertEquals(CATALOG_CODE, productArgumentCaptor.getAllValues().get(0).getMasterCatalog().getCatalogCode());
    assertNotNull(result);
  }

  @Test()
  public void migrateProductAndL5DetailByProductSkuNullTest() throws JsonProcessingException {
    ApplicationRuntimeException exception =
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> {
        productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID,
          productAndL5MigrationRequest);
      });
  }

  @Test()
  public void migrateProductAndL5DetailByProductSkuNullValueTest() throws JsonProcessingException {
    ApplicationRuntimeException exception =
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> {
        productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID,
          productAndL5MigrationRequest);
      });
  }

  @Test()
  public void migrateProductAndL5DetailByProductSkuProductNotFoundTest()
    throws JsonProcessingException {
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID,
      PRODUCT_SKU, false)).thenReturn(null);
    ApplicationRuntimeException exception =
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> {
        productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID,
          productAndL5MigrationRequest);
      });
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(
      STORE_ID, PRODUCT_SKU, false);
  }

  @Test
  public void migrateProductAndL5DetailByProductSkuProductUpdatedTest()
    throws JsonProcessingException {
    productAndL5MigrationRequest.setDimensionsMissing(true);
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      false)).thenReturn(product);
    productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID, productAndL5MigrationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      false);
    verify(this.saveOperationService).saveProduct(product);
  }

  @Test()
  public void migrateProductAndL5DetailByProductSkuProductTypeUpdatedTest()
    throws JsonProcessingException {
    productAndL5MigrationRequest.setDimensionsMissing(true);
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    productAndL5MigrationRequest.setProductType(ProductType.REGULAR);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID,
      PRODUCT_SKU)).thenReturn(new ArrayList<>());
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID,
      PRODUCT_SKU, false)).thenReturn(product);

    ApplicationRuntimeException exception =
      Assertions.assertThrows(ApplicationRuntimeException.class, () -> {
        productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID,
          productAndL5MigrationRequest);
      });
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(
      STORE_ID, PRODUCT_SKU, false);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSkuAndMarkForDeleteFalse(
      STORE_ID, PRODUCT_SKU);
  }

  @Test
  public void migrateProductAndL5DetailByProductSkuProductTypeUpdatedItemupdatedTest()
    throws JsonProcessingException {
    productAndL5MigrationRequest.setDimensionsMissing(true);
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    productAndL5MigrationRequest.setProductType(ProductType.REGULAR);
    productAndL5MigrationRequest.setIncludeMfd(true);
    when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(
      Arrays.asList(item));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true)).thenReturn(product);
    productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID, productAndL5MigrationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true);
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProduct(product);
    verify(saveOperationService).saveItemsWithoutUpdatingSolr(eq(List.of(item)));
  }
  @Test()
  public void migrateProductAndL5DetailByProductSkuL5UpdatedTest() throws JsonProcessingException {
    productAndL5MigrationRequest.setDimensionsMissing(true);
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    productAndL5MigrationRequest.setL5Updated(true);
    when(itemPickupPointService.getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(
      new ArrayList<>());
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      false)).thenReturn(product);
    ApplicationRuntimeException exception =
      Assertions.assertThrows(ApplicationRuntimeException.class,
      () -> {
      productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID, productAndL5MigrationRequest);
    });
    verify(this.itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
      verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID,
        PRODUCT_SKU, false);
  }
  @Test
  public void migrateProductAndL5DetailByProductSkuItemPickupPointupdatedTest()
    throws JsonProcessingException {
    itemViewConfigList = new HashSet<>(Arrays.asList(
      new ItemViewConfig(false, true, "DEFAULT", new ItemDiscoverableSchedule(),
        new ItemBuyableSchedule()),
      new ItemViewConfig(false, true, Constants.B2B, new ItemDiscoverableSchedule(),
        new ItemBuyableSchedule())));
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    productAndL5MigrationRequest.setDimensionsMissing(true);
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    productAndL5MigrationRequest.setIncludeMfd(true);
    productAndL5MigrationRequest.setL5Updated(true);
    productAndL5MigrationRequest.setBuyable(true);
    productAndL5MigrationRequest.setDiscoverable(false);
    when(itemPickupPointService.getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(
      Arrays.asList(itemPickupPoint));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true)).thenReturn(product);
    productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID, productAndL5MigrationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true);
    verify(this.itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProduct(product);
    verify(itemPickupPointService).saveItemPickupPoint(anyList());
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(anyList(), anyList(),
      eq(Collections.EMPTY_MAP));
    verify(saveAndPublishService).publishViewConfigChange(itemPickupPoint);
  }

  @Test
  public void migrateProductAndL5DetailByProductSkuItemPickupPointScheduleUpdatedTest()
    throws JsonProcessingException {
    ItemPickupPoint itemPickupPoint2 = itemPickupPoint ;
    itemPickupPoint2.setOfflineItemId(PRODUCT_ITEM_ID);
    itemViewConfigList = new HashSet<>(Arrays.asList(new ItemViewConfig(true, false, Constants.DEFAULT_CHANNEL,
        new ItemDiscoverableSchedule(true, Date.from(Instant.now().plus(Duration.ofDays(1))),
          Date.from(Instant.now().plus(Duration.ofDays(3)))),
        new ItemBuyableSchedule(true, Date.from(Instant.now().plus(Duration.ofDays(1))),
          Date.from(Instant.now().plus(Duration.ofDays(3))))),
      new ItemViewConfig(false, true, Constants.B2B, new ItemDiscoverableSchedule(),
        new ItemBuyableSchedule(true, new Date(), new Date()))));
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    itemPickupPoint.setOfflineItemId(ITEM_SKU_OFFLINE_ITEM);
    productAndL5MigrationRequest.setDimensionsMissing(true);
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    productAndL5MigrationRequest.setIncludeMfd(true);
    productAndL5MigrationRequest.setL5Updated(true);
    productAndL5MigrationRequest.setBuyable(false);
    productAndL5MigrationRequest.setDiscoverable(true);
    when(itemPickupPointService.getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(
      Arrays.asList(itemPickupPoint, itemPickupPoint2));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true)).thenReturn(product);
    productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID, productAndL5MigrationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true);
    verify(this.itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProduct(product);
    verify(itemPickupPointService).saveItemPickupPoint(anyList());
    verify(saveAndPublishService).publishItemPickupPointDataChangeEvent(anyList(), anyList(),
      eq(Collections.EMPTY_MAP));
    verify(saveAndPublishService).publishViewConfigChange(itemPickupPoint);
  }

  @Test
  public void migrateProductAndL5DetailByProductSkuItemPickupPointNotUpdateTest()
    throws JsonProcessingException {
    itemViewConfigList = new HashSet<>(Arrays.asList(new ItemViewConfig(false, false, "DEFAULT", null, null),
      new ItemViewConfig(false, false, Constants.B2B, null, null)));
    itemPickupPoint.setItemViewConfig(itemViewConfigList);
    productAndL5MigrationRequest.setDimensionsMissing(true);
    productAndL5MigrationRequest.setProductSku(PRODUCT_SKU);
    productAndL5MigrationRequest.setIncludeMfd(true);
    productAndL5MigrationRequest.setL5Updated(true);
    when(itemPickupPointService.getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(
      Arrays.asList(itemPickupPoint));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true)).thenReturn(product);
    productServiceImpl.migrateProductAndL5DetailByProductSku(STORE_ID, productAndL5MigrationRequest);
    verify(this.productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, PRODUCT_SKU,
      true);
    verify(this.itemPickupPointService).getItemPickupPointsByProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProduct(product);
  }

  @Test
  public void handleFieldChangeWithInvalidFieldChangeTest() throws JsonProcessingException {
    String invalidFieldChange = "INVALID_FIELD_CHANGE";
    ItemPickupPoint l5 = new ItemPickupPoint();
    ItemViewConfig defaultViewConfig = new ItemViewConfig();
    List<AuditTrailDto> auditTrailResponseList = new ArrayList<>();
    productServiceImpl.handleFieldChange(invalidFieldChange, l5, defaultViewConfig, auditTrailResponseList);
    assertTrue(auditTrailResponseList.isEmpty(), "Expected no changes to the audit trail response list");
  }

  @Test
  public void handleFieldChangeWithFieldChangeTest() throws JsonProcessingException {
    ItemPickupPoint l5 = new ItemPickupPoint();
    ItemViewConfig defaultViewConfig = new ItemViewConfig();
    List<AuditTrailDto> auditTrailResponseList = new ArrayList<>();
    productServiceImpl.handleFieldChange(ItemPickupPointChangeEventType.VARIANT_CHANGE.getName(), l5,
      defaultViewConfig,
      auditTrailResponseList);
    assertTrue(auditTrailResponseList.isEmpty(), "Expected no changes to the audit trail response list");
  }

  @Test
  public void isPromoItemAvailableEmptyProductSku() {
    Map<String, Set<String>> emptyMap = new HashMap<>();
    PromoEligibilityResponse response = productServiceImpl.isPromoItemAvailable(STORE_ID, emptyMap);
    assertTrue(response.getPromoEligibility().isEmpty());
  }
    @Test
    public void isPromoItemAvaiableEmptyPromoItemsSku() {
      ProductSolr productSolrWithoutPromo = new ProductSolr();
      productSolrWithoutPromo.setProductSku(PRODUCT_SKU);
      productSolrWithoutPromo.setPromoItemSkus(Collections.emptyList());
      Map<String, Set<String>> businessPartnerProductSkuList = new HashMap<>();
      businessPartnerProductSkuList.put(MERCHANT_CODE, Set.of(PRODUCT_SKU));
      when(productSolrRepository.findByProductSkuListForMFDTrueAndFalse(STORE_ID, MERCHANT_CODE, Set.of(PRODUCT_SKU)))
          .thenReturn(List.of(productSolrWithoutPromo));
      PromoEligibilityResponse response = productServiceImpl.isPromoItemAvailable(STORE_ID, businessPartnerProductSkuList);
      assertFalse(response.getPromoEligibility().get(PRODUCT_SKU));
      verify(productSolrRepository).findByProductSkuListForMFDTrueAndFalse(STORE_ID, MERCHANT_CODE, Set.of(PRODUCT_SKU));
    }
    @Test
    public void isPromoItemAvaiableNotEmptyPromoItemsSku() {
      ProductSolr productSolrWithPromo = new ProductSolr();
      productSolrWithPromo.setProductSku(PRODUCT_SKU);
      productSolrWithPromo.setPromoItemSkus(List.of("promoSku1"));
      Map<String, Set<String>> businessPartnerProductSkuList = new HashMap<>();
      businessPartnerProductSkuList.put(MERCHANT_CODE, Set.of(PRODUCT_SKU));
      when(productSolrRepository.findByProductSkuListForMFDTrueAndFalse(STORE_ID, MERCHANT_CODE, Set.of(PRODUCT_SKU)))
          .thenReturn(List.of(productSolrWithPromo));
      PromoEligibilityResponse response = productServiceImpl.isPromoItemAvailable(STORE_ID, businessPartnerProductSkuList);
      assertTrue(response.getPromoEligibility().get(PRODUCT_SKU));
      verify(productSolrRepository).findByProductSkuListForMFDTrueAndFalse(STORE_ID, MERCHANT_CODE, Set.of(PRODUCT_SKU));
    }

  @Test
  public void addProductAndItemsOdooTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "odooCreationEventEnabled", true);
    productAndItemsVO.getProduct().setPreOrder(preOrder);
    productAndItemsVO.getProduct().getPreOrder().setIsPreOrder(false);
    when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
        ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode()))
        .thenReturn(this.productDetailResponse);
    when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
        businessPartner);
    when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), eq(this.productSync), eq(this.productDetailResponse),
        eq(businessPartner))).thenReturn(
        new ArrayList<>());
    this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
        ProductServiceImplTest.USERNAME,
        generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));
    verify(this.productHelperService)
        .setProductDetail(eq(ProductServiceImplTest.REQUEST_ID), eq(ProductServiceImplTest.USERNAME),
            eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class), eq(this.productDetailResponse));
    verify(this.itemService).addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
        eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC),
        anyList(), productArgumentCaptor.capture(), eq(this.productDetailResponse),
        eq(businessPartner));
    verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
    verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
    verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
    verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_SYNC);
    verify(saveAndPublishService).publishOdooCreationEvent(Mockito.any());
    verify(objectConverterService).convertToOdooCreationEventModel(Mockito.any(),Mockito.any());
  }


  @Test
  public void addProductAndItemsOdooExceptionTest() throws Exception {
      ReflectionTestUtils.setField(productServiceImpl, "odooCreationEventEnabled", true);
      productAndItemsVO.getProduct().setPreOrder(preOrder);
      productAndItemsVO.getProduct().getPreOrder().setIsPreOrder(false);
      when(this.masterDataService.getProductDetailFromMasterData(ProductServiceImplTest.USERNAME,
          ProductServiceImplTest.REQUEST_ID, this.productSync.getProductCode())).thenReturn(this.productDetailResponse);
      when(businessPartnerService.getBusinessPartnerByBusinessPartnerCode(anyString(), anyString())).thenReturn(
          businessPartner);
      when(this.itemService.addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
          eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC), anyList(),
          eq(this.productSync), eq(this.productDetailResponse), eq(businessPartner))).thenReturn(new ArrayList<>());
      Mockito.doThrow(ApplicationRuntimeException.class).when(objectConverterService)
          .convertToOdooCreationEventModel(Mockito.any(),Mockito.any());
      this.productServiceImpl.addProductAndItems(ProductServiceImplTest.STORE_ID, ProductServiceImplTest.REQUEST_ID,
          ProductServiceImplTest.USERNAME,
          generateProductItemVo(productAndItemsVO.getProduct(), productAndItemsVO.getItems().get(0), itemPickupPoint));
      verify(this.productHelperService).setProductDetail(eq(ProductServiceImplTest.REQUEST_ID),
          eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.STORE_ID), any(ProductVo.class),
          eq(this.productDetailResponse));
      verify(this.itemService).addItems(eq(ProductServiceImplTest.STORE_ID), eq(ProductServiceImplTest.REQUEST_ID),
          eq(ProductServiceImplTest.USERNAME), eq(ProductServiceImplTest.PRODUCT_SKU_SYNC), anyList(),
          productArgumentCaptor.capture(), eq(this.productDetailResponse), eq(businessPartner));
      verify(businessPartnerService).getBusinessPartnerByBusinessPartnerCode(anyString(), anyString());
      verify(this.objectConverterService).convertToAddProductItemsResponseVo(eq(this.productSync), anyList());
      verify(this.productScoreUtil).getProductScoreByProductScoreRequest(any(ProductScoreRequest.class));
      verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU_SYNC);
      verify(objectConverterService).convertToOdooCreationEventModel(Mockito.any(), Mockito.any());
  }

  @Test
  public void toggleArchiveProductWithNewErrorMessageFlowAndMarkedForDeleteTest() throws Exception {
    ReflectionTestUtils.setField(productServiceImpl, "newErrorMessageInArchiveFlow", true);
    EditItemResponse editItemResponse;
    product.setStoreId(STORE_ID);
    product.setArchived(false);
    product.setProductSku(PRODUCT_SKU);
    product.setMarkForDelete(true);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    editItemResponse = productServiceImpl.toggleArchiveProduct(STORE_ID, USERNAME, PRODUCT_SKU, true,StringUtils.EMPTY);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU);
    Assertions.assertEquals(ApiErrorCode.PRODUCT_IS_NOT_ACTIVE, editItemResponse.getApiErrorCode());
  }

  @Test
  public void toggleArchiveProductWithNewErrorMessageFlowAndNotMarkedForDeleteTest() throws Exception {
    EditItemResponse editItemResponse = new EditItemResponse();
    editItemResponse.setCncActivated(true);
    product.setStoreId(STORE_ID);
    product.setArchived(false);
    product.setProductSku(PRODUCT_SKU);
    product.setMarkForDelete(false);
    ReflectionTestUtils.setField(productServiceImpl, "newErrorMessageInArchiveFlow", true);
    when(this.productCacheableService.findProductByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(this.itemService.toggleArchiveByProductSku(STORE_ID, USERNAME, PRODUCT_SKU, true,StringUtils.EMPTY)).thenReturn(
        editItemResponse);
    editItemResponse = productServiceImpl.toggleArchiveProduct(STORE_ID, USERNAME, PRODUCT_SKU, true,StringUtils.EMPTY);
    verify(this.productCacheableService).findProductByStoreIdAndProductSku(ProductServiceImplTest.STORE_ID,
        ProductServiceImplTest.PRODUCT_SKU);
    verify(this.itemService).toggleArchiveByProductSku(ProductServiceImplTest.STORE_ID, USERNAME,
        ProductServiceImplTest.PRODUCT_SKU, true, StringUtils.EMPTY);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(this.product,
        Arrays.asList(ProductChangeEventType.ARCHIVE_FLAG_CHANGE), StringUtils.EMPTY, Collections.EMPTY_MAP);
    Mockito.verify(saveAndPublishService).publishSolrUpdateEvent(anyList());
    Mockito.verify(objectConverterService).convertToProductAndItemEventModel(any(ProductAndItemsVO.class));
    assertNull(editItemResponse.getApiErrorCode());
  }

  @Test
  void updateFinalVideoDataProductSkuEmptyTest() {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
      VIDEO_URL_CLIENT_ID);
    try {
      productServiceImpl.updateFinalVideoData(new CompressedVideoUpdateEventModel());
    } catch (Exception e) {
      Assertions.assertEquals(ApplicationRuntimeException.class, e.getClass());
    }
  }

  @Test
  void updateFinalVideoDataSuccessTest() {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
      VIDEO_URL_CLIENT_ID);
    Video video = new Video();
    CompressedVideoUpdateEventModel videoUpdateEventModel = new CompressedVideoUpdateEventModel();
    videoUpdateEventModel.setVideoId(VIDEO_ID_1);
    videoUpdateEventModel.setFinalUrl(UPDATED_URL);
    videoUpdateEventModel.setClientId(VIDEO_URL_CLIENT_ID);
    videoUpdateEventModel.setAdditionalFields(Map.of(Constants.PRODUCT_SKU, PRODUCT_SKU));
    product.setVideo(video);
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
      .thenReturn(product);
    Mockito.when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
      .thenReturn(List.of(item));
    productServiceImpl.updateFinalVideoData(videoUpdateEventModel);
    Mockito.verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(saveAndPublishService).publishProduct(product, new ArrayList<>());
    Mockito.verify(cacheEvictHelperService).evictProductData(STORE_ID, product);
    Mockito.verify(cacheItemHelperService)
      .findCacheableByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU);
    Mockito.verify(saveAndPublishService)
      .publishItemDataChangeEvent(List.of(item), StringUtils.EMPTY, false);
    Mockito.verify(productRepository).save(product);
  }

  @Test
  void updateFinalVideoDifferentClientTest() {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
      VIDEO_URL_CLIENT_ID);
    CompressedVideoUpdateEventModel videoUpdateEventModel = new CompressedVideoUpdateEventModel();
    videoUpdateEventModel.setClientId(STORE_ID);
    productServiceImpl.updateFinalVideoData(videoUpdateEventModel);
    Mockito.verify(productRepository, never()).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
  }

  @Test
  void updateFinalVideoDataSourceNullSuccessTest() {
    ReflectionTestUtils.setField(productServiceImpl, "clientIdForVideoCompression",
      VIDEO_URL_CLIENT_ID);
    CompressedVideoUpdateEventModel videoUpdateEventModel = new CompressedVideoUpdateEventModel();
    videoUpdateEventModel.setVideoId(VIDEO_ID_1);
    videoUpdateEventModel.setFinalUrl(UPDATED_URL);
    videoUpdateEventModel.setClientId(VIDEO_URL_CLIENT_ID);
    videoUpdateEventModel.setAdditionalFields(Map.of(Constants.PRODUCT_SKU, PRODUCT_SKU));
    product.setVideo(null);
    Mockito.when(productRepository.findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
      .thenReturn(product);
    Mockito.when(cacheItemHelperService.findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU))
      .thenReturn(List.of(item));
    productServiceImpl.updateFinalVideoData(videoUpdateEventModel);
    Mockito.verify(productRepository).findByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    Mockito.verify(saveAndPublishService).publishProduct(product, new ArrayList<>());
    Mockito.verify(cacheEvictHelperService).evictProductData(STORE_ID, product);
    Mockito.verify(cacheItemHelperService)
      .findCacheableByStoreIdAndProductSku(Constants.DEFAULT_STORE_ID, PRODUCT_SKU);
    Mockito.verify(saveAndPublishService)
      .publishItemDataChangeEvent(List.of(item), StringUtils.EMPTY, false);
    Mockito.verify(productRepository).save(product);
  }

  @Test
  public void testGetProductSkuListResponse_withValidInputAndNonEmptySolrResponse() {
    ProductSummaryRequest productSummaryRequest = new ProductSummaryRequest();
    productSummaryRequest.setMerchantCode(MERCHANT_CODE);
    PageRequest pageRequest = PageRequest.of(0, 10);
    List<ProductSolr> productSolrList = Arrays.asList(new ProductSolr(), new ProductSolr());
    Page<ProductSolr> productSolrPage = new PageImpl<>(productSolrList, pageRequest, productSolrList.size());
    when(productSolrRepository.getProductNameByProductSummaryRequest(eq(STORE_ID),
        any(ProductSummaryRequestVo.class), eq(pageRequest))).thenReturn(productSolrPage);
    Page<ProductSkuResponse> result =
        productServiceImpl.getProductSkuListResponse(STORE_ID, productSummaryRequest, pageRequest);
    assertNotNull(result);
    assertEquals(2, result.getTotalElements());
    verify(productSolrRepository).getProductNameByProductSummaryRequest(eq(STORE_ID),
        any(ProductSummaryRequestVo.class), eq(pageRequest));
  }

  @Test
  public void testGetProductSkuListResponse_withValidInputAndEmptySolrResponse() {
    ProductSummaryRequest productSummaryRequest = new ProductSummaryRequest();
    productSummaryRequest.setMerchantCode(MERCHANT_CODE);
    PageRequest pageRequest = PageRequest.of(0, 10);
    Page<ProductSolr> productSolrPage = new PageImpl<>(Collections.emptyList(), pageRequest, 0);

    when(productSolrRepository.getProductNameByProductSummaryRequest(eq(STORE_ID),
        any(ProductSummaryRequestVo.class), eq(pageRequest))).thenReturn(productSolrPage);
    Page<ProductSkuResponse> result =
        productServiceImpl.getProductSkuListResponse(STORE_ID, productSummaryRequest, pageRequest);
    assertNotNull(result);
    assertEquals(0, result.getTotalElements());
    verify(productSolrRepository).getProductNameByProductSummaryRequest(eq(STORE_ID),
        any(ProductSummaryRequestVo.class), eq(pageRequest));

  }

  @Test
  public void testGetProductSkuListResponse_withInvalidInput() {
    ProductSummaryRequest productSummaryRequest = new ProductSummaryRequest();
    productSummaryRequest.setMerchantCode(""); // Blank merchant code
    PageRequest pageRequest = PageRequest.of(0, 10);
    assertThrows(ApplicationRuntimeException.class, () -> {
      productServiceImpl.getProductSkuListResponse(STORE_ID, productSummaryRequest, pageRequest);
    });
    verifyNoMoreInteractions(productSolrRepository);
  }

  @Test
  void getProductBasicInfoByProductSkus_Success() {
    List<String> productSkuList = Arrays.asList("SKU1", "SKU2");
    ProductLevel3SummaryRequest request = new ProductLevel3SummaryRequest();
    request.setProductSkuList(productSkuList);

    Product product1 = new Product();
    product1.setProductCode("CODE1");
    product1.setProductSku("SKU1");

    Product product2 = new Product();
    product2.setProductCode("CODE2");
    product2.setProductSku("SKU2");

    BasicInfoProductResponse basicInfo1 = new BasicInfoProductResponse();
    basicInfo1.setProductCode("CODE1");

    BasicInfoProductResponse basicInfo2 = new BasicInfoProductResponse();
    basicInfo2.setProductCode("CODE2");

    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU1", false))
        .thenReturn(product1);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU2", false))
        .thenReturn(product2);
    when(productCategoryBaseClient.getBasicInfoProductDetailsListByProductCodes(anyList()))
        .thenReturn(Arrays.asList(basicInfo1, basicInfo2));

    BulkDownloadProductBasicInfoResponse response = productServiceImpl.getProductBasicInfoByProductSkus(STORE_ID, request);

    assertNotNull(response);
    assertEquals(2, response.getProductBasicInfoResponseList().size());
    assertTrue(response.getExceptionMap().isEmpty());

    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU1", false);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU2", false);
    verify(productCategoryBaseClient).getBasicInfoProductDetailsListByProductCodes(anyList());
  }

  @Test
  void getProductBasicInfoByProductSkus_SomeProductsNotFound() {
    List<String> productSkuList = Arrays.asList("SKU1", "SKU2", "SKU3");
    ProductLevel3SummaryRequest request = new ProductLevel3SummaryRequest();
    request.setProductSkuList(productSkuList);

    Product product1 = new Product();
    product1.setProductCode("CODE1");
    product1.setProductSku("SKU1");

    BasicInfoProductResponse basicInfo1 = new BasicInfoProductResponse();
    basicInfo1.setProductCode("CODE1");

    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU1", false))
        .thenReturn(product1);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU2", false))
        .thenReturn(null);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU3", false))
        .thenReturn(null);
    when(productCategoryBaseClient.getBasicInfoProductDetailsListByProductCodes(anyList()))
        .thenReturn(Collections.singletonList(basicInfo1));

    BulkDownloadProductBasicInfoResponse response = productServiceImpl.getProductBasicInfoByProductSkus(STORE_ID, request);

    assertNotNull(response);
    assertEquals(1, response.getProductBasicInfoResponseList().size());
    assertEquals(2, response.getExceptionMap().size());
    assertEquals(PRODUCT_NOT_FOUND, response.getExceptionMap().get("SKU2"));
    assertEquals(PRODUCT_NOT_FOUND, response.getExceptionMap().get("SKU3"));

    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU1", false);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU2", false);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU3", false);
    verify(productCategoryBaseClient).getBasicInfoProductDetailsListByProductCodes(anyList());
  }

  @Test
  void getProductBasicInfoByProductSkus_ProductCodeNotFoundInPCB() {
    List<String> productSkuList = Arrays.asList("SKU1", "SKU2", "SKU3");
    ProductLevel3SummaryRequest request = new ProductLevel3SummaryRequest();
    request.setProductSkuList(productSkuList);

    Product product1 = new Product();
    product1.setProductCode("CODE1");
    product1.setProductSku("SKU1");

    BasicInfoProductResponse basicInfo1 = new BasicInfoProductResponse();
    basicInfo1.setProductCode(null);

    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU1", false))
        .thenReturn(product1);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU2", false))
        .thenReturn(null);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU3", false))
        .thenReturn(null);
    when(productCategoryBaseClient.getBasicInfoProductDetailsListByProductCodes(anyList()))
        .thenReturn(Collections.singletonList(basicInfo1));

    BulkDownloadProductBasicInfoResponse response = productServiceImpl.getProductBasicInfoByProductSkus(STORE_ID, request);

    assertNotNull(response);
    assertEquals(0, response.getProductBasicInfoResponseList().size());
    assertEquals(3, response.getExceptionMap().size());
    assertEquals(PRODUCT_NOT_FOUND, response.getExceptionMap().get("SKU2"));
    assertEquals(PRODUCT_NOT_FOUND, response.getExceptionMap().get("SKU3"));

    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU1", false);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU2", false);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU3", false);
    verify(productCategoryBaseClient).getBasicInfoProductDetailsListByProductCodes(anyList());
  }

  @Test
  void getProductBasicInfoByProductSkus_ExceptionThrown() {
    List<String> productSkuList = Arrays.asList("SKU1", "SKU2");
    ProductLevel3SummaryRequest request = new ProductLevel3SummaryRequest();
    request.setProductSkuList(productSkuList);

    when(productCacheableService.findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(anyString(), anyString(), anyBoolean()))
        .thenThrow(new RuntimeException("Test exception"));

    BulkDownloadProductBasicInfoResponse response = productServiceImpl.getProductBasicInfoByProductSkus(STORE_ID, request);

    assertNotNull(response);
    assertTrue(response.getProductBasicInfoResponseList().isEmpty());
    assertEquals(2, response.getExceptionMap().size());
    assertEquals(PRODUCT_NOT_FOUND, response.getExceptionMap().get("SKU1"));
    assertEquals(PRODUCT_NOT_FOUND, response.getExceptionMap().get("SKU2"));
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndIncludeMarkForDelete(STORE_ID, "SKU1", false);
    verify(productCategoryBaseClient).getBasicInfoProductDetailsListByProductCodes(anyList());
  }

  @Test
  void updateMasterDataInfo_ProductNotFound_ShouldThrowException() {
    ProductBasicMasterFieldsRequest request = new ProductBasicMasterFieldsRequest();
    request.setProductSku(PRODUCT_SKU);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU))
        .thenReturn(null);
    ApplicationRuntimeException exception = assertThrows(ApplicationRuntimeException.class, () ->
        productServiceImpl.updateMasterDataInfo(STORE_ID, REQUEST_ID, USERNAME, request)
    );
    assertTrue(exception.getMessage().contains(PRODUCT_NOT_FOUND + PRODUCT_SKU));
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
  }

  @Test
  void updateMasterDataInfo_Success_FieldsAreChanged() throws Exception {
    ProductBasicMasterFieldsRequest request = new ProductBasicMasterFieldsRequest();
    request.setProductSku(PRODUCT_SKU);
    request.setInstore(false);
    request.setSizeChartCode(SIZE_CHART_CODE);
    request.setProductType(ProductType.REGULAR);
    request.setGenerateProductScoreNeeded(false);

    Product product = new Product();
    product.setOff2OnChannelActive(true);
    product.setSizeChartCode(SIZE_CHART_CODE1);
    product.setProductType(ProductType.BOPIS);
    product.setMerchantCode(MERCHANT_CODE);
    product.setProductSku(PRODUCT_SKU);
    product.setProductName(PRODUCT_NAME);
    List<AuditTrailDto> auditTrailDtoList = new ArrayList<>();
    auditTrailDtoList.add(new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.OFF_2ON_ACTIVE_CHANGED,
        String.valueOf(product.isOff2OnChannelActive()), String.valueOf(request.isInstore()), null,
        product.getProductSku(), product.getProductName()));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(objectConverterService.convertToProductAndItemEventModel(new ProductAndItemsVO(Mockito.any(), new ArrayList<>()))).thenReturn(new ProductAndItemEventModel());
    listOfItems.get(0).setStoreId(STORE_ID);
    when(itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku())).thenReturn(this.listOfItems);
    productServiceImpl.updateMasterDataInfo(STORE_ID, REQUEST_ID, USERNAME, request);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        Mockito.anyString(), eq(Collections.EMPTY_MAP));
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku());
    verify(itemService).saveItems(Mockito.anyList());
    verify(objectConverterService).convertToProductAndItemEventModel(productAndItemsVOArgumentCaptor.capture());
    verify(saveAndPublishService).publishSolrUpdateEvent(Collections.singletonList(new ProductAndItemEventModel()));
    verify(cacheEvictHelperService).evictItemData(eq(STORE_ID), Mockito.any());
    Mockito.verify(kafkaProducer).send(Mockito.any(),
        auditTrailListResponseArgumentCaptor.capture());
    AuditTrailListResponse capturedResponse = auditTrailListResponseArgumentCaptor.getValue();
    Assertions.assertEquals(USERNAME, capturedResponse.getChangedBy());
    Assertions.assertEquals(false, productArgumentCaptor.getValue().isOff2OnChannelActive());
  }

  @Test
  void updateMasterDataInfo_Success_SizeChartCodeIsAdded() throws Exception {
    ProductBasicMasterFieldsRequest request = new ProductBasicMasterFieldsRequest();
    request.setProductSku(PRODUCT_SKU);
    request.setInstore(false);
    request.setSizeChartCode(SIZE_CHART_CODE);
    request.setProductType(ProductType.REGULAR);
    request.setGenerateProductScoreNeeded(false);
    request.setLateFulfillment(true);

    Product product = new Product();
    product.setOff2OnChannelActive(true);
    product.setSizeChartCode(StringUtils.EMPTY);
    product.setProductType(ProductType.BOPIS);
    product.setMerchantCode(MERCHANT_CODE);
    product.setProductSku(PRODUCT_SKU);
    product.setProductName(PRODUCT_NAME);
    List<AuditTrailDto> auditTrailDtoList = new ArrayList<>();
    auditTrailDtoList.add(new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.OFF_2ON_ACTIVE_CHANGED,
        String.valueOf(product.isOff2OnChannelActive()), String.valueOf(request.isInstore()), null,
        product.getProductSku(), product.getProductName()));
    auditTrailDtoList.add(new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.OFF_2ON_ACTIVE_CHANGED,
        product.getSizeChartCode(), request.getSizeChartCode(), null,
        product.getProductSku(), product.getProductName()));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(objectConverterService.convertToProductAndItemEventModel(new ProductAndItemsVO(Mockito.any(), new ArrayList<>()))).thenReturn(new ProductAndItemEventModel());
    listOfItems.get(0).setStoreId(STORE_ID);
    when(itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku())).thenReturn(this.listOfItems);
    productServiceImpl.updateMasterDataInfo(STORE_ID, REQUEST_ID, USERNAME, request);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku());
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        Mockito.anyString(), eq(Collections.EMPTY_MAP));
    verify(itemService).saveItems(Mockito.anyList());
    verify(objectConverterService).convertToProductAndItemEventModel(productAndItemsVOArgumentCaptor.capture());
    verify(saveAndPublishService).publishSolrUpdateEvent(Collections.singletonList(new ProductAndItemEventModel()));
    verify(cacheEvictHelperService).evictItemData(eq(STORE_ID), Mockito.any());
    Mockito.verify(kafkaProducer).send(Mockito.any(),
        auditTrailListResponseArgumentCaptor.capture());
    AuditTrailListResponse capturedResponse = auditTrailListResponseArgumentCaptor.getValue();
    Assertions.assertEquals(USERNAME, capturedResponse.getChangedBy());
    Assertions.assertEquals(false, productArgumentCaptor.getValue().isOff2OnChannelActive());
    Assertions.assertEquals(SIZE_CHART_CODE, productArgumentCaptor.getValue().getSizeChartCode());
  }

  @Test
  void updateMasterDataInfo_Success_SizeChartCodeIsDeleted() throws Exception {
    ProductBasicMasterFieldsRequest request = new ProductBasicMasterFieldsRequest();
    request.setProductSku(PRODUCT_SKU);
    request.setInstore(false);
    request.setSizeChartCode(StringUtils.EMPTY);
    request.setProductType(ProductType.REGULAR);
    request.setGenerateProductScoreNeeded(false);
    request.setLateFulfillment(true);

    Product product = new Product();
    product.setOff2OnChannelActive(true);
    product.setSizeChartCode(SIZE_CHART_CODE);
    product.setProductType(ProductType.BOPIS);
    product.setMerchantCode(MERCHANT_CODE);
    product.setProductSku(PRODUCT_SKU);
    product.setProductName(PRODUCT_NAME);
    List<AuditTrailDto> auditTrailDtoList = new ArrayList<>();
    auditTrailDtoList.add(new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.OFF_2ON_ACTIVE_CHANGED,
        String.valueOf(product.isOff2OnChannelActive()), String.valueOf(request.isInstore()), null,
        product.getProductSku(), product.getProductName()));
    auditTrailDtoList.add(new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.OFF_2ON_ACTIVE_CHANGED,
        product.getSizeChartCode(), request.getSizeChartCode(), null,
        product.getProductSku(), product.getProductName()));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(objectConverterService.convertToProductAndItemEventModel(new ProductAndItemsVO(Mockito.any(), new ArrayList<>()))).thenReturn(new ProductAndItemEventModel());
    when(itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku())).thenReturn(new ArrayList<>());
    productServiceImpl.updateMasterDataInfo(STORE_ID, REQUEST_ID, USERNAME, request);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku());
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        Mockito.anyString(), eq(Collections.EMPTY_MAP));
    verify(objectConverterService).convertToProductAndItemEventModel(productAndItemsVOArgumentCaptor.capture());
    verify(saveAndPublishService).publishSolrUpdateEvent(Collections.singletonList(new ProductAndItemEventModel()));
    Mockito.verify(kafkaProducer).send(Mockito.any(),
        auditTrailListResponseArgumentCaptor.capture());
    AuditTrailListResponse capturedResponse = auditTrailListResponseArgumentCaptor.getValue();
    Assertions.assertEquals(USERNAME, capturedResponse.getChangedBy());
    Assertions.assertEquals(false, productArgumentCaptor.getValue().isOff2OnChannelActive());
    Assertions.assertEquals(StringUtils.EMPTY, productArgumentCaptor.getValue().getSizeChartCode());
  }

  @Test
  void updateMasterDataInfo_Success_NoFieldsAreChanged() throws Exception {
    ProductBasicMasterFieldsRequest request = new ProductBasicMasterFieldsRequest();
    request.setProductSku(PRODUCT_SKU);
    request.setInstore(false);
    request.setSizeChartCode(SIZE_CHART_CODE);
    request.setProductType(ProductType.REGULAR);
    request.setGenerateProductScoreNeeded(false);

    Product product = new Product();
    product.setOff2OnChannelActive(false);
    product.setSizeChartCode(SIZE_CHART_CODE);
    product.setProductType(ProductType.REGULAR);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    productServiceImpl.updateMasterDataInfo(STORE_ID, REQUEST_ID, USERNAME, request);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
  }

  @Test
  void updateMasterDataInfo_Success_GenerateProductScore() throws Exception {
    systemParameter.setValue("10");
    ProductBasicMasterFieldsRequest request = new ProductBasicMasterFieldsRequest();
    request.setProductSku(PRODUCT_SKU);
    request.setInstore(false);
    request.setSizeChartCode(SIZE_CHART_CODE);
    request.setProductType(ProductType.REGULAR);
    request.setGenerateProductScoreNeeded(true);

    Product product = new Product();
    product.setProductSku(PRODUCT_SKU);
    product.setOff2OnChannelActive(false);
    product.setSizeChartCode(SIZE_CHART_CODE);
    product.setProductType(ProductType.REGULAR);
    product.setMasterDataProduct(masterDataProduct);
    product.getMasterDataProduct().setDescription(UPDATED_DESCRIPTION);
    product.setMasterCatalog(this.masterCatalog);
    product.getMasterDataProduct().setMasterCatalog(this.masterCatalog);
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(productScoreUtil.getProductScoreByProductScoreRequest(Mockito.any())).thenReturn(productScoreVo);
    when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY)).thenReturn(systemParameter);
    when(systemParameterService.findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE)).thenReturn(systemParameter);
    when(saveOperationService.saveProductWithoutUpdatingSolr(Mockito.any(Product.class), Mockito.anyList(),
        Mockito.anyString(), eq(Collections.EMPTY_MAP))).thenReturn(product);
    productServiceImpl.updateMasterDataInfo(STORE_ID, REQUEST_ID, USERNAME, request);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(productScoreUtil).getProductScoreByProductScoreRequest(Mockito.any());
    verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MADE_NON_MANDATORY);
    verify(systemParameterService).findValueByStoreIdAndVariable(STORE_ID,
        SystemParameterNames.VARIANT_CREATION_MANDATORY_SCORE);
    verify(saveOperationService).saveProductWithoutUpdatingSolr(Mockito.any(Product.class), Mockito.anyList(),
        Mockito.anyString(), eq(Collections.EMPTY_MAP));
    verify(cacheItemHelperService).findCacheableByStoreIdAndProductSku(STORE_ID, PRODUCT_SKU);
    verify(this.productScoreHistoryL3Service).saveProductScoreHistoryL3(eq(STORE_ID), anyString(),
        any(ProductScore.class), any(ProductScore.class));
    verify(this.productAndItemSolrIndexerService).updateProductAndItemDetailsInSolr(product, new ArrayList<>(), true);
  }

  @Test
  void updateMasterDataInfo_Success_UpdateLateFulfillment() throws Exception {
    ProductBasicMasterFieldsRequest request = new ProductBasicMasterFieldsRequest();
    request.setProductSku(PRODUCT_SKU);
    request.setInstore(false);
    request.setSizeChartCode(SIZE_CHART_CODE);
    request.setProductType(ProductType.REGULAR);
    request.setGenerateProductScoreNeeded(false);
    request.setLateFulfillment(true);

    Product product = new Product();
    product.setOff2OnChannelActive(false);
    product.setSizeChartCode(StringUtils.EMPTY);
    product.setProductType(ProductType.BOPIS);
    product.setMerchantCode(MERCHANT_CODE);
    product.setProductSku(PRODUCT_SKU);
    product.setProductName(PRODUCT_NAME);
    List<AuditTrailDto> auditTrailDtoList = new ArrayList<>();
    auditTrailDtoList.add(new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.OFF_2ON_ACTIVE_CHANGED,
        String.valueOf(product.isOff2OnChannelActive()), String.valueOf(request.isInstore()), null,
        product.getProductSku(), product.getProductName()));
    auditTrailDtoList.add(new AuditTrailDto(product.getMerchantCode(), Constants.HYPHEN, Constants.OFF_2ON_ACTIVE_CHANGED,
        product.getSizeChartCode(), request.getSizeChartCode(), null,
        product.getProductSku(), product.getProductName()));
    when(productCacheableService.findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU)).thenReturn(product);
    when(objectConverterService.convertToProductAndItemEventModel(new ProductAndItemsVO(Mockito.any(), new ArrayList<>()))).thenReturn(new ProductAndItemEventModel());
    listOfItems.get(0).setStoreId(STORE_ID);
    when(itemService.findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku())).thenReturn(this.listOfItems);
    productServiceImpl.updateMasterDataInfo(STORE_ID, REQUEST_ID, USERNAME, request);
    verify(productCacheableService).findProductByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, PRODUCT_SKU);
    verify(itemService).findItemsByStoreIdAndProductSkuAndMarkForDeleteFalse(STORE_ID, product.getProductSku());
    verify(this.saveOperationService).saveProductWithoutUpdatingSolr(productArgumentCaptor.capture(), anyList(),
        Mockito.anyString(), eq(Collections.EMPTY_MAP));
    verify(itemService).saveItems(Mockito.anyList());
    verify(objectConverterService).convertToProductAndItemEventModel(productAndItemsVOArgumentCaptor.capture());
    verify(saveAndPublishService).publishSolrUpdateEvent(Collections.singletonList(new ProductAndItemEventModel()));
    verify(cacheEvictHelperService).evictItemData(eq(STORE_ID), Mockito.any());
    Mockito.verify(kafkaProducer).send(Mockito.any(),
        auditTrailListResponseArgumentCaptor.capture());
    AuditTrailListResponse capturedResponse = auditTrailListResponseArgumentCaptor.getValue();
    Assertions.assertEquals(USERNAME, capturedResponse.getChangedBy());
    Assertions.assertEquals(false, productArgumentCaptor.getValue().isOff2OnChannelActive());
    Assertions.assertEquals(SIZE_CHART_CODE, productArgumentCaptor.getValue().getSizeChartCode());
  }

  @Test
  public void getProductDetailsByReelProductListingRequestTest() {
    ReelProductListingRequest request = new ReelProductListingRequest();
    PageRequest pageRequest = PageRequest.of(0, 10);
    when(productSolrRepository.getL3ProductsForReelsByReelProductListingRequest(eq(STORE_ID),
        any(ReelProductListingRequestVo.class), Mockito.eq(pageRequest))).thenReturn(
        productSolrPage);
    Page<ReelProductDetailResponse> response =
        productServiceImpl.getProductDetailsByReelProductListingRequest(STORE_ID, request,
            pageRequest);
    Assertions.assertNotNull(response);
    Assertions.assertEquals(1, response.getContent().size());
    Assertions.assertEquals(PRODUCT_SKU, response.getContent().getFirst().getProductSku());
    Mockito.verify(productSolrRepository)
        .getL3ProductsForReelsByReelProductListingRequest(eq(STORE_ID),
            any(ReelProductListingRequestVo.class), Mockito.eq(pageRequest));
  }
}
